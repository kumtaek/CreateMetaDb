# 예상 리포트

SampleSrc 폴더의 파일들을 수작업으로 분석하여 create_report.py로 생성될 것으로 예상되는 리포트들입니다.

## 1. ERD (Entity Relationship Diagram) 리포트

### 예상 ERD 구조

```mermaid
erDiagram
    USERS ||--o{ ORDERS : "has"
    ORDERS ||--o{ ORDER_ITEMS : "contains"
    PRODUCTS ||--o{ ORDER_ITEMS : "ordered"
    CATEGORIES ||--o{ PRODUCTS : "categorizes"
    BRANDS ||--o{ PRODUCTS : "manufactures"
    SUPPLIERS ||--o{ PRODUCTS : "supplies"
    USERS ||--o{ USER_PROFILES : "has"
    PRODUCTS ||--o{ INVENTORY : "tracked"
    
    USERS {
        varchar user_id PK
        varchar username UK
        varchar email UK
        varchar full_name
        varchar phone
        varchar status
        varchar user_type
        timestamp created_date
        timestamp last_login_date
        char del_yn
    }
    
    PRODUCTS {
        varchar product_id PK
        varchar product_name
        text description
        decimal price
        integer stock_quantity
        varchar status
        varchar category_id FK
        varchar brand_id FK
        varchar supplier_id FK
        timestamp created_date
        char del_yn
    }
    
    ORDERS {
        varchar order_id PK
        varchar user_id FK
        decimal total_amount
        varchar status
        timestamp order_date
        timestamp updated_date
        char del_yn
    }
    
    ORDER_ITEMS {
        varchar order_item_id PK
        varchar order_id FK
        varchar product_id FK
        integer quantity
        decimal unit_price
        decimal total_price
    }
    
    CATEGORIES {
        varchar category_id PK
        varchar category_name
        varchar parent_category_id FK
        integer sort_order
    }
    
    BRANDS {
        varchar brand_id PK
        varchar brand_name
        varchar country
        varchar description
    }
    
    SUPPLIERS {
        varchar supplier_id PK
        varchar supplier_name
        varchar contact_person
        varchar phone
        varchar email
        varchar address
    }
    
    USER_PROFILES {
        varchar profile_id PK
        varchar user_id FK
        date birth_date
        varchar gender
        varchar address
        varchar job_title
        varchar department_id FK
    }
    
    INVENTORY {
        varchar inventory_id PK
        varchar product_id FK
        integer current_stock
        integer reorder_point
        integer max_stock
        timestamp last_updated
    }
```

### ERD 특징
- **총 9개 테이블**로 구성
- **사용자 중심 설계**: USERS를 중심으로 한 주문 관리 시스템
- **상품 관리**: 카테고리, 브랜드, 공급업체별 상품 분류
- **재고 관리**: 별도 INVENTORY 테이블로 재고 추적
- **확장성**: USER_PROFILES로 사용자 상세 정보 확장 가능

## 2. Architecture Layer Diagram 리포트

### 예상 아키텍처 레이어

```mermaid
flowchart TB
    subgraph "Frontend Layer"
        JSP[JSP Pages<br/>user/list.jsp<br/>product/list.jsp]
        VUE[Vue Components<br/>UserManagement.vue]
        JS[JavaScript/TypeScript<br/>ApiService.ts<br/>Utils.ts]
    end
    
    subgraph "Controller Layer"
        CTRL[Spring Controllers<br/>UserController<br/>ProductController<br/>JpaUserController]
        SERVLET[Servlets<br/>UserManagementServlet<br/>ProductCatalogServlet]
    end
    
    subgraph "Service Layer"
        SVC[Business Services<br/>UserService<br/>ProductService<br/>JpaUserService]
    end
    
    subgraph "Data Access Layer"
        DAO[DAO Classes<br/>UserDao<br/>ProductDao]
        REPO[JPA Repositories<br/>UserRepository<br/>ProductRepository]
    end
    
    subgraph "Data Layer"
        MYBATIS[MyBatis Mappers<br/>UserMapper.xml<br/>ProductMapper.xml]
        DB[(Database<br/>MySQL/Oracle)]
    end
    
    JSP --> CTRL
    VUE --> CTRL
    JS --> SERVLET
    
    CTRL --> SVC
    SERVLET --> SVC
    
    SVC --> DAO
    SVC --> REPO
    
    DAO --> MYBATIS
    REPO --> DB
    MYBATIS --> DB
    
    style JSP fill:#e1f5fe
    style VUE fill:#e8f5e8
    style CTRL fill:#fff3e0
    style SERVLET fill:#fce4ec
    style SVC fill:#f3e5f5
    style DAO fill:#e0f2f1
    style REPO fill:#e0f2f1
    style MYBATIS fill:#fff8e1
    style DB fill:#ffebee
```

### 아키텍처 특징
- **5계층 구조**: Frontend → Controller → Service → Data Access → Data
- **하이브리드 접근**: Spring MVC + Servlet + JPA + MyBatis 혼재
- **다양한 Frontend**: JSP + Vue.js 혼합 사용
- **데이터 접근 다양성**: JPA Repository와 MyBatis Mapper 병행

## 3. Call Chain Report

### 주요 호출 체인들

#### 1. 사용자 목록 조회 체인
```mermaid
sequenceDiagram
    participant JSP as user/list.jsp
    participant UC as UserController
    participant US as UserService
    participant UD as UserDao
    participant UM as UserMapper.xml
    participant DB as Database
    
    JSP->>UC: GET /user/list?name=김&status=ACTIVE
    UC->>UC: validateSearchParameters()
    UC->>US: getUsersByCondition(params)
    US->>US: validateSearchParams()
    US->>UD: findUsersByCondition(params)
    UD->>UM: findUsersByCondition
    UM->>DB: SELECT * FROM users WHERE...
    DB-->>UM: ResultSet
    UM-->>UD: List<User>
    UD-->>US: List<User>
    US->>US: processUserData()
    US-->>UC: List<User>
    UC->>UC: calculateUserStatistics()
    UC-->>JSP: ModelAndView(users, statistics)
```

#### 2. 상품 검색 체인
```mermaid
sequenceDiagram
    participant JSP as product/list.jsp
    participant PC as ProductController
    participant PS as ProductService
    participant PD as ProductDao
    participant PM as ProductMapper.xml
    participant DB as Database
    
    JSP->>PC: POST /product/search
    PC->>PS: getProductsByAdvancedCondition(params)
    PS->>PD: findProductsByAdvancedCondition(params)
    PD->>PM: selectProductsByAdvancedCondition
    PM->>DB: SELECT p.*, c.category_name, b.brand_name FROM products p LEFT JOIN...
    DB-->>PM: ResultSet with joins
    PM-->>PD: List<Product>
    PD-->>PS: List<Product>
    PS-->>PC: List<Product>
    PC-->>JSP: ModelAndView(products)
```

#### 3. JPA REST API 체인
```mermaid
sequenceDiagram
    participant VUE as UserManagement.vue
    participant JUC as JpaUserController
    participant JUS as JpaUserService
    participant UR as UserRepository
    participant DB as Database
    
    VUE->>JUC: GET /api/jpa/users/search?username=admin
    JUC->>JUS: searchUsers(username, email, status, userType, pageable)
    JUS->>UR: findUsersByDynamicCriteria(criteria, pageable)
    UR->>DB: JPA Query with Criteria API
    DB-->>UR: Page<User>
    UR-->>JUS: Page<User>
    JUS-->>JUC: Page<User>
    JUC-->>VUE: ResponseEntity<Page<User>>
```

#### 4. Servlet 처리 체인
```mermaid
sequenceDiagram
    participant CLIENT as HTTP Client
    participant UMS as UserManagementServlet
    participant US as UserService
    participant UD as UserDao
    participant DB as Database
    
    CLIENT->>UMS: POST /api/v1/users
    UMS->>UMS: doPost()
    UMS->>US: createUser(userData)
    US->>US: validateUserData()
    US->>US: checkUserDuplication()
    US->>UD: createUser(processedData)
    UD->>DB: INSERT INTO users...
    DB-->>UD: success
    UD-->>US: User
    US-->>UMS: User
    UMS-->>CLIENT: JSON Response
```

### 호출 체인 통계
- **평균 호출 깊이**: 4-5 레벨
- **최대 호출 깊이**: 6 레벨 (JSP → Controller → Service → DAO → Mapper → DB)
- **주요 패턴**: MVC + Repository/DAO 패턴
- **예외 처리**: 각 계층별 try-catch 구조

## 4. Sequence Diagram Report

### 복합 비즈니스 프로세스 시퀀스

#### 사용자 생성 및 검증 프로세스
```mermaid
sequenceDiagram
    participant UI as Frontend UI
    participant UC as UserController
    participant US as UserService
    participant UD as UserDao
    participant UM as UserMapper
    participant DB as Database
    participant CACHE as Cache
    
    UI->>UC: POST /user/create
    UC->>UC: validateInput()
    
    alt validation fails
        UC-->>UI: ValidationError
    else validation success
        UC->>US: createUser(userData)
        US->>US: validateUserData()
        US->>UD: existsByUsername(username)
        UD->>UM: existsByUsername
        UM->>DB: SELECT COUNT(*) FROM users WHERE username=?
        DB-->>UM: count
        UM-->>UD: boolean
        UD-->>US: boolean
        
        alt user exists
            US-->>UC: UserExistsException
            UC-->>UI: ConflictError
        else user not exists
            US->>UD: existsByEmail(email)
            UD->>UM: existsByEmail
            UM->>DB: SELECT COUNT(*) FROM users WHERE email=?
            DB-->>UM: count
            UM-->>UD: boolean
            UD-->>US: boolean
            
            alt email exists
                US-->>UC: EmailExistsException
                UC-->>UI: ConflictError
            else email available
                US->>US: processUserCreationData()
                US->>UD: createUser(processedData)
                UD->>UM: createUser
                UM->>DB: INSERT INTO users...
                DB-->>UM: insertId
                UM-->>UD: User
                UD-->>US: User
                US->>US: postCreateUserProcessing()
                US->>CACHE: invalidateUserCache()
                US-->>UC: User
                UC-->>UI: CreatedUser
            end
        end
    end
```

#### 상품 재고 업데이트 프로세스
```mermaid
sequenceDiagram
    participant ADMIN as Admin UI
    participant PC as ProductController
    participant PS as ProductService
    participant PD as ProductDao
    participant PM as ProductMapper
    participant DB as Database
    participant NOTIFY as NotificationService
    
    ADMIN->>PC: POST /product/updateStock
    PC->>PS: updateProductStock(productId, quantity)
    PS->>PD: findProductById(productId)
    PD->>PM: selectProductById
    PM->>DB: SELECT * FROM products WHERE product_id=?
    DB-->>PM: Product
    PM-->>PD: Product
    PD-->>PS: Product
    
    alt product not found
        PS-->>PC: ProductNotFoundException
        PC-->>ADMIN: NotFoundError
    else product found
        PS->>PS: validateStockUpdate(product, quantity)
        
        alt validation fails
            PS-->>PC: ValidationException
            PC-->>ADMIN: ValidationError
        else validation success
            PS->>PD: updateProductStock(productId, quantity)
            PD->>PM: updateProductStock
            PM->>DB: UPDATE products SET stock_quantity = stock_quantity + ? WHERE product_id = ?
            DB-->>PM: affectedRows
            PM-->>PD: int
            PD-->>PS: int
            
            alt update failed
                PS-->>PC: UpdateFailedException
                PC-->>ADMIN: ServerError
            else update success
                PS->>PD: findProductById(productId)
                PD->>PM: selectProductById
                PM->>DB: SELECT * FROM products WHERE product_id=?
                DB-->>PM: Updated Product
                PM-->>PD: Product
                PD-->>PS: Product
                PS->>PS: checkLowStockAlert(product)
                
                alt low stock detected
                    PS->>NOTIFY: sendLowStockAlert(product)
                end
                
                PS-->>PC: Updated Product
                PC-->>ADMIN: Success Response
            end
        end
    end
```

## 5. Architecture Diagram Report

### 전체 시스템 아키텍처

```mermaid
graph TB
    subgraph "External Systems"
        BROWSER[Web Browser]
        MOBILE[Mobile App]
        API_CLIENT[API Client]
    end
    
    subgraph "Load Balancer"
        LB[Nginx/Apache]
    end
    
    subgraph "Application Server"
        subgraph "Web Layer"
            JSP_ENGINE[JSP Engine]
            STATIC[Static Resources]
        end
        
        subgraph "Spring Framework"
            SPRING_MVC[Spring MVC]
            SPRING_BOOT[Spring Boot]
            SPRING_DATA[Spring Data JPA]
        end
        
        subgraph "Business Logic"
            CONTROLLERS[Controllers]
            SERVICES[Services]
            COMPONENTS[Components]
        end
        
        subgraph "Data Access"
            JPA_REPOS[JPA Repositories]
            MYBATIS[MyBatis Mappers]
            DAOS[DAO Classes]
        end
    end
    
    subgraph "Database Layer"
        DB_MASTER[(Primary DB)]
        DB_SLAVE[(Replica DB)]
        CACHE_DB[(Redis Cache)]
    end
    
    subgraph "File System"
        LOGS[Log Files]
        UPLOADS[Upload Files]
        CONFIG[Configuration]
    end
    
    BROWSER --> LB
    MOBILE --> LB
    API_CLIENT --> LB
    
    LB --> JSP_ENGINE
    LB --> SPRING_MVC
    
    JSP_ENGINE --> CONTROLLERS
    SPRING_MVC --> CONTROLLERS
    CONTROLLERS --> SERVICES
    SERVICES --> JPA_REPOS
    SERVICES --> DAOS
    DAOS --> MYBATIS
    
    JPA_REPOS --> DB_MASTER
    MYBATIS --> DB_MASTER
    JPA_REPOS --> DB_SLAVE
    MYBATIS --> DB_SLAVE
    
    SERVICES --> CACHE_DB
    
    SPRING_BOOT --> LOGS
    SPRING_BOOT --> CONFIG
    
    style BROWSER fill:#e3f2fd
    style MOBILE fill:#e8f5e8
    style API_CLIENT fill:#fff3e0
    style CONTROLLERS fill:#fce4ec
    style SERVICES fill:#f3e5f5
    style DB_MASTER fill:#ffebee
    style CACHE_DB fill:#e0f2f1
```

### 아키텍처 구성 요소

#### Frontend Components
- **JSP Pages**: 전통적인 서버 사이드 렌더링
- **Vue.js Components**: 모던 SPA 컴포넌트
- **TypeScript Services**: API 통신 및 비즈니스 로직

#### Backend Components
- **Spring Controllers**: REST API 및 MVC 엔드포인트
- **Servlet Classes**: 레거시 서블릿 기반 처리
- **Service Layer**: 비즈니스 로직 처리
- **DAO/Repository**: 데이터 접근 추상화

#### Data Layer
- **MyBatis Mappers**: SQL 기반 데이터 접근
- **JPA Repositories**: 객체 관계 매핑
- **Database**: 관계형 데이터베이스

## 6. 리포트 생성 예상 결과

### 파일 구조
```
reports/
├── [SampleSrc]_ERD_20240101_120000.html
├── [SampleSrc]_ERD_Dagre_20240101_120001.html  
├── [SampleSrc]_ArchitectureLayerDiagram_20240101_120002.html
├── [SampleSrc]_CallChainReport_20240101_120003.html
├── [SampleSrc]_SequenceDiagramReport_20240101_120004.html
└── [SampleSrc]_ArchitectureDiagram_20240101_120005.html
```

### 각 리포트 특징

#### ERD 리포트
- **테이블 수**: 9개 주요 테이블
- **관계 수**: 8개 주요 관계
- **시각화**: Mermaid ERD 다이어그램
- **상호작용**: 클릭 가능한 테이블/컬럼 정보

#### Architecture Layer 리포트  
- **레이어 수**: 5개 계층
- **컴포넌트 수**: 약 15개 주요 컴포넌트
- **연결선**: 계층 간 의존성 표시
- **색상 구분**: 계층별 색상 코딩

#### Call Chain 리포트
- **체인 수**: 약 20개 주요 호출 체인
- **평균 깊이**: 4-5 레벨
- **최대 깊이**: 6 레벨
- **필터링**: 계층별, 메서드별 필터 기능

#### Sequence Diagram 리포트
- **시나리오 수**: 약 10개 주요 비즈니스 프로세스
- **참여자 수**: 평균 5-6개 클래스/컴포넌트
- **메시지 수**: 시나리오당 평균 15-20개 메시지
- **조건 분기**: alt/opt 블록으로 예외 상황 표현

#### Architecture Diagram 리포트
- **노드 수**: 약 25개 시스템 컴포넌트
- **연결 수**: 약 30개 연결선
- **그룹핑**: 논리적 레이어별 서브그래프
- **레이아웃**: 계층적 상하 구조

### 예상 성능 지표
- **ERD 생성 시간**: 2-3초
- **Call Chain 분석 시간**: 5-7초  
- **Sequence Diagram 생성 시간**: 3-5초
- **전체 리포트 생성 시간**: 15-20초
- **HTML 파일 크기**: 평균 500KB-2MB

이러한 리포트들은 SampleSrc의 실제 코드 구조를 반영하여 개발자들이 시스템의 전체적인 구조와 흐름을 이해하는데 도움을 줄 것으로 예상됩니다.

