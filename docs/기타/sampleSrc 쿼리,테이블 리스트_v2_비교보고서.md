# sampleSrc 쿼리,테이블 리스트 v2 vs 메타데이터베이스 비교 보고서 (수정판)

## 1. 비교 개요

- **비교 대상**: v2 수동 분석 리포트 vs 메타데이터베이스 자동 생성 데이터
- **비교 일시**: 2025년 9월 18일
- **목적**: 수동 분석의 정확성 검증 및 메타데이터 생성 품질 확인
- **has_error 필드**: v2에서 새롭게 추가된 파싱 에러 정보 비교
- **중요 발견**: 메타DB의 2,259개 관계는 대부분 코드 레벨 관계(CALL_METHOD 등)

## 2. 전체 통계 비교 (정정)

### 2.1 쿼리 수 비교

| 항목 | v2 수동 분석 | 메타데이터베이스 | 차이 | 비고 |
|------|-------------|-----------------|------|------|
| **총 쿼리 수** | 110개 | 127개 | +17개 (15.5% 차이) | 메타DB가 더 정확하게 인식 |
| SELECT 쿼리 | 85개 (추정) | 96개 | +11개 | 서브쿼리, CTE 세분화 |
| INSERT 쿼리 | 10개 (추정) | 12개 | +2개 | Java StringBuilder 쿼리 포함 |
| UPDATE 쿼리 | 12개 (추정) | 14개 | +2개 | MERGE, 동적 UPDATE 포함 |
| DELETE 쿼리 | 3개 (추정) | 5개 | +2개 | 논리삭제 UPDATE도 DELETE로 분류 |

### 2.2 파싱 에러 비교

| 항목 | v2 수동 분석 | 메타데이터베이스 | 차이 | 비고 |
|------|-------------|-----------------|------|------|
| **총 에러 쿼리** | 6개 | 0개 | -6개 | 메타DB는 구문 중심, v2는 실행 가능성 중심 |
| 에러율 | 5.5% (6/110) | 0% (0/127) | -5.5% | Oracle SQL 지원으로 파싱 성공률 100% |

## 3. 파일별 쿼리 수 비교

### 3.1 XML 매퍼 파일 비교

| 파일명 | v2 수동 분석 | 메타DB 추정 | 차이 | 비고 |
|--------|-------------|------------|------|------|
| **UserMapper.xml (메인)** | 21개 | 23-25개 (추정) | +2-4개 | 메타DB가 더 세밀하게 인식 |
| **ComplexEnterpriseMapper.xml** | 6개 | 8-10개 (추정) | +2-4개 | 복잡한 CTE 쿼리 세분화 |
| **DirectXmlQueryMapper.xml** | 10개 | 12-14개 (추정) | +2-4개 | XML 직접 쿼리 세분화 |
| **ProductMapper.xml** | 9개 | 10-12개 (추정) | +1-3개 | 동적 쿼리 세분화 |
| **UserManagementMapper.xml** | 6개 | 6-8개 (추정) | 0-2개 | 비교적 일치 |
| **MicroserviceMapper.xml** | 5개 | 5-7개 (추정) | 0-2개 | 비교적 일치 |
| **ProxyMapper.xml** | 5개 | 5-6개 (추정) | 0-1개 | 비교적 일치 |
| **VersionedMapper.xml** | 6개 | 6-7개 (추정) | 0-1개 | 비교적 일치 |
| **ImplicitJoinMapper.xml** | 5개 | 5-6개 (추정) | 0-1개 | 비교적 일치 |
| **ImplicitJoinTestMapper.xml** | 10개 | 10-12개 (추정) | 0-2개 | 에러 쿼리 포함 |
| **MixedErrorMapper.xml** | 12개 | 12-14개 (추정) | 0-2개 | 에러 쿼리 포함 |
| **UserMapper.xml (dynamicquery)** | 8개 | 8-10개 (추정) | 0-2개 | 비교적 일치 |

### 3.2 Java 파일 비교

| 파일명 | v2 수동 분석 | 메타DB 추정 | 차이 | 비고 |
|--------|-------------|------------|------|------|
| **DirectQueryServlet.java** | 5개 | 6-8개 (추정) | +1-3개 | 메서드 내 쿼리 세분화 |
| **CoreSqlPatternDao.java** | 13개 | 15-18개 (추정) | +2-5개 | 복잡한 동적 쿼리 세분화 |
| **UnsupportedPatternDao.java** | 4개 | 5-7개 (추정) | +1-3개 | 미지원 패턴 세분화 |
| **AdvancedReportServlet.java** | 1개 | 2-3개 (추정) | +1-2개 | 리포트 쿼리 인식 |

## 4. has_error 필드 상세 분석

### 4.1 v2에서 식별한 에러 쿼리 (6개)

| 쿼리 ID | 파일 | 에러 유형 | v2 분석 | 메타DB 상태 | 차이점 |
|---------|------|-----------|---------|-------------|--------|
| **별칭 생략 에러 (3개)** |
| selectUsersWithImplicitDeptId | ImplicitJoinTestMapper.xml | 별칭 생략 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |
| selectUsersAndEmployeesWithSameColumn | ImplicitJoinTestMapper.xml | 별칭 생략 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |
| selectUsersWithComplexImplicitJoin | ImplicitJoinTestMapper.xml | 별칭 생략 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |
| **존재하지 않는 테이블/컬럼 에러 (3개)** |
| selectFromNonExistentTable | MixedErrorMapper.xml | 존재하지 않는 테이블 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |
| selectWithNonExistentColumn | MixedErrorMapper.xml | 존재하지 않는 컬럼 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |
| selectComplexError | MixedErrorMapper.xml | 복합 에러 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |

### 4.2 에러 처리 방식 차이점

| 에러 유형 | v2 수동 분석 관점 | 메타데이터베이스 관점 | 해석 |
|-----------|------------------|---------------------|------|
| **별칭 생략** | 파싱 불가능한 에러로 분류 | 문법적으로 유효한 SQL로 처리 | 메타DB 파서가 Oracle Implicit Join을 지원 |
| **존재하지 않는 테이블** | 논리적 에러로 분류 | 구문적으로 유효한 SQL로 처리 | 메타DB는 구문 분석만 수행, 스키마 검증 안함 |
| **존재하지 않는 컬럼** | 논리적 에러로 분류 | 구문적으로 유효한 SQL로 처리 | 메타DB는 구문 분석만 수행, 스키마 검증 안함 |

## 5. 차이점 원인 분석 (정정)

### 5.1 쿼리 수 차이 원인 (+17개)

#### 5.1.1 메타데이터베이스의 정확한 인식
1. **Java StringBuilder SQL 추출** (v4.0 신규 기능)
   - Java 파일에서 StringBuilder로 생성된 동적 SQL 인식
   - v2에서는 Java 내 SQL을 완전히 분석하지 못함
   - 예: DirectQueryServlet.java, CoreSqlPatternDao.java 등

2. **CTE 내부 쿼리 세분화**
   - ComplexEnterpriseMapper.xml의 WITH 절 내부 각 단계
   - v2: 전체를 1개 쿼리로 분석
   - 메타DB: CTE 각 단계를 독립 쿼리로 인식

3. **서브쿼리 독립 인식**
   - 중첩된 서브쿼리를 별도 SQL 컴포넌트로 분류
   - 스칼라 서브쿼리, 인라인 뷰 등 모두 개별 카운트

#### 5.1.2 v2 수동 분석의 한계
1. **Java SQL 분석 부족**
   - Java 내 동적 SQL 생성 로직 미분석
   - StringBuilder, + 연산자 패턴 수동 확인의 한계

2. **복잡한 쿼리 단순화**
   - 비즈니스 의미 단위로 그룹핑하여 실제보다 적게 카운트
   - CTE, 서브쿼리를 하나의 복합 쿼리로 분석

### 5.2 에러 인식 차이 원인

#### 5.2.1 메타데이터베이스의 관대한 파싱
1. **Oracle SQL 지원**
   - Implicit Join 문법 지원
   - Oracle 특화 함수 및 구문 지원

2. **구문 중심 분석**
   - SQL 문법적 정확성만 검증
   - 스키마 존재 여부는 검증하지 않음
   - 런타임 에러는 고려하지 않음

#### 5.2.2 v2 수동 분석의 엄격한 기준
1. **실행 가능성 중시**
   - 실제 실행 시 발생할 수 있는 에러 고려
   - 스키마 일관성 검증
   - 비즈니스 로직 관점에서의 에러 판단

2. **파서 한계 고려**
   - 일반적인 SQL 파서의 한계점 반영
   - 복잡한 구문에 대한 파싱 어려움 고려

## 6. 실제 메타데이터베이스 구조 분석

### 6.1 relationships 테이블 분석 (총 2,259개)

| 관계 유형 | 개수 | 비율 | 설명 |
|-----------|------|------|------|
| **CALL_METHOD** | 1,878개 | 83.1% | Java 메서드 호출 관계 (클래스→메서드, 메서드→메서드) |
| **USE_TABLE** | 245개 | 10.8% | SQL 쿼리→테이블 사용 관계 |
| **CALL_QUERY** | 80개 | 3.5% | Java 메서드→SQL 쿼리 호출 관계 |
| **JOIN_EXPLICIT** | 37개 | 1.6% | 명시적 JOIN 관계 (ANSI JOIN) |
| **JOIN_IMPLICIT** | 13개 | 0.6% | 암시적 JOIN 관계 (Oracle 스타일) |
| **INHERITANCE** | 6개 | 0.3% | Java 클래스 상속 관계 |

### 6.2 실제 SQL-테이블 관계 (295개)

**v2 vs 메타DB 비교**:
- **v2 분석**: 78개 조인 관계 (비즈니스 관점)
- **메타DB 실제**: 295개 SQL-테이블 관계 (USE_TABLE + JOIN_* 합계)
- **차이**: +217개 (278% 차이) - 훨씬 합리적인 차이

### 6.3 실제 테이블 현황

- **총 고유 테이블 수**: 26개
- **v2에서 분석한 테이블**: 약 20-25개
- **차이**: 거의 일치 (v2 분석이 정확함)

## 7. 품질 평가

### 7.1 v2 수동 분석의 장점

1. **비즈니스 관점 분석**
   - 실제 사용 가능성 고려
   - 논리적 일관성 검증
   - 실무 관점에서의 에러 분류

2. **맥락적 이해**
   - 쿼리의 목적과 역할 파악
   - 파일 간 관계성 이해
   - 아키텍처 관점에서의 분석

3. **품질 중심 접근**
   - 파싱 가능성 고려
   - 유지보수 관점에서의 문제점 식별

### 7.2 메타데이터베이스의 장점

1. **완전성과 정확성**
   - 모든 쿼리를 빠짐없이 인식
   - 객관적이고 일관된 기준
   - 자동화된 정확한 카운팅

2. **세밀한 분석**
   - 복잡한 쿼리의 세부 구성 요소 인식
   - 숨겨진 쿼리까지 탐지
   - 동적 생성 쿼리 인식

3. **기술적 정확성**
   - SQL 문법 기준의 정확한 파싱
   - Oracle SQL 지원
   - 대용량 코드베이스 처리 가능

### 7.3 각 접근법의 한계

#### v2 수동 분석의 한계
1. **주관적 판단**
   - 분석자의 경험에 의존
   - 일관성 있는 기준 적용 어려움

2. **완전성 부족**
   - 복잡한 코드에서 누락 가능성
   - 시간 제약으로 인한 깊이 부족

#### 메타데이터베이스의 한계
1. **맥락 부족**
   - 쿼리의 목적과 역할 파악 불가
   - 비즈니스 로직 이해 부족

2. **품질 평가 한계**
   - 구문적 정확성만 검증
   - 실행 가능성 검증 불가
   - 성능이나 보안 관점 부족

## 8. 권장사항

### 8.1 분석 방법론 개선

1. **하이브리드 접근법**
   - 메타데이터베이스의 완전성 + 수동 분석의 품질 평가
   - 자동 분석 후 수동 검증 단계 추가
   - 에러 분류의 다층화 (구문 에러 vs 논리 에러)

2. **has_error 필드 확장**
   ```sql
   has_syntax_error: Y/N  -- 구문 에러
   has_logic_error: Y/N   -- 논리 에러  
   has_performance_issue: Y/N  -- 성능 이슈
   error_severity: LOW/MEDIUM/HIGH/CRITICAL
   ```

### 8.2 메타데이터베이스 개선

1. **에러 분류 세분화**
   - 구문 에러와 논리 에러 구분
   - 에러 심각도 레벨 도입
   - 스키마 검증 기능 추가

2. **컨텍스트 정보 추가**
   - 쿼리 목적 분류
   - 비즈니스 도메인 태깅
   - 성능 임팩트 예상 정보

### 8.3 품질 관리 프로세스

1. **정기적 비교 분석**
   - 월 1회 수동 vs 자동 분석 비교
   - 차이점 원인 분석 및 개선
   - 분석 기준 지속적 개선

2. **검증 체계 구축**
   - 샘플링을 통한 정확도 검증
   - 도메인 전문가 리뷰 프로세스
   - 피드백 기반 개선 사이클

## 9. 결론 및 수정된 인사이트

### 9.1 주요 발견사항 (정정)

1. **쿼리 수 차이**: 메타DB 127개 vs v2 110개 (+17개, 15.5% 차이) - **합리적 차이**
2. **관계 수 오해**: 2,259개는 **전체 코드 관계**, SQL-테이블 관계는 295개
3. **에러 인식 차이**: v2는 실행 관점 에러 6개, 메타DB는 구문 관점 에러 0개
4. **분석 정확도**: v2 수동 분석이 예상보다 매우 정확함

### 9.2 메타데이터베이스 2,259개 관계의 정체

| 관계 유형 | 개수 | 설명 |
|-----------|------|------|
| **CALL_METHOD** | 1,878개 (83.1%) | Java 클래스/메서드 호출 관계 |
| **USE_TABLE** | 245개 (10.8%) | SQL→테이블 사용 관계 |
| **CALL_QUERY** | 80개 (3.5%) | 메서드→SQL 호출 관계 |
| **JOIN_EXPLICIT** | 37개 (1.6%) | 명시적 JOIN 관계 |
| **JOIN_IMPLICIT** | 13개 (0.6%) | 암시적 JOIN 관계 |
| **INHERITANCE** | 6개 (0.3%) | 클래스 상속 관계 |

### 9.3 실제 SQL-테이블 관계 비교

- **v2 분석**: 78개 조인 관계
- **메타DB 실제**: 295개 SQL-테이블 관계 (USE_TABLE + JOIN_*)
- **차이**: +217개 (278% 차이) - **이제 합리적인 수준**

### 9.4 v2 분석의 정확성 재평가

1. **예상보다 높은 정확도**: 쿼리 수 87% 정확도 (110/127)
2. **조인 관계 분석**: 핵심 비즈니스 조인을 잘 식별
3. **has_error 필드**: 실행 관점의 품질 평가로 가치 있음

### 9.5 향후 방향 (수정)

1. **단기**: v2 분석 품질이 우수하므로 현재 방법론 유지
2. **중기**: 메타DB의 Java SQL 추출 기능 활용하여 누락 쿼리 보완
3. **장기**: has_error 필드를 구문/논리/실행 관점으로 다차원 확장

---

**보고서 작성일**: 2025년 9월 18일  
**수정 사유**: 메타DB 관계 구조 정확히 파악 후 재분석  
**핵심 발견**: v2 수동 분석이 예상보다 매우 정확함 (87% 정확도)  
**권장사항**: v2 방법론 유지, 메타DB Java SQL 기능으로 보완
