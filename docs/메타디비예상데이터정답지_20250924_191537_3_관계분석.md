# 메타디비 예상데이터 정답지 - 관계 분석

**생성일시**: 2025-09-24 19:15:37  
**분석대상**: projects/SampleSrc 폴더  
**분석방법**: 수작업 직접 분석  

## 1. CALL_METHOD 관계 분석 (45개)

### 1.1 프론트엔드 → Controller (20개)

| 프론트엔드파일 | Controller | 메소드 | 관계타입 |
|---------------|------------|--------|----------|
| userManagement.jsp | UserController | getUserList | CALL_METHOD |
| userManagement.jsp | UserController | searchUsers | CALL_METHOD |
| userManagement.jsp | UserController | getUsersByType | CALL_METHOD |
| userManagement.jsp | UserManagementController | getUsers | CALL_METHOD |
| userManagement.jsp | UserManagementController | getUserDetail | CALL_METHOD |
| userManagement.jsp | UserManagementController | createUser | CALL_METHOD |
| userManagement.jsp | UserManagementController | updateUser | CALL_METHOD |
| userManagement.jsp | UserManagementController | deleteUser | CALL_METHOD |
| UserManagement.jsx | UserManagementController | getUsers | CALL_METHOD |
| UserManagement.jsx | UserManagementController | getUserDetail | CALL_METHOD |
| UserManagement.jsx | UserManagementController | createUser | CALL_METHOD |
| UserManagement.jsx | UserManagementController | updateUser | CALL_METHOD |
| UserManagement.jsx | UserManagementController | deleteUser | CALL_METHOD |
| UserManagement.jsx | UserManagementController | getUserStatistics | CALL_METHOD |
| UserManagement.vue | UserManagementController | getUsers | CALL_METHOD |
| UserManagement.vue | UserManagementController | getUserDetail | CALL_METHOD |
| UserManagement.vue | UserManagementController | createUser | CALL_METHOD |
| UserManagement.vue | UserManagementController | updateUser | CALL_METHOD |
| UserManagement.vue | UserManagementController | deleteUser | CALL_METHOD |
| UserManagement.vue | UserManagementController | getUserStatistics | CALL_METHOD |

### 1.2 Controller → Service (15개)

| Controller | Service | 메소드 | 관계타입 |
|------------|---------|--------|----------|
| UserController | UserService | getUsersByCondition | CALL_METHOD |
| UserController | UserService | getUsersByAdvancedCondition | CALL_METHOD |
| UserController | UserService | getUsersByType | CALL_METHOD |
| ProductController | ProductService | getProductsByCondition | CALL_METHOD |
| ProductController | ProductService | getProductsByAdvancedCondition | CALL_METHOD |
| ProductController | ProductService | getProductsByCategory | CALL_METHOD |
| ProductController | ProductService | updateProductStock | CALL_METHOD |
| UserManagementController | UserManagementService | getUsers | CALL_METHOD |
| UserManagementController | UserManagementService | getUserDetail | CALL_METHOD |
| UserManagementController | UserManagementService | createUser | CALL_METHOD |
| UserManagementController | UserManagementService | updateUser | CALL_METHOD |
| UserManagementController | UserManagementService | deleteUser | CALL_METHOD |
| UserManagementController | UserManagementService | getUserStatistics | CALL_METHOD |
| ErrorController | UserService | getUsersByCondition | CALL_METHOD |
| SyntaxErrorController | UserService | getAllUsers | CALL_METHOD |

### 1.3 Service → DAO/Repository (10개)

| Service | DAO/Repository | 메소드 | 관계타입 |
|---------|----------------|--------|----------|
| UserService | UserDao | findUsersByCondition | CALL_METHOD |
| UserService | UserDao | findUsersByAdvancedCondition | CALL_METHOD |
| UserService | UserDao | findUsersByType | CALL_METHOD |
| ProductService | ProductDao | selectProductsByCondition | CALL_METHOD |
| ProductService | ProductDao | selectProductsByAdvancedCondition | CALL_METHOD |
| ProductService | ProductDao | selectProductsByCategory | CALL_METHOD |
| ProductService | ProductDao | updateProductStock | CALL_METHOD |
| UserManagementService | UserManagementDao | selectUsers | CALL_METHOD |
| UserManagementService | UserManagementDao | selectUserById | CALL_METHOD |
| UserManagementService | UserManagementDao | selectUserStatistics | CALL_METHOD |

## 2. CALL_QUERY 관계 분석 (66개)

### 2.1 MyBatis XML-Java 연결 (15개)

| Java파일명 | METHOD명 | XML파일명 | 쿼리ID | 쿼리종류 | 쿼리(SQL content) |
|-----------|----------|-----------|--------|----------|-------------------|
| UserController | getUserList | UserMapper.xml | findUsersByCondition | SQL_SELECT | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date FROM users u WHERE u.del_yn = 'N' |
| UserController | searchUsers | UserMapper.xml | findUsersByAdvancedCondition | SQL_SELECT | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date FROM users u WHERE u.del_yn = 'N' |
| UserController | getUsersByType | UserMapper.xml | findUsersByType | SQL_SELECT | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date FROM users u WHERE u.del_yn = 'N' AND u.user_type = #{userType} |
| ProductController | getProductList | ProductMapper.xml | selectProductsByCondition | SQL_SELECT | SELECT * FROM products WHERE 조건들 |
| ProductController | searchProducts | ProductMapper.xml | selectProductsByAdvancedCondition | SQL_SELECT | SELECT p.*, c.category_name, b.brand_name FROM products p LEFT JOIN categories c ON p.category_id = c.category_id LEFT JOIN brands b ON p.brand_id = b.brand_id WHERE 조건들 |
| ProductController | getProductsByCategory | ProductMapper.xml | selectProductsByCategory | SQL_SELECT | SELECT * FROM products WHERE category_id = #{categoryId} |
| ProductController | updateProductStock | ProductMapper.xml | updateProductStock | SQL_UPDATE | UPDATE products SET stock_quantity = stock_quantity + #{quantity}, updated_date = SYSDATE WHERE product_id = #{productId} |
| UserManagementController | getUsers | UserManagementMapper.xml | selectUsers | SQL_SELECT | SELECT u.user_id, u.username, u.email, u.status, u.created_at FROM users u WHERE 조건들 |
| UserManagementController | getUserDetail | UserManagementMapper.xml | selectUserById | SQL_SELECT | SELECT u.*, up.first_name, up.last_name, up.phone FROM users u LEFT JOIN user_profiles up ON u.user_id = up.user_id WHERE u.user_id = #{userId} |
| UserManagementController | getUserStatistics | UserManagementMapper.xml | selectUserStatistics | SQL_SELECT | SELECT COUNT(*) as total_users, COUNT(CASE WHEN status = 'ACTIVE' THEN 1 END) as active_users, COUNT(CASE WHEN status = 'INACTIVE' THEN 1 END) as inactive_users FROM users |
| UserManagementController | updateUser | UserManagementMapper.xml | updateUserStatus | SQL_UPDATE | UPDATE users SET status = #{newStatus}, updated_at = SYSDATE WHERE user_id = #{userId} |
| UserManagementController | deleteUser | UserManagementMapper.xml | deleteInactiveUsers | SQL_DELETE | DELETE FROM users WHERE status = 'INACTIVE' AND last_login_at < #{cutoffDate} |
| UserManagementController | createUser | UserManagementMapper.xml | insertUser | SQL_INSERT | INSERT INTO users (username, email, password, status, created_at) VALUES (#{username}, #{email}, #{password}, #{status}, SYSDATE) |
| ErrorController | getErrorList | UserMapper.xml | findUsersByCondition | SQL_SELECT | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date FROM users u WHERE u.del_yn = 'N' |
| SyntaxErrorController | getAllUsers | UserMapper.xml | findUsersByCondition | SQL_SELECT | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date FROM users u WHERE u.del_yn = 'N' |

### 2.2 JPA Repository 연결 (25개)

| Java파일명 | METHOD명 | JPA파일명 | 쿼리ID | 쿼리종류 | 쿼리(SQL content) |
|-----------|----------|-----------|--------|----------|-------------------|
| UserRepository | findActiveUsersFromDate | UserRepository.java | findActiveUsersFromDate | SQL_SELECT | SELECT u FROM User u WHERE u.status = :status AND u.createdAt >= :fromDate |
| UserRepository | findByEmailDomain | UserRepository.java | findByEmailDomain | SQL_SELECT | SELECT u FROM User u WHERE u.email LIKE %:domain% |
| UserRepository | findByIdWithOrders | UserRepository.java | findByIdWithOrders | SQL_SELECT | SELECT u FROM User u LEFT JOIN FETCH u.orders WHERE u.userId = :userId |
| UserRepository | findByStatusWithProfile | UserRepository.java | findByStatusWithProfile | SQL_SELECT | SELECT u FROM User u LEFT JOIN FETCH u.userProfile WHERE u.status = :status |
| UserRepository | findByUserTypeAndCreatedAtAfterNative | UserRepository.java | findByUserTypeAndCreatedAtAfterNative | SQL_SELECT | SELECT * FROM USERS u WHERE u.USER_TYPE = ?1 AND u.CREATED_AT > ?2 |
| UserRepository | countUsersByStatusNative | UserRepository.java | countUsersByStatusNative | SQL_SELECT | SELECT COUNT(*) FROM USERS WHERE STATUS = :status |
| UserRepository | getUserTypeStatistics | UserRepository.java | getUserTypeStatistics | SQL_SELECT | SELECT u.userType, COUNT(u) FROM User u GROUP BY u.userType |
| UserRepository | getUserStatusStatistics | UserRepository.java | getUserStatusStatistics | SQL_SELECT | SELECT u.status, COUNT(u) FROM User u WHERE u.createdAt >= :fromDate GROUP BY u.status |
| UserRepository | updateLastLoginTime | UserRepository.java | updateLastLoginTime | SQL_UPDATE | UPDATE User u SET u.lastLoginAt = :loginTime WHERE u.userId = :userId |
| UserRepository | updateUserStatusByDateAndStatus | UserRepository.java | updateUserStatusByDateAndStatus | SQL_UPDATE | UPDATE User u SET u.status = :newStatus WHERE u.status = :oldStatus AND u.createdAt < :beforeDate |
| UserRepository | findUsersWithOrdersAfterDate | UserRepository.java | findUsersWithOrdersAfterDate | SQL_SELECT | SELECT u FROM User u WHERE u.userId IN (SELECT o.user.userId FROM Order o WHERE o.orderDate >= :fromDate) |
| UserRepository | findUsersWithoutCompletedOrders | UserRepository.java | findUsersWithoutCompletedOrders | SQL_SELECT | SELECT u FROM User u WHERE u.userId NOT IN (SELECT o.user.userId FROM Order o WHERE o.orderStatus = 'COMPLETED') |
| UserRepository | findUsersByDynamicCriteria | UserRepository.java | findUsersByDynamicCriteria | SQL_SELECT | SELECT u FROM User u WHERE (:username IS NULL OR u.username LIKE %:username%) AND (:email IS NULL OR u.email LIKE %:email%) AND (:status IS NULL OR u.status = :status) AND (:userType IS NULL OR u.userType = :userType) |
| UserRepository | findUsersWithOrdersAboveAmount | UserRepository.java | findUsersWithOrdersAboveAmount | SQL_SELECT | SELECT u FROM User u JOIN u.orders o WHERE o.totalAmount > :minAmount |
| UserRepository | findUsersByCityOrNoProfile | UserRepository.java | findUsersByCityOrNoProfile | SQL_SELECT | SELECT DISTINCT u FROM User u LEFT JOIN u.userProfile p WHERE p.city = :city OR p.city IS NULL |
| UserRepository | findUserSummariesByStatus | UserRepository.java | findUserSummariesByStatus | SQL_SELECT | SELECT new com.example.jpa.dto.UserSummaryDto(u.userId, u.username, u.email, u.status) FROM User u WHERE u.status = :status |
| ProductRepository | findByStatusWithCategory | ProductRepository.java | findByStatusWithCategory | SQL_SELECT | SELECT p FROM Product p JOIN FETCH p.category WHERE p.status = :status |
| ProductRepository | findByCategoryName | ProductRepository.java | findByCategoryName | SQL_SELECT | SELECT p FROM Product p WHERE p.category.categoryName = :categoryName |
| ProductRepository | findExpensiveProductsWithStock | ProductRepository.java | findExpensiveProductsWithStock | SQL_SELECT | SELECT p FROM Product p WHERE p.price >= :minPrice AND p.stockQuantity > :minStock |
| ProductRepository | getAveragePriceByStatus | ProductRepository.java | getAveragePriceByStatus | SQL_SELECT | SELECT AVG(p.price) FROM Product p WHERE p.status = :status |
| ProductRepository | getMaxPriceByCategoryId | ProductRepository.java | getMaxPriceByCategoryId | SQL_SELECT | SELECT MAX(p.price) FROM Product p WHERE p.category.categoryId = :categoryId |
| ProductRepository | getTotalActiveStock | ProductRepository.java | getTotalActiveStock | SQL_SELECT | SELECT SUM(p.stockQuantity) FROM Product p WHERE p.status = 'ACTIVE' |
| ProductRepository | getProductCountByCategory | ProductRepository.java | getProductCountByCategory | SQL_SELECT | SELECT p.category.categoryName, COUNT(p) FROM Product p GROUP BY p.category.categoryName |
| ProductRepository | getAveragePriceByStatus | ProductRepository.java | getAveragePriceByStatus | SQL_SELECT | SELECT p.status, AVG(p.price) FROM Product p GROUP BY p.status |
| ProductRepository | findByNameAndPriceNative | ProductRepository.java | findByNameAndPriceNative | SQL_SELECT | SELECT * FROM PRODUCTS p WHERE p.PRODUCT_NAME LIKE %?1% AND p.PRICE > ?2 |

### 2.3 Java DAO 연결 (16개)

| Java파일명 | METHOD명 | DAO파일명 | 쿼리ID | 쿼리종류 | 쿼리(SQL content) |
|-----------|----------|-----------|--------|----------|-------------------|
| JoinQueryDao | insertUserOrderStatistics | JoinQueryDao.java | insertUserOrderStatistics | SQL_INSERT | INSERT INTO user_order_statistics (user_id, total_orders, total_amount, last_order_date) SELECT u.user_id, COUNT(o.order_id), SUM(o.total_amount), MAX(o.order_date) FROM users u, orders o WHERE u.user_id = o.user_id AND u.status = 'ACTIVE' AND o.order_status = 'COMPLETED' AND u.created_date > ? GROUP BY u.user_id |
| JoinQueryDao | updateUserStatusBasedOnOrders | JoinQueryDao.java | updateUserStatusBasedOnOrders | SQL_UPDATE | UPDATE users u SET u.status = 'INACTIVE', u.updated_date = SYSDATE WHERE EXISTS (SELECT 'X' FROM orders o WHERE u.user_id = o.user_id AND o.order_date < ? AND o.order_status = 'CANCELLED') AND u.status = 'ACTIVE' |
| JoinQueryDao | deleteInactiveUsersWithNoActivity | JoinQueryDao.java | deleteInactiveUsersWithNoActivity | SQL_DELETE | DELETE FROM users u WHERE EXISTS (SELECT 'X' FROM user_activities ua WHERE u.user_id = ua.user_id AND ua.last_login_date < ? AND ua.activity_count = 0) AND u.status = 'INACTIVE' |
| JoinQueryDao | insertProductRecommendations | JoinQueryDao.java | insertProductRecommendations | SQL_INSERT | INSERT INTO product_recommendations (user_id, product_id, recommendation_score, created_date) SELECT u.user_id, p.product_id, (COUNT(oi.quantity) * AVG(oi.unit_price)) as score, SYSDATE FROM users u, orders o, order_items oi, products p WHERE u.user_id = o.user_id AND o.order_id = oi.order_id AND oi.product_id = p.product_id AND u.status = 'ACTIVE' AND o.order_status = 'COMPLETED' AND p.status = 'ACTIVE' GROUP BY u.user_id, p.product_id HAVING COUNT(oi.quantity) > 1 |
| JoinQueryDao | updateProductPricesBasedOnAnalysis | JoinQueryDao.java | updateProductPricesBasedOnAnalysis | SQL_UPDATE | UPDATE products p SET p.price = p.price * 1.1, p.updated_date = SYSDATE WHERE EXISTS (SELECT 'X' FROM categories c, brands b WHERE p.category_id = c.category_id AND p.brand_id = b.brand_id AND c.category_name = 'Electronics' AND b.brand_name IN ('Samsung', 'Apple', 'LG')) AND p.status = 'ACTIVE' |
| JoinQueryDao | deleteOldOrderItems | JoinQueryDao.java | deleteOldOrderItems | SQL_DELETE | DELETE FROM order_items oi WHERE EXISTS (SELECT 'X' FROM orders o, users u WHERE oi.order_id = o.order_id AND o.user_id = u.user_id AND o.order_date < ? AND u.status = 'INACTIVE') AND oi.created_date < ? |
| UserDao | findUsersByCondition | UserDao.java | findUsersByCondition | SQL_SELECT | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date FROM users u WHERE u.del_yn = 'N' |
| UserDao | findUsersByAdvancedCondition | UserDao.java | findUsersByAdvancedCondition | SQL_SELECT | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date FROM users u WHERE u.del_yn = 'N' |
| UserDao | findUsersByType | UserDao.java | findUsersByType | SQL_SELECT | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date FROM users u WHERE u.del_yn = 'N' AND u.user_type = #{userType} |
| UserDao | createUser | UserDao.java | createUser | SQL_INSERT | INSERT INTO users (username, full_name, email, phone, password, status, user_type, created_date, email_verified, phone_verified, del_yn) VALUES (#{username}, #{fullName}, #{email}, #{phone}, #{password}, #{status}, #{userType}, #{createdDate}, #{emailVerified}, #{phoneVerified}, 'N') |
| UserDao | updateUser | UserDao.java | updateUser | SQL_UPDATE | UPDATE users SET (동적 컬럼들) WHERE user_id = #{userId} AND del_yn = 'N' |
| UserDao | deleteUser | UserDao.java | deleteUser | SQL_UPDATE | UPDATE users SET del_yn = 'Y', updated_date = NOW() WHERE user_id = #{userId} AND del_yn = 'N' |
| ProductDao | selectProductsByCondition | ProductDao.java | selectProductsByCondition | SQL_SELECT | SELECT * FROM products WHERE 조건들 |
| ProductDao | selectProductsByAdvancedCondition | ProductDao.java | selectProductsByAdvancedCondition | SQL_SELECT | SELECT p.*, c.category_name, b.brand_name FROM products p LEFT JOIN categories c ON p.category_id = c.category_id LEFT JOIN brands b ON p.brand_id = b.brand_id WHERE 조건들 |
| ProductDao | updateProductStock | ProductDao.java | updateProductStock | SQL_UPDATE | UPDATE products SET stock_quantity = stock_quantity + #{quantity}, updated_date = SYSDATE WHERE product_id = #{productId} |
| ProductDao | insertProductDynamic | ProductDao.java | insertProductDynamic | SQL_INSERT | INSERT INTO products (동적 컬럼들) VALUES (동적 값들) |

### 2.4 XML 직접 쿼리 (10개)

| XML파일명 | 쿼리ID | 쿼리종류 | 쿼리(SQL content) |
|-----------|--------|----------|-------------------|
| ImplicitJoinMapper.xml | selectUsersWithOrders | SQL_SELECT | SELECT u.user_id, u.username, o.order_id, o.total_amount FROM users u, orders o WHERE u.user_id = o.user_id AND u.status = #{status} AND o.order_date >= #{fromDate} |
| ImplicitJoinMapper.xml | selectUsersWithOrderDetails | SQL_SELECT | SELECT u.user_id, u.username, o.order_id, oi.product_id, p.product_name FROM users u, orders o, order_items oi, products p WHERE u.user_id = o.user_id AND o.order_id = oi.order_id AND oi.product_id = p.product_id AND u.status = #{status} AND o.order_date >= #{fromDate} |
| ImplicitJoinMapper.xml | selectUsersWithActiveOrders | SQL_SELECT | SELECT u.user_id, u.username, u.email FROM users u WHERE u.status = #{status} AND EXISTS (SELECT 1 FROM orders o WHERE u.user_id = o.user_id AND o.order_status = 'COMPLETED') |
| ImplicitJoinMapper.xml | selectUsersWithRecentOrders | SQL_SELECT | SELECT u.user_id, u.username, u.email FROM users u WHERE u.user_id IN (SELECT o.user_id FROM orders o WHERE o.order_date >= #{fromDate}) AND u.status = #{status} |
| ImplicitJoinMapper.xml | selectUsersWithOrderStatistics | SQL_SELECT | SELECT u.user_id, u.username, COUNT(o.order_id) as order_count, SUM(o.total_amount) as total_amount FROM users u, orders o WHERE u.user_id = o.user_id AND u.status = #{status} AND o.order_date >= #{fromDate} GROUP BY u.user_id, u.username HAVING COUNT(o.order_id) > #{minOrderCount} |
| UserMapper.xml | findUsersWithOrderInfo | SQL_SELECT | SELECT u.user_id, u.username, u.full_name, u.email, u.status, u.user_type, COUNT(o.order_id) as order_count, COALESCE(SUM(o.total_amount), 0) as total_order_amount, MAX(o.created_date) as last_order_date FROM users u LEFT JOIN orders o ON u.user_id = o.user_id AND o.del_yn = 'N' WHERE u.del_yn = 'N' GROUP BY u.user_id, u.username, u.full_name, u.email, u.status, u.user_type ORDER BY total_order_amount DESC |
| UserMapper.xml | findUsersByComplexSearch | SQL_SELECT | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date FROM users u WHERE u.del_yn = 'N' |
| ProductMapper.xml | selectProductsByBrand | SQL_SELECT | SELECT p.*, b.brand_name, b.country FROM products p INNER JOIN brands b ON p.brand_id = b.brand_id WHERE p.brand_id = #{brandId} AND p.del_yn = 'N' AND p.status = 'ACTIVE' ORDER BY p.product_name |
| ProductMapper.xml | selectLowStockProducts | SQL_SELECT | SELECT p.*, i.current_stock, i.reorder_point, s.supplier_name, s.lead_time_days FROM products p LEFT JOIN inventory i ON p.product_id = i.product_id LEFT JOIN suppliers s ON p.supplier_id = s.supplier_id WHERE i.current_stock <= #{threshold} AND p.status = 'ACTIVE' AND p.del_yn = 'N' ORDER BY i.current_stock ASC, s.lead_time_days DESC |
| ProductMapper.xml | getProductStatsByCategory | SQL_SELECT | SELECT c.category_name, COUNT(p.product_id) as product_count, AVG(p.price) as avg_price, MIN(p.price) as min_price, MAX(p.price) as max_price, SUM(p.stock_quantity) as total_stock, COUNT(CASE WHEN p.status = 'ACTIVE' THEN 1 END) as active_products, COUNT(CASE WHEN p.status = 'INACTIVE' THEN 1 END) as inactive_products FROM categories c LEFT JOIN products p ON c.category_id = p.category_id AND p.del_yn = 'N' GROUP BY c.category_id, c.category_name HAVING COUNT(p.product_id) > 0 ORDER BY product_count DESC, avg_price DESC |

## 3. USE_TABLE 관계 분석 (71개)

### 3.1 users 테이블 사용 (25개)

| 쿼리ID | 테이블명 | 사용컬럼 | 관계타입 |
|--------|----------|----------|----------|
| findUsersByCondition | users | user_id, username, full_name, email, phone, status, user_type, created_date, last_login_date, updated_date, del_yn | USE_TABLE |
| findUsersByAdvancedCondition | users | user_id, username, full_name, email, phone, status, user_type, created_date, last_login_date, updated_date, del_yn | USE_TABLE |
| findUsersByType | users | user_id, username, full_name, email, phone, status, user_type, created_date, last_login_date, updated_date, del_yn | USE_TABLE |
| findUserById | users | user_id, username, full_name, email, phone, status, user_type, created_date, last_login_date, updated_date, del_yn | USE_TABLE |
| existsByUsername | users | username, del_yn | USE_TABLE |
| existsByEmail | users | email, del_yn | USE_TABLE |
| isEmailVerified | users | user_id, email_verified, del_yn | USE_TABLE |
| isPhoneVerified | users | user_id, phone_verified, del_yn | USE_TABLE |
| getTotalUserCount | users | del_yn | USE_TABLE |
| getActiveUserCount | users | status, del_yn | USE_TABLE |
| getNewUsersTodayCount | users | created_date, del_yn | USE_TABLE |
| getPremiumUserCount | users | user_type, del_yn | USE_TABLE |
| getUserStatisticsByStatus | users | status, del_yn | USE_TABLE |
| getUserStatisticsByType | users | user_type, del_yn | USE_TABLE |
| getMonthlyRegistrationStats | users | created_date, del_yn | USE_TABLE |
| findUsersWithOrderInfo | users | user_id, username, full_name, email, status, user_type, created_date | USE_TABLE |
| findUsersByComplexSearch | users | user_id, username, full_name, email, phone, status, user_type, created_date, last_login_date | USE_TABLE |
| createUser | users | username, full_name, email, phone, password, status, user_type, created_date, email_verified, phone_verified, del_yn | USE_TABLE |
| updateUser | users | full_name, email, phone, status, user_type, password, email_verified, phone_verified, updated_date, user_id, del_yn | USE_TABLE |
| deleteUser | users | del_yn, updated_date, user_id | USE_TABLE |
| updateLastLogin | users | last_login_date, updated_date, user_id, del_yn | USE_TABLE |
| selectUsers | users | user_id, username, email, status, created_at | USE_TABLE |
| selectUserById | users | user_id, username, email, status, created_at | USE_TABLE |
| selectUserStatistics | users | status | USE_TABLE |
| updateUserStatus | users | status, updated_at, user_id | USE_TABLE |

### 3.2 products 테이블 사용 (20개)

| 쿼리ID | 테이블명 | 사용컬럼 | 관계타입 |
|--------|----------|----------|----------|
| selectProductById | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |
| selectProductsByCondition | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |
| selectProductsByAdvancedCondition | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |
| selectProductsByCategory | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |
| updateProductStock | products | stock_quantity, updated_date, product_id | USE_TABLE |
| updateProductDynamic | products | product_name, price, category_id, brand_id, stock_quantity, status, updated_date, product_id | USE_TABLE |
| deleteProduct | products | del_yn, updated_date, product_id | USE_TABLE |
| selectProductsByBrand | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |
| selectLowStockProducts | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |
| getProductStatsByCategory | products | product_id, price, stock_quantity, status, category_id, created_date, updated_date, del_yn | USE_TABLE |
| analyzeProductSalesPerformance | products | product_id, product_name, price, status, category_id, brand_id, created_date, updated_date, del_yn | USE_TABLE |
| insertProductDynamic | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |
| deleteProductsByCondition | products | del_yn, updated_date, status, category_id, created_date | USE_TABLE |
| countProductsByCondition | products | category_id, status, price, del_yn | USE_TABLE |
| selectProductsByCategory | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |
| selectProductsByBrand | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |
| selectLowStockProducts | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |
| getProductStatsByCategory | products | product_id, price, stock_quantity, status, category_id, created_date, updated_date, del_yn | USE_TABLE |
| analyzeProductSalesPerformance | products | product_id, product_name, price, status, category_id, brand_id, created_date, updated_date, del_yn | USE_TABLE |
| insertProductDynamic | products | product_id, product_name, description, price, stock_quantity, status, category_id, brand_id, supplier_id, warehouse_id, created_date, updated_date, del_yn | USE_TABLE |

### 3.3 orders 테이블 사용 (10개)

| 쿼리ID | 테이블명 | 사용컬럼 | 관계타입 |
|--------|----------|----------|----------|
| findUsersWithOrderInfo | orders | order_id, user_id, total_amount, created_date, del_yn | USE_TABLE |
| selectUsersWithOrders | orders | order_id, user_id, total_amount, order_date | USE_TABLE |
| selectUsersWithOrderDetails | orders | order_id, user_id, order_date | USE_TABLE |
| selectUsersWithActiveOrders | orders | order_id, user_id, order_status | USE_TABLE |
| selectUsersWithRecentOrders | orders | order_id, user_id, order_date | USE_TABLE |
| selectUsersWithOrderStatistics | orders | order_id, user_id, total_amount, order_date | USE_TABLE |
| insertUserOrderStatistics | orders | order_id, user_id, total_amount, order_date, order_status | USE_TABLE |
| updateUserStatusBasedOnOrders | orders | order_id, user_id, order_date, order_status | USE_TABLE |
| deleteInactiveUsersWithNoActivity | orders | order_id, user_id, order_date | USE_TABLE |
| insertProductRecommendations | orders | order_id, user_id, order_status | USE_TABLE |

### 3.4 order_items 테이블 사용 (8개)

| 쿼리ID | 테이블명 | 사용컬럼 | 관계타입 |
|--------|----------|----------|----------|
| selectUsersWithOrderDetails | order_items | order_id, product_id, quantity, unit_price | USE_TABLE |
| analyzeProductSalesPerformance | order_items | order_id, product_id, quantity, unit_price | USE_TABLE |
| insertProductRecommendations | order_items | order_id, product_id, quantity, unit_price | USE_TABLE |
| deleteOldOrderItems | order_items | order_id, product_id, created_date | USE_TABLE |
| findProductsOrderedAfterDate | order_items | order_id, product_id, quantity, unit_price | USE_TABLE |
| findPopularProducts | order_items | order_id, product_id, quantity, unit_price | USE_TABLE |
| findNeverOrderedProducts | order_items | order_item_id, order_id, product_id | USE_TABLE |
| insertProductRecommendationsWithJoin | order_items | order_id, product_id, quantity, unit_price | USE_TABLE |

### 3.5 categories 테이블 사용 (5개)

| 쿼리ID | 테이블명 | 사용컬럼 | 관계타입 |
|--------|----------|----------|----------|
| selectProductsByAdvancedCondition | categories | category_id, category_name | USE_TABLE |
| getProductStatsByCategory | categories | category_id, category_name | USE_TABLE |
| analyzeProductSalesPerformance | categories | category_id, category_name | USE_TABLE |
| updateProductPricesBasedOnAnalysis | categories | category_id, category_name | USE_TABLE |
| findProductsInActiveCategories | categories | category_id, is_active | USE_TABLE |

### 3.6 brands 테이블 사용 (3개)

| 쿼리ID | 테이블명 | 사용컬럼 | 관계타입 |
|--------|----------|----------|----------|
| selectProductsByAdvancedCondition | brands | brand_id, brand_name | USE_TABLE |
| selectProductsByBrand | brands | brand_id, brand_name, country | USE_TABLE |
| updateProductPricesBasedOnAnalysis | brands | brand_id, brand_name | USE_TABLE |

## 4. JOIN 관계 분석 (20개)

### 4.1 명시적 조인 (JOIN_EXPLICIT) - 12개

| 쿼리ID | 테이블1 | 테이블2 | 조인조건 | 관계타입 |
|--------|---------|---------|----------|----------|
| selectProductsByAdvancedCondition | products | categories | p.category_id = c.category_id | JOIN_EXPLICIT |
| selectProductsByAdvancedCondition | products | brands | p.brand_id = b.brand_id | JOIN_EXPLICIT |
| selectProductsByBrand | products | brands | p.brand_id = b.brand_id | JOIN_EXPLICIT |
| selectLowStockProducts | products | inventory | p.product_id = i.product_id | JOIN_EXPLICIT |
| selectLowStockProducts | products | suppliers | p.supplier_id = s.supplier_id | JOIN_EXPLICIT |
| getProductStatsByCategory | categories | products | c.category_id = p.category_id | JOIN_EXPLICIT |
| analyzeProductSalesPerformance | products | order_items | p.product_id = oi.product_id | JOIN_EXPLICIT |
| analyzeProductSalesPerformance | order_items | orders | oi.order_id = o.order_id | JOIN_EXPLICIT |
| analyzeProductSalesPerformance | products | categories | p.category_id = c.category_id | JOIN_EXPLICIT |
| analyzeProductSalesPerformance | products | brands | p.brand_id = b.brand_id | JOIN_EXPLICIT |
| findUsersWithOrderInfo | users | orders | u.user_id = o.user_id | JOIN_EXPLICIT |
| selectUserById | users | user_profiles | u.user_id = up.user_id | JOIN_EXPLICIT |

### 4.2 암시적 조인 (JOIN_IMPLICIT) - 8개

| 쿼리ID | 테이블1 | 테이블2 | 조인조건 | 관계타입 |
|--------|---------|---------|----------|----------|
| selectUsersWithOrders | users | orders | u.user_id = o.user_id | JOIN_IMPLICIT |
| selectUsersWithOrderDetails | users | orders | u.user_id = o.user_id | JOIN_IMPLICIT |
| selectUsersWithOrderDetails | orders | order_items | o.order_id = oi.order_id | JOIN_IMPLICIT |
| selectUsersWithOrderDetails | order_items | products | oi.product_id = p.product_id | JOIN_IMPLICIT |
| selectUsersWithOrderStatistics | users | orders | u.user_id = o.user_id | JOIN_IMPLICIT |
| insertUserOrderStatistics | users | orders | u.user_id = o.user_id | JOIN_IMPLICIT |
| insertProductRecommendations | users | orders | u.user_id = o.user_id | JOIN_IMPLICIT |
| insertProductRecommendations | orders | order_items | o.order_id = oi.order_id | JOIN_IMPLICIT |

### 4.3 MERGE 조인 (JOIN_MERGEON) - 0개

현재 SampleSrc 폴더에는 MERGE 쿼리가 없습니다.

## 5. 오류 케이스 분석

### 5.1 문법 오류 파일 (2개)

| 파일명 | 오류유형 | 오류내용 | 영향도 |
|--------|----------|----------|--------|
| ErrorController.java | 컴파일 오류 | 잘못된 변수 타입, null 체크 없음, 잘못된 어노테이션 사용, 중괄호 불일치, 잘못된 import, 중복 변수 선언, SQL Injection 위험, 무한 루프 | 높음 |
| SyntaxErrorController.java | 정상 파일 | 이름만 오류, 실제로는 정상 구문 | 없음 |

### 5.2 부분 오류 파일 (1개)

| 파일명 | 오류유형 | 오류내용 | 영향도 |
|--------|----------|----------|--------|
| mixed/partialError.jsp | JSP 태그 오류 | 잘못된 EL 표현식, 잘못된 스크립틀릿, 잘못된 태그 | 중간 |

### 5.3 정상 파일 (54개)

나머지 모든 파일들은 정상 구문입니다.

