# SourceAnalyzer 처리 플로우 구현 가이드

## 문서 목적

이 문서는 SourceAnalyzer 시스템의 **실제 구현 과정과 개발 가이드**를 상세히 설명합니다.  
**대상 독자**: 개발자, 시스템 엔지니어  
**참조 문서**: [요구사항정의서.md](./요구사항정의서.md), [메타데이터베이스스키마정의서.md](./메타데이터베이스스키마정의서.md)

## 개요

SourceAnalyzer의 실제 메타데이터 생성 플로우는 `main.py`로부터 시작한다.

## 전체 처리 플로우

```mermaid
flowchart TD
    A[SourceAnalyzer 시작] --> B[1단계: 파일 스캔 완료]
    B --> C[2단계: DB 스키마 로드 완료]
    C --> D[3단계: XML 분석 완료]
    D --> E[4단계: Java 분석 완료]
    E --> F[5단계: API 매핑 정리 완료]
    F --> G[6단계: Qwen 보완 분석]
    G --> H[7단계: 일관성 체크]
    H --> I[완료]
    
    B -.-> B1[files 테이블 등록\n프로젝트 전체 스캔]
    C -.-> C1[tables/columns 저장\nTABLE/COLUMN 컴포넌트 생성]
    D -.-> D1["Enhanced 파서 시도<br/>(<include>, 동적SQL 지원)"]
    D1 --> D2{"파싱 성공?"}
    D2 -- Yes --> D4[SQL_* 컴포넌트 생성<br/>JOIN 관계 분석]
    D2 -- No --> D3["기본 파서로 대체 실행<br/>(안정성 보장)"]
    D3 --> D4
    E -.-> E1[classes 저장\nMETHOD 컴포넌트 생성\n관계 분석]
    F -.-> F1[API_URL 컴포넌트 생성\nCALL_API 관계 생성]
    G -.-> G1[Qwen Coder 7B\n고급 분석 및 보완]
    H -.-> H1[최종 중복 및 참조\n무결성 오류 점검]
    
    style A fill:#e1f5fe
    style I fill:#c8e6c9
    style B fill:#c8e6c9
    style C fill:#c8e6c9
    style D fill:#c8e6c9
    style D1 fill:#fff3e0
    style D2 fill:#fff3e0
    style D3 fill:#ffeb3b
    style D4 fill:#c8e6c9
    style E fill:#c8e6c9
    style F fill:#fff3e0
    style G fill:#c8e6c9
    style H fill:#fff3e0
    style I fill:#ffcdd2
```

## 시스템 폴더 구조

```
D:\Analyzer\CreateMetaDb\
├── config/                  # 설정 파일들
│   ├── config.yaml         # 시스템 설정
│   ├── config.yaml.bak     # 설정 백업
│   ├── logging.yaml        # 로깅 설정
│   ├── target_source_config.yaml # 파일 필터링 설정
│   └── parser/             # 파서별 키워드 설정
│       ├── mybatis_dom_rules.yaml  # MyBatis DOM 파싱 규칙 ✅ **구현 완료**
│       ├── mybatis_keyword.yaml    # MyBatis 키워드 설정 ✅ **구현 완료**
│       ├── method_xml_patterns.yaml # 메서드 XML 패턴 정의 ✅ **구현 완료**
│       ├── ai_config.yaml
│       ├── css_keyword.yaml
│       ├── html_keyword.yaml
│       ├── java_keyword.yaml
│       ├── javascript_keyword.yaml
│       ├── jpa_keyword.yaml
│       ├── jquery_keyword.yaml
│       ├── jsp_keyword.yaml
│       ├── oracle_sql_keyword.yaml
│       ├── spring_keyword.yaml
│       ├── sql_keyword.yaml
│       └── xml_parser_config.yaml
├── database/               # DB 스키마
│   ├── create_table_script.sql  # 메타데이터베이스 스키마
│   └── create_sql_content_db.sql  # SQL Content DB 스키마 ✅ **구현 완료**
├── docs/                   # 문서들
│   ├── report/             # 진척보고 및 분석 리포트
│   ├── 메타데이터베이스스키마정의서.md
│   ├── 요구사항정의서.md
│   ├── 처리플로우_요약.md
│   ├── 처리플로우_상세_1단계.md
│   ├── 처리플로우_상세_2단계.md
│   └── 처리플로우_상세_3단계.md
├── parser/                 # 파서 소스 코드 및 매뉴얼
│   ├── xml_parser.py       # MyBatis XML 파서 (DOM + SAX Fallback) ✅ **구현 완료**
│   ├── sax_fallback_parser.py # SAX Fallback 파서 ✅ **구현 완료**
│   └── manual/             # 기술별 매뉴얼
│       ├── 01_java/
│       ├── 02_jsp/
│       ├── 03_web_frontend/
│       ├── 04_mybatis/     # MyBatis 파서 가이드 ✅ **구현 완료**
│       ├── 05_jpa/
│       ├── 06_oracle_sql/
│       ├── 07_spring/
│       ├── 08_xml/
│       └── 99_common/
├── util/                   # 유틸리티 소스 코드
│   ├── __init__.py
│   ├── arg_utils.py        # 명령행 인자 처리
│   ├── arg_utils_example.py
│   ├── config_utils.py     # 설정 파일 처리
│   ├── database_utils.py   # 데이터베이스 유틸리티
│   ├── file_utils.py       # 파일 처리 유틸리티
│   ├── global_project.py   # 글로벌 프로젝트 정보 관리 ✅ **구현 완료**
│   ├── hash_utils.py       # 해시 처리 유틸리티
│   ├── integrated_example.py
│   ├── logger.py           # 로깅 유틸리티
│   ├── path_utils.py       # 경로 처리 유틸리티
│   ├── path_utils_example.py
│   ├── sql_content_manager.py  # SQL Content DB 관리 ✅ **구현 완료**
│   ├── sql_content_processor.py # SQL Content 처리 (현재 보류 상태)
│   └── validation_utils.py # 검증 유틸리티
├── projects/               # 분석 대상 프로젝트들
│   └── SampleSrc/          # 샘플 프로젝트
│       ├── config/
│       │   └── target_source_config.yaml
│       ├── db_schema/      # DB 스키마 CSV 파일
│       │   ├── ALL_TABLES.csv
│       │   └── ALL_TAB_COLUMNS.csv
│       ├── metadata.db     # 메타데이터베이스
│       ├── SqlContent.db   # SQL Content 데이터베이스 (현재 보류 상태)
│       └── src/            # 소스 코드
│           └── ... 내용은 프로젝트마다 가변
├── logs/                   # 로그 파일들
├── temp/                   # 임시 파일들
├── qna/                    # Q&A 폴더
├── main.py                 # 메인 실행 파일
├── file_loading.py         # 1-2단계 처리 (파일 스캔, DB 구조 저장) ✅ **구현 완료**
└── xml_loading.py          # 3단계 처리 (XML 분석) ✅ **구현 완료**
```

## 실제 처리 순서 (5단계 구현 완료)

### 1단계: 파일 정보 저장 (프로젝트 전체 스캔) ✅ **구현 완료**

- **목적**: `./projects/{project_name}` 하위 모든 파일을 `files` 테이블에 등록
- **처리**: 
  - `FileUtils.scan_directory()`로 프로젝트 전체 디렉토리 재귀적 스캔
  - `target_source_config.yaml` 설정 기반 파일 필터링 (include/exclude 패턴)
  - 파일 확장자로 타입 결정 (java, xml, jsp, sql, csv 등)
  - `HashUtils`로 파일 내용 해시값 생성
  - `DatabaseUtils.upsert()`로 `INSERT OR REPLACE` 실행
- **결과**: 모든 파일의 `file_id` 생성으로 후속 단계에서 참조 가능
- **구현 파일**: `file_loading.py` (FileLoadingEngine.execute_file_scan)
- **상세 문서**: [04_1단계_파일_스캔_구현서.md](./04_1단계_파일_스캔_구현서.md)

### 2단계: 데이터베이스 구조 저장 및 컴포넌트 생성 ✅ **구현 완료**

- **목적**: CSV 파일에서 테이블/컬럼 정보를 메타DB에 저장하고 components에 등록
- **처리**: 
  - `FileLoadingEngine.execute_db_loading()`: ALL_TABLES.csv → `tables` 테이블, ALL_TAB_COLUMNS.csv → `columns` 테이블
  - TABLE/COLUMN 컴포넌트 생성 및 components 테이블 등록
  - 데이터 타입, NULL 허용 여부, PK 정보, 컬럼 코멘트, 기본값 등 상세 정보 저장
- **구현 파일**: `file_loading.py` (FileLoadingEngine.execute_db_loading)
- **상세 문서**: [05_2단계_DB_구조_저장_구현서.md](./05_2단계_DB_구조_저장_구현서.md)
  - `FileLoadingEngine.create_table_components()`: `tables` 테이블의 모든 테이블을 `components` 테이블에 `TABLE` 타입으로 등록
  - `FileLoadingEngine.create_column_components()`: `columns` 테이블의 모든 컬럼을 `components` 테이블에 `COLUMN` 타입으로 등록 (component_name: "컬럼명" 형태, parent_id: 테이블의 component_id) 및 columns 테이블의 component_id 업데이트
  - `HashUtils`로 테이블/컬럼 해시값 생성
  - `DatabaseUtils.batch_insert_or_replace()`로 배치 저장
- **결과**: 테이블/컬럼 구조 정보 저장 및 components에서 참조 가능
- **상세 문서**: [처리플로우_상세_2단계.md](./처리플로우_상세_2단계.md)

> **관련 스키마**: `tables`, `columns`, `components` 테이블 구조는 [메타데이터베이스스키마정의서.md](./메타데이터베이스스키마정의서.md) 참조

### 3단계: XML 파일 분석 (안정성과 커버리지 동시 확보) ✅ **구현 완료**

- **목적**: MyBatis XML 파일에서 SQL 쿼리를 안정적으로 추출하고, JOIN 관계를 분석하여 `components` 및 `relationships` 테이블에 등록합니다.
- **처리**:
  - **이중 파서(Dual-Parser) 아키텍처**를 통해 안정성과 분석 커버리지를 동시에 확보합니다.
  - **1. `Enhanced Parser` 우선 시도**:
    - `<include>` 태그를 해석하여 완전한 SQL을 재구성합니다.
    - 기본적인 동적 SQL(`<if>`, `<foreach>`)을 분석하여 대표 SQL 구문을 생성합니다.
  - **2. `기본 파서`로 안전하게 대체 실행 (Fallback)**:
    - `Enhanced Parser`가 실패할 경우, 재귀 호출을 제거하여 안정성을 극대화한 기본 파서가 실행됩니다.
    - 이를 통해 어떤 복잡한 XML 파일이라도 시스템 중단 없이 최소한의 분석을 보장합니다.
  - **단일 패스 처리**: 각 파일은 이 과정 중 단 한 번만 파싱되어 효율적으로 처리됩니다.
- **결과**: SQL 쿼리 컴포넌트 및 JOIN 관계가 누락과 오류 없이 메타데이터베이스에 저장됩니다.
- **상세 문서**: [06_3단계_XML_분석_구현서.md](./06_3단계_XML_분석_구현서.md)

### 4단계: Java 소스코드 분석 및 관계 생성 - 메모리 최적화 ✅ **구현 완료**

- **목적**: Java 파일에서 CLASS, METHOD 추출 및 관계 분석을 한 번에 처리
- **처리**:
  - `get_filtered_files()`로 Java 파일 수집
  - **스트리밍 처리**: `JavaParser.parse_java_file()`로 한 파일씩 처리
  - **통합 분석**: 클래스/메서드 추출과 관계 분석을 동시에 처리
  - `classes` 테이블에 클래스 정보 등록 (상속 관계는 `parent_class_id`로 저장)
  - `components` 테이블에 `METHOD` 타입으로 등록 (component_name: "클래스명.메서드명")
  - **관계 분석**: CALL_QUERY_M2S, CALL_METHOD_C2S, CALL_METHOD_S2D, USE_TABLE_S2D 관계를 relationships 테이블에 등록
  - **인터페이스 구현 관계는 저장하지 않음** (껍데기일 뿐, 실제 메서드 호출 분석에 불필요)
  - **소스 코드 레벨에서만 분석** (런타임 의존성은 고려하지 않음)
  - **오류 처리**: 파싱 오류 발생 시 `has_error='Y'` 설정하고 다음 파일로 계속 진행
- **결과**: CLASS, METHOD 정보 등록 및 관계 분석 완료 (메모리 사용량 최소화)
- **파일**: `java_loading.py` (메인 엔진), `parser/java_parser.py` (파싱 로직)

> **관련 스키마**: `classes`, `components`, `relationships` 테이블 구조는 [메타데이터베이스스키마정의서.md](./메타데이터베이스스키마정의서.md) 참조

### 5단계: API 진입점 분석 (개발 예정)

- **목적**: Java 백엔드 제일 앞단인 API 진입점을 분석하여 프론트엔드 → 백엔드 호출 체인 구성
- **처리**: 
  - Java 파일에서 백엔드 진입점 식별 (`@RestController`, `@Controller`, `@RequestMapping` 등)
  - API 엔드포인트 매핑 (URL 패턴 → Controller 메서드)
  - `API_ENTRY` 타입으로 components 테이블에 등록
  - 가상 프론트엔드 컴포넌트 생성 (`FRONTEND_API` 타입)
  - **프론트엔드 → 백엔드 진입점**: `CALL_API_F2B` 관계 생성
  - **완전한 호출 체인 구성**: Frontend → API_ENTRY → Controller → Service → DAO → DB
- **결과**: 프론트엔드 기술 무관하게 백엔드 제일 앞단부터 완전한 호출 체인 구성
- **파일**: `backend_entry_loading.py` (메인 엔진), `parser/backend_entry_analyzer.py` (파싱 로직)
- **상세 문서**: [처리플로우_상세_5단계.md](./처리플로우_상세_5단계.md)

### 6단계: JSP 파일 분석 ✅ **구현 완료**

- **목적**: JSP 파일을 `components` 테이블에 등록하고 JSP → Java 메서드 관계 생성
- **처리**: 
  - `get_filtered_files()`로 JSP 파일 수집
  - **스트리밍 처리**: 한 파일씩만 메모리에 로드하여 처리
  - JSP 파일을 `JSP` 타입으로 components 테이블에 등록
  - JSP에서 Java 메서드 호출 분석 (스크립틀릿, 표현식, EL, JSTL 등)
  - **JSP → METHOD**: `CALL_METHOD_C2S` 관계 생성 (inferred 메서드 자동 생성)
  - **JSP → CLASS**: 관계 생성 안함 (parent_id로 찾아감)
  - 처리 후 즉시 메모리에서 해제 (`del jsp_content`)
- **결과**: JSP 컴포넌트 등록 및 JSP → Java 메서드 관계 생성 완료 (메모리 사용량 최소화)
- **파일**: `jsp_loading.py` (메인 엔진), `parser/jsp_parser.py` (파싱 로직)
- **상세 문서**: [처리플로우_상세_6단계.md](./처리플로우_상세_6단계.md)

### 7단계: Qwen Coder 7B 보완 분석 (개발 예정)

- **목적**: Qwen Coder 7B를 활용하여 1-6단계 메타디비의 정확도 검증 및 고급 인사이트 도출
- **처리**: 
  - 현재 메타디비 상태 로드 및 분석 대상 영역 식별
  - 8개 분석 영역별 Qwen 분석 실행:
    - 고급 SQL 패턴 분석 (복잡한 JOIN, 성능 이슈, 보안 취약점)
    - 복잡한 Java 관계 분석 (의존성 주입, 메서드 체인, 설계 패턴)
    - API 진입점 분석 (RESTful API, GraphQL, 마이크로서비스)
    - JSP 동적 관계 분석 (AJAX 호출, 세션 관리, 폼 처리)
    - 비즈니스 로직 식별 (도메인 규칙, 워크플로우, 권한 관리)
    - 코드 품질 분석 (복잡도, 코드 냄새, 중복 코드)
    - 보안 취약점 분석 (SQL 인젝션, XSS, CSRF)
    - 성능 이슈 분석 (N+1 쿼리, 메모리 누수, 캐시 활용)
    - 아키텍처 패턴 분석 (MVC, SOLID 원칙, 레이어드 아키텍처)
  - 결과 병합 및 검증, 메타디비 업데이트
  - 고급 인사이트 리포트 및 정답지 자동 생성
- **결과**: 정확도 85% → 95% 향상, 실무 활용 가능한 분석 리포트 생성
- **파일**: `qwen_loading.py` (메인 엔진), `parser/qwen_analyzer.py` (분석 로직)
- **상세 문서**: [처리플로우_상세_7단계.md](./처리플로우_상세_7단계.md)

### 8단계: 일관성 체크 (향후 개발)

- **목적**: 최종 중복 제거, 참조 무결성 점검, 데이터 일관성 검증
- **처리**:
  - `metadata_engine.check_consistency()`: 중복 데이터 정리
  - `metadata_engine.validate_references()`: 참조 무결성 점검
  - `metadata_engine.finalize_metadata()`: 최종 통계 및 정리
- **결과**: 완전한 메타데이터 및 일관성 보장

### 최종 단계: 데이터 무결성 정리 (향후 개발)

- **목적**: 최종 데이터 정리 및 통계 생성
- **처리**:
  - `metadata_engine.finalize_metadata_generation()`: 고아 컬럼 정리, 중복 관계 정리
- **결과**: 최종 통계 및 정리 완료

## 핵심 설계 원칙

### Components 테이블 저장 대상

- **저장**: CLASS, METHOD, SQL_*, TABLE, COLUMN, API_URL
- **상세 정보**: API_URL은 components 테이블에 저장
- **제외**: java 파일 자체 (files 테이블에만 저장)

### Relationships 테이블 역할

- **모든 관계 통합 관리**: 컴포넌트 간, 컬럼 간, 테이블 간 관계
- **조인 관계**: 테이블 간 조인 관계도 relationships에서 관리
- **호출 관계**: 메서드 → 쿼리, JSP → 메서드, JSP → FRONTEND_API → API_ENTRY → METHOD 등

### 처리 순서의 중요성

1. **종속관계 고려**: 하위 테이블부터 생성 후 상위 테이블 연결
2. **컴포넌트 우선**: relationships에서 참조할 수 있도록 components 먼저 생성
3. **관계 마지막**: 모든 컴포넌트 생성 후 관계 정의

# 처리단계

### 처리단계 현황

```mermaid
flowchart TD
    A1["1단계<br/>파일 스캔<br/>143개 파일"] --> A2["2단계<br/>DB 구조 저장<br/>테이블/컬럼 로드"]
    
    A2 --> A3["3단계<br/>XML 분석<br/>MyBatis 파싱"]
    
    A3 --> A4["4단계<br/>Java 분석<br/>클래스/메서드 추출"]
    
    A4 --> A5["5단계<br/>백엔드 진입점<br/>Spring/Servlet API"]
    
    A5 --> A6["리포트 생성<br/>CallChain, ERD<br/>Architecture"]
    
    A6 -.-> B1["7단계<br/>AI 보완 분석<br/>개발 예정"]
    
    B1 -.-> B2["8단계<br/>일관성 체크<br/>개발 예정"]
    
    style A1 fill:#c8e6c9
    style A2 fill:#c8e6c9
    style A3 fill:#c8e6c9
    style A4 fill:#c8e6c9
    style A5 fill:#c8e6c9
    style A6 fill:#c8e6c9
    style B1 fill:#fff3e0
    style B2 fill:#fff3e0
```

- [✅] **1단계: 파일 스캔** - 프로젝트 전체 파일 인덱싱 및 files 테이블 등록 - **구현 완료**
- [✅] **2단계: DB 구조 저장** - CSV에서 테이블/컬럼 정보 추출 및 components 등록 - **구현 완료**
- [✅] **3단계: XML 분석** - Enhanced MyBatis 파싱, SQL 컴포넌트 생성, JOIN 관계 분석 - **구현 완료**
- [✅] **4단계: Java 분석** - 클래스/메서드 추출, SQL 추출, 관계 분석 - **구현 완료**
- [✅] **5단계: 백엔드 진입점 분석** - Spring/Servlet API 진입점 분석 - **구현 완료**
- [✅] **리포트 생성** - CallChain, ERD, Architecture, Sequence Diagram 리포트 - **구현 완료**
- [⏳] **7단계: AI 보완 분석** - AI 기반 고급 분석 및 정확도 향상 - **개발 예정**
- [⏳] **8단계: 일관성 체크** - 최종 중복 제거 및 참조 무결성 점검 - **개발 예정**

## 실제 개발 플로우 검증

현재 SourceAnalyzer는 다음과 같은 플로우로 동작합니다:

```
1. 파일 스캔 → files 테이블 등록 ✅ **구현 완료**
2. CSV 로드 → tables/columns 테이블 등록 → TABLE 컴포넌트 등록 ✅ **구현 완료**
3. XML 분석 + JOIN 관계 분석 (통합 처리, 메모리 최적화) → SQL_* 컴포넌트 등록 + JOIN 관계 등록 ✅ **구현 완료**
   - 한 번의 XML 읽기로 SQL 추출과 JOIN 분석을 동시 처리
   - ✅ **SQL Content DB에 gzip 압축 저장** (SqlContentProcessor 적용 완료)
   - ✅ **공통 SQL 조인 분석 모듈** 적용 (SqlJoinAnalyzer)
   - Explicit JOIN (ANSI SQL) 및 Implicit JOIN (Oracle 전통 구문) 모두 지원
   - 별칭 해석 및 별칭 생략 처리로 정확한 테이블 관계 추출
   - 쿼리에서 도출된 테이블이 기존 tables에 없을 수 있음 (정상 상황)
   - project_id, table_name으로 tables에서 조회 시:
     * table_owner가 'UNKNOWN'이 아닌 테이블을 우선 선택 (LIMIT 1)
     * table_owner가 'UNKNOWN'이 아닌 테이블이 없으면 'UNKNOWN' 테이블 선택
   - 기존 테이블이 없으면 inferred 테이블 생성:
     * table_owner='UNKNOWN', HASH_VALUE='INFERRED'로 tables에 등록
   - inferred 테이블의 table_id로 relationships 등록
4. Java 분석 + 관계 생성 + **SQL 추출** (메모리 최적화) → classes 테이블 등록 + METHOD 컴포넌트 등록 + **SQL_* 컴포넌트 등록** + 관계 등록 ✅ **구현 완료**
   - 한 번의 Java 읽기로 클래스/메서드 추출과 관계 분석을 동시 처리
   - ✅ **StringBuilder SQL 추출**: Java 코드에서 StringBuilder 패턴으로 작성된 SQL 자동 추출
   - ✅ **SQL 압축 저장**: 추출된 SQL을 gzip 압축하여 SqlContent.db에 저장
   - ✅ **공통 SQL 조인 분석**: XML과 동일한 수준의 오라클 조인 분석 (EXPLICIT/IMPLICIT)
   - CALL_QUERY_M2S/CALL_METHOD_C2S/CALL_METHOD_S2D/USE_TABLE_S2D 관계를 relationships 테이블에 등록
   - inferred 컴포넌트 자동 생성 (기존에 없는 클래스/메서드/쿼리/테이블)
5. API 매핑 정리 → API_URL 컴포넌트 생성 + 프론트엔드 → 백엔드 관계 생성 (개발 예정)
   - 프론트엔드 API 호출 = 백엔드 API 진입점 (동일한 URL)
   - components 테이블에 API_URL 컴포넌트 생성 (중복 저장 불필요)
   - file_id로 프론트엔드 파일과 API_URL 연결
   - relationships 테이블에 CALL_API 관계 생성
   - 완전한 호출 체인 구성: JSP 파일 → API_URL → METHOD → SQL_* → TABLE
6. JSP 분석 (메모리 최적화) → JSP 컴포넌트 등록 + JSP → METHOD 관계 생성 + JSP → API 관계 분석 ✅ **구현 완료**
   - 한 번의 JSP 읽기로 컴포넌트 등록과 관계 분석을 동시 처리
   - inferred 메서드 자동 생성 (기존에 없는 메서드)
   - JSP에서 API 호출 패턴 분석 및 API_URL 컴포넌트 생성
   - 완전한 호출 체인: JSP 파일 → API_URL → METHOD → SQL_* → TABLE
7. Qwen 보완 분석 → 정확도 검증 및 고급 인사이트 도출
8. 일관성 체크 → 최종 중복 및 참조 무결성 오류 점검
```

### 주요 개선 사항

- **3단계 Enhanced 파싱**: include 태그 해석, 동적 SQL 분석으로 누락 없는 SQL 추출 [OK]
- **3단계 통합 처리**: XML 파일 분석과 JOIN 관계 분석을 한 번에 처리하여 메모리 최적화 [OK]  
- **3단계 안전한 Fallback**: Enhanced → DOM → SAX → 정규식 다단계 파싱으로 안정성 보장 [OK]
- **4단계 Enhanced SQL 추출**: StringBuilder + 정규식 패턴으로 Java 문자열 리터럴 SQL 추출 [OK]
- **4단계 통합 처리**: Java 파일 분석과 관계 분석을 한 번에 처리하여 메모리 최적화 [OK]
- **4단계 메모리 최적화**: Java 파일 분석 시 스트리밍 처리로 메모리 사용량 최소화 [OK]
- **4단계 상속 관계**: Java 클래스 상속 관계를 `parent_class_id`로 저장 [OK]
- **공통 SQL 분석**: XML Enhanced + Java Enhanced에서 추출된 모든 SQL을 SqlJoinAnalyzer로 통합 분석 [OK]
- **누락 방지**: INSERT, UPDATE, DELETE, SELECT, MERGE 모든 SQL 타입에서 테이블/조인 관계 완전 추출 [OK]
- **5단계 API 매핑 정리**: 프론트엔드 API 호출 = 백엔드 API 진입점 (동일한 URL)
- **5단계 단순화된 구조**: API_URL 하나로 프론트엔드와 백엔드 연결 (중복 저장 불필요)
- **5단계 명확한 연결**: file_id로 프론트엔드 파일과 API_URL 연결
- **5단계 완전한 호출 체인**: JSP 파일 → API_URL → METHOD → SQL_* → TABLE 구성
- **6단계 JSP 분석**: JSP 파일을 components 테이블에 등록하고 JSP → METHOD 관계 생성 [OK]
- **6단계 API 관계 분석**: JSP에서 API 호출 패턴 분석 및 API_URL 컴포넌트 생성 [OK]
- **6단계 메모리 최적화**: JSP 파일 분석 시 스트리밍 처리로 메모리 사용량 최소화 [OK]
- **6단계 inferred 컴포넌트**: 참조되는 메서드가 없으면 inferred 메서드 자동 생성 [OK]
- **7단계 Qwen 보완 분석**: Qwen Coder 7B를 활용한 고급 분석 및 정확도 향상 (85% → 95%)
- **8단계 일관성 체크**: 최종 중복 제거, 참조 무결성 점검, 데이터 일관성 검증

---

## 📚 관련 문서

- **[요구사항정의서.md](./요구사항정의서.md)**: 비즈니스 요구사항 및 기능 명세
- **[메타데이터베이스스키마정의서.md](./메타데이터베이스스키마정의서.md)**: 데이터베이스 스키마 구조 상세
- **[create_table_script.sql](../database/create_table_script.sql)**: 스키마 정의 원본 파일
- **[처리플로우_상세_1단계_파일정보저장.md](./처리플로우_상세_1단계_파일정보저장.md)**: 1단계 파일 정보 저장 상세 구현 가이드
- **[처리플로우_상세_2단계_데이터베이스구조저장.md](./처리플로우_상세_2단계_데이터베이스구조저장.md)**: 2단계 데이터베이스 구조 저장 상세 구현 가이드
- **[처리플로우_상세_3단계_XML분석및SQL컴포넌트등록.md](./처리플로우_상세_3단계_XML분석및SQL컴포넌트등록.md)**: 3단계 XML 파일 분석 및 SQL 컴포넌트 등록 상세 구현 가이드
- **[처리플로우_상세_4단계_Java소스코드분석및관계생성.md](./처리플로우_상세_4단계_Java소스코드분석및관계생성.md)**: 4단계 Java 소스코드 분석 및 관계 생성 상세 구현 가이드
- **[처리플로우_상세_5단계_API진입점분석.md](./처리플로우_상세_5단계_API진입점분석.md)**: 5단계 API 진입점 분석 상세 구현 가이드
- **[처리플로우_상세_6단계_JSP파일분석.md](./처리플로우_상세_6단계_JSP파일분석.md)**: 6단계 JSP 파일 분석 상세 구현 가이드
- **[처리플로우_상세_7단계_QwenCoder7B보완분석.md](./처리플로우_상세_7단계_QwenCoder7B보완분석.md)**: 7단계 Qwen Coder 7B 보완 분석 상세 구현 가이드
- **[DOM_vs_SAX_비교분석.md](./DOM_vs_SAX_비교분석.md)**: DOM과 SAX 파서 비교 및 SAX Fallback 구조 분석
