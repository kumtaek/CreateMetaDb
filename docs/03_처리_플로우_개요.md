# SourceAnalyzer 처리 플로우 구현 가이드

## 문서 목적

이 문서는 SourceAnalyzer 시스템의 **실제 구현 과정과 개발 가이드**를 상세히 설명합니다.  
**대상 독자**: 개발자, 시스템 엔지니어  
**참조 문서**: [요구사항정의서.md](./요구사항정의서.md), [메타데이터베이스스키마정의서.md](./메타데이터베이스스키마정의서.md)

## 개요

SourceAnalyzer의 실제 메타데이터 생성 플로우는 `main.py`로부터 시작한다.

## 전체 처리 플로우

### 🔄 **SourceAnalyzer 실행 단계**

| 단계 | 처리 내용 | 상태 | 핵심 작업 | 특이사항 |
|------|-----------|------|-----------|----------|
| **시작** | SourceAnalyzer 초기화 | 🚀 | 프로젝트 설정 로드 | `main.py` 실행 |
| **1단계** | 파일 스캔 완료 | ✅ | files 테이블 등록, 프로젝트 전체 스캔 | 143개 파일 처리 |
| **2단계** | DB 스키마 로드 완료 | ✅ | tables/columns 저장, TABLE/COLUMN 컴포넌트 생성 | CSV 파일 기반 |
| **3단계** | XML 분석 완료 | ✅ | MyBatis 파싱 → SQL 컴포넌트 생성 | Fallback: SAX |
| | | | ↳ MybatisParser 실행 (안정적 XML 파싱) | 파싱 성공 시 |
| | | | ↳ SAX Fallback 실행 (최소한의 SQL 추출) | 파싱 실패 시 |
| | | | ↳ SQL_* 컴포넌트 생성, JOIN 관계 분석 | 최종 결과 |
| **4단계** | Java 분석 완료 | ✅ | classes 저장, METHOD 컴포넌트 생성, 관계 분석 | StringBuilder SQL 지원 |
| **5단계** | 백엔드 API 매핑 완료 | ✅ | 백엔드 API_URL 생성, 백엔드 진입점 분석 | Spring/Servlet |
| **6단계** | 프론트엔드 분석 완료 | ✅ | 프론트엔드 API 호출 분석, frameworks 추적, API_URL 매칭 | JSP/JSX/Vue/TS/JS/HTML |
| **7단계** | 일관성 검증 완료 | ✅ | 일관성 검증, 치명적 문제 검출, 데이터 품질 보장 | 에러 시 종료 |
| **완료** | 분석 완료 | 🎯 | 메타데이터베이스 생성 완료 | 리포트 생성 가능 |

## 시스템 폴더 구조

```
D:\Analyzer\CreateMetaDb\
├── config/                  # 설정 파일들
│   ├── config.yaml         # 시스템 설정
│   ├── config.yaml.bak     # 설정 백업
│   ├── logging.yaml        # 로깅 설정
│   ├── target_source_config.yaml # 파일 필터링 설정
│   └── parser/             # 파서별 키워드 설정
│       ├── mybatis_dom_rules.yaml  # MyBatis DOM 파싱 규칙 ✅ **구현 완료**
│       ├── mybatis_keyword.yaml    # MyBatis 키워드 설정 ✅ **구현 완료**
│       ├── method_xml_patterns.yaml # 메서드 XML 패턴 정의 ✅ **구현 완료**
│       ├── ai_config.yaml
│       ├── css_keyword.yaml
│       ├── html_keyword.yaml
│       ├── java_keyword.yaml
│       ├── javascript_keyword.yaml
│       ├── jpa_keyword.yaml
│       ├── jquery_keyword.yaml
│       ├── jsp_keyword.yaml
│       ├── oracle_sql_keyword.yaml
│       ├── spring_keyword.yaml
│       ├── sql_keyword.yaml
│       └── xml_parser_config.yaml
├── database/               # DB 스키마
│   ├── create_table_script.sql  # 메타데이터베이스 스키마
│   └── create_sql_content_db.sql  # SQL Content DB 스키마 ✅ **구현 완료**
├── docs/                   # 문서들
│   ├── report/             # 진척보고 및 분석 리포트
│   ├── 메타데이터베이스스키마정의서.md
│   ├── 요구사항정의서.md
│   ├── 처리플로우_요약.md
│   ├── 처리플로우_상세_1단계.md
│   ├── 처리플로우_상세_2단계.md
│   └── 처리플로우_상세_3단계.md
├── parser/                 # 파서 소스 코드 및 매뉴얼
│   ├── xml_parser.py       # MyBatis XML 파서 (DOM + SAX Fallback) ✅ **구현 완료**
│   ├── sax_fallback_parser.py # SAX Fallback 파서 ✅ **구현 완료**
│   └── manual/             # 기술별 매뉴얼
│       ├── 01_java/
│       ├── 02_jsp/
│       ├── 03_web_frontend/
│       ├── 04_mybatis/     # MyBatis 파서 가이드 ✅ **구현 완료**
│       ├── 05_jpa/
│       ├── 06_oracle_sql/
│       ├── 07_spring/
│       ├── 08_xml/
│       └── 99_common/
├── util/                   # 유틸리티 소스 코드
│   ├── __init__.py
│   ├── arg_utils.py        # 명령행 인자 처리
│   ├── arg_utils_example.py
│   ├── config_utils.py     # 설정 파일 처리
│   ├── database_utils.py   # 데이터베이스 유틸리티
│   ├── file_utils.py       # 파일 처리 유틸리티
│   ├── global_project.py   # 글로벌 프로젝트 정보 관리 ✅ **구현 완료**
│   ├── hash_utils.py       # 해시 처리 유틸리티
│   ├── integrated_example.py
│   ├── logger.py           # 로깅 유틸리티
│   ├── path_utils.py       # 경로 처리 유틸리티
│   ├── path_utils_example.py
│   ├── sql_content_manager.py  # SQL Content DB 관리 ✅ **구현 완료**
│   ├── sql_content_processor.py # SQL Content 처리 (현재 보류 상태)
│   └── validation_utils.py # 검증 유틸리티
├── projects/               # 분석 대상 프로젝트들
│   └── SampleSrc/          # 샘플 프로젝트
│       ├── config/
│       │   └── target_source_config.yaml
│       ├── db_schema/      # DB 스키마 CSV 파일
│       │   ├── ALL_TABLES.csv
│       │   └── ALL_TAB_COLUMNS.csv
│       ├── metadata.db     # 메타데이터베이스
│       ├── SqlContent.db   # SQL Content 데이터베이스 (현재 보류 상태)
│       └── src/            # 소스 코드
│           └── ... 내용은 프로젝트마다 가변
├── logs/                   # 로그 파일들
├── temp/                   # 임시 파일들
├── qna/                    # Q&A 폴더
├── main.py                 # 메인 실행 파일
├── file_loading.py         # 1-2단계 처리 (파일 스캔, DB 구조 저장) ✅ **구현 완료**
└── xml_loading.py          # 3단계 처리 (XML 분석) ✅ **구현 완료**
```

## 실제 처리 순서 (5단계 구현 완료)

### 1단계: 파일 정보 저장 (프로젝트 전체 스캔) ✅ **구현 완료**

- **목적**: `./projects/{project_name}` 하위 모든 파일을 `files` 테이블에 등록
- **처리**: 
  - `FileUtils.scan_directory()`로 프로젝트 전체 디렉토리 재귀적 스캔
  - `target_source_config.yaml` 설정 기반 파일 필터링 (include/exclude 패턴)
  - 파일 확장자로 타입 결정 (java, xml, jsp, sql, csv 등)
  - `HashUtils`로 파일 내용 해시값 생성
  - `DatabaseUtils.upsert()`로 `INSERT OR REPLACE` 실행
- **결과**: 모든 파일의 `file_id` 생성으로 후속 단계에서 참조 가능
- **구현 파일**: `file_loading.py` (FileLoadingEngine.execute_file_scan)
- **상세 문서**: [04_1단계_파일_스캔_구현서.md](./04_1단계_파일_스캔_구현서.md)

### 2단계: 데이터베이스 구조 저장 및 컴포넌트 생성 ✅ **구현 완료**

- **목적**: CSV 파일에서 테이블/컬럼 정보를 메타DB에 저장하고 components에 등록
- **처리**: 
  - `FileLoadingEngine.execute_db_loading()`: ALL_TABLES.csv → `tables` 테이블, ALL_TAB_COLUMNS.csv → `columns` 테이블
  - TABLE/COLUMN 컴포넌트 생성 및 components 테이블 등록
  - 데이터 타입, NULL 허용 여부, PK 정보, 컬럼 코멘트, 기본값 등 상세 정보 저장
- **구현 파일**: `file_loading.py` (FileLoadingEngine.execute_db_loading)
- **상세 문서**: [05_2단계_DB_구조_저장_구현서.md](./05_2단계_DB_구조_저장_구현서.md)
  - `FileLoadingEngine.create_table_components()`: `tables` 테이블의 모든 테이블을 `components` 테이블에 `TABLE` 타입으로 등록
  - `FileLoadingEngine.create_column_components()`: `columns` 테이블의 모든 컬럼을 `components` 테이블에 `COLUMN` 타입으로 등록 (component_name: "컬럼명" 형태, parent_id: 테이블의 component_id) 및 columns 테이블의 component_id 업데이트
  - `HashUtils`로 테이블/컬럼 해시값 생성
  - `DatabaseUtils.batch_insert_or_replace()`로 배치 저장
- **결과**: 테이블/컬럼 구조 정보 저장 및 components에서 참조 가능
- **상세 문서**: [처리플로우_상세_2단계.md](./처리플로우_상세_2단계.md)

> **관련 스키마**: `tables`, `columns`, `components` 테이블 구조는 [메타데이터베이스스키마정의서.md](./메타데이터베이스스키마정의서.md) 참조

### 3단계: XML 파일 분석 (안정성과 커버리지 동시 확보) ✅ **구현 완료**

- **목적**: MyBatis XML 파일에서 SQL 쿼리를 안정적으로 추출하고, JOIN 관계를 분석하여 `components` 및 `relationships` 테이블에 등록합니다.
- **처리**:
  - **이중 파서(Dual-Parser) 아키텍처**를 통해 안정성과 분석 커버리지를 동시에 확보합니다.
  - **1. `Enhanced Parser` 우선 시도**:
    - `<include>` 태그를 해석하여 완전한 SQL을 재구성합니다.
    - 기본적인 동적 SQL(`<if>`, `<foreach>`)을 분석하여 대표 SQL 구문을 생성합니다.
  - **2. `기본 파서`로 안전하게 대체 실행 (Fallback)**:
    - `Enhanced Parser`가 실패할 경우, 재귀 호출을 제거하여 안정성을 극대화한 기본 파서가 실행됩니다.
    - 이를 통해 어떤 복잡한 XML 파일이라도 시스템 중단 없이 최소한의 분석을 보장합니다.
  - **단일 패스 처리**: 각 파일은 이 과정 중 단 한 번만 파싱되어 효율적으로 처리됩니다.
- **결과**: SQL 쿼리 컴포넌트 및 JOIN 관계가 누락과 오류 없이 메타데이터베이스에 저장됩니다.
- **상세 문서**: [06_3단계_XML_분석_구현서.md](./06_3단계_XML_분석_구현서.md)

### 4단계: Java 소스코드 분석 및 관계 생성 - 메모리 최적화 ✅ **구현 완료**

- **목적**: Java 파일에서 CLASS, METHOD 추출 및 관계 분석을 한 번에 처리
- **처리**:
  - `get_filtered_files()`로 Java 파일 수집
  - **스트리밍 처리**: `JavaParser.parse_java_file()`로 한 파일씩 처리
  - **통합 분석**: 클래스/메서드 추출과 관계 분석을 동시에 처리
  - `classes` 테이블에 클래스 정보 등록 (상속 관계는 `parent_class_id`로 저장)
  - `components` 테이블에 `METHOD` 타입으로 등록 (component_name: "클래스명.메서드명")
  - **관계 분석**: CALL_QUERY_M2S, CALL_METHOD_C2S, CALL_METHOD_S2D, USE_TABLE_S2D 관계를 relationships 테이블에 등록
  - **인터페이스 구현 관계는 저장하지 않음** (껍데기일 뿐, 실제 메서드 호출 분석에 불필요)
  - **소스 코드 레벨에서만 분석** (런타임 의존성은 고려하지 않음)
  - **오류 처리**: 파싱 오류 발생 시 `has_error='Y'` 설정하고 다음 파일로 계속 진행
- **결과**: CLASS, METHOD 정보 등록 및 관계 분석 완료 (메모리 사용량 최소화)
- **파일**: `java_loading.py` (메인 엔진), `parser/java_parser.py` (파싱 로직)

> **관련 스키마**: `classes`, `components`, `relationships` 테이블 구조는 [메타데이터베이스스키마정의서.md](./메타데이터베이스스키마정의서.md) 참조

### 5단계: API 진입점 분석 (개발 예정)

- **목적**: Java 백엔드 제일 앞단인 API 진입점을 분석하여 프론트엔드 → 백엔드 호출 체인 구성
- **처리**: 
  - Java 파일에서 백엔드 진입점 식별 (`@RestController`, `@Controller`, `@RequestMapping` 등)
  - API 엔드포인트 매핑 (URL 패턴 → Controller 메서드)
  - `API_ENTRY` 타입으로 components 테이블에 등록
  - 가상 프론트엔드 컴포넌트 생성 (`FRONTEND_API` 타입)
  - **프론트엔드 → 백엔드 진입점**: `CALL_API_F2B` 관계 생성
  - **완전한 호출 체인 구성**: Frontend → API_ENTRY → Controller → Service → DAO → DB
- **결과**: 프론트엔드 기술 무관하게 백엔드 제일 앞단부터 완전한 호출 체인 구성
- **파일**: `backend_entry_loading.py` (메인 엔진), `parser/backend_entry_analyzer.py` (파싱 로직)
- **상세 문서**: [처리플로우_상세_5단계.md](./처리플로우_상세_5단계.md)

### 6단계: 프론트엔드 파일 분석 ✅ **구현 완료**

- **목적**: 모든 프론트엔드 파일(JSP, JSX, Vue, TS, JS, HTML)을 분석하고 API 호출 관계 구축
- **처리**: 
  - **범용 프론트엔드 지원**: JSP, JSX, Vue, TypeScript, JavaScript, HTML 파일 통합 처리
  - **API 호출 분석**: jQuery, Axios, Fetch, XMLHttpRequest 등 다양한 방식 지원
  - **Frameworks 추적**: 각 파일에서 사용된 프론트엔드 기술 스택 자동 수집
  - **API_URL 컴포넌트 생성**: 프론트엔드 API 호출을 API_URL 컴포넌트로 변환
  - **백엔드 매칭**: 프론트엔드 API와 백엔드 API 자동 연결
  - **메모리 최적화**: 스트리밍 처리로 대용량 파일 효율적 처리
- **결과**: 완전한 프론트엔드 → 백엔드 호출 체인 구성, frameworks 사용 현황 추적
- **파일**: `frontend_loading.py` (통합 엔진), `parser/frontend_parser.py` (파싱 로직)
- **지원 기술**: jQuery, Axios, Fetch API, XMLHttpRequest, Vue Resource

### 7단계: 메타데이터베이스 일관성 검증 ✅ **구현 완료**

- **목적**: 메타데이터베이스 생성 완료 후 데이터 일관성 검증 및 오류 검출
- **처리**: 
  - 외래키 무결성 위반 검출 (FOREIGN KEY 제약조건)
  - API_URL 중복 검출 (프론트엔드-백엔드 연결 끊어짐 원인)
  - parent_id 타입 불일치 검출 (METHOD, COLUMN 부모 관계)
  - TABLE/COLUMN file_id 불일치 검출 (CSV 파일 기준)
  - CHECK 제약조건 위반 검출 (자기 참조 등)
  - 치명적 문제 발견 시 handle_error() 호출하여 프로그램 종료
- **결과**: 메타데이터베이스 품질 보장, 신뢰할 수 있는 분석 결과 제공
- **파일**: `consistency_validator.py`
- **상세 문서**: [10_7단계_일관성_검증_구현서.md](./10_7단계_일관성_검증_구현서.md)
- **처리**:
  - `metadata_engine.finalize_metadata_generation()`: 고아 컬럼 정리, 중복 관계 정리
- **결과**: 최종 통계 및 정리 완료

## 핵심 설계 원칙

### Components 테이블 저장 대상

- **저장**: CLASS, METHOD, SQL_*, TABLE, COLUMN, API_URL
- **상세 정보**: API_URL은 components 테이블에 저장
- **제외**: java 파일 자체 (files 테이블에만 저장)

### Relationships 테이블 역할

- **모든 관계 통합 관리**: 컴포넌트 간, 컬럼 간, 테이블 간 관계
- **조인 관계**: 테이블 간 조인 관계도 relationships에서 관리
- **호출 관계**: 메서드 → 쿼리, JSP → 메서드, JSP → FRONTEND_API → API_ENTRY → METHOD 등

### 처리 순서의 중요성

1. **종속관계 고려**: 하위 테이블부터 생성 후 상위 테이블 연결
2. **컴포넌트 우선**: relationships에서 참조할 수 있도록 components 먼저 생성
3. **관계 마지막**: 모든 컴포넌트 생성 후 관계 정의

# 처리단계

### 처리단계 현황

| 단계 | 처리 내용 | 처리량 | 상태 |
|------|-----------|--------|------|
| **1단계** | 파일 스캔 | 143개 파일 | ✅ 완료 |
| **2단계** | DB 구조 저장 | 테이블/컬럼 로드 | ✅ 완료 |
| **3단계** | XML 분석 | MyBatis 파싱 | ✅ 완료 |
| **4단계** | Java 분석 | 클래스/메서드 추출 | ✅ 완료 |
| **5단계** | 백엔드 진입점 | Spring/Servlet API | ✅ 완료 |
| **6단계** | 프론트엔드 분석 | 통합 처리 | ✅ 완료 |
| **7단계** | 일관성 검증 | 데이터 품질 보장 | ✅ 완료 |
| **리포트** | 리포트 생성 | CallChain, ERD, Architecture | ✅ 완료 |

- [✅] **1단계: 파일 스캔** - 프로젝트 전체 파일 인덱싱 및 files 테이블 등록 - **구현 완료**
- [✅] **2단계: DB 구조 저장** - CSV에서 테이블/컬럼 정보 추출 및 components 등록 - **구현 완료**
- [✅] **3단계: XML 분석** - MyBatis XML 파싱, SQL 컴포넌트 생성, JOIN 관계 분석 - **구현 완료**
- [✅] **4단계: Java 분석** - 클래스/메서드 추출, SQL 추출, 관계 분석 - **구현 완료**
- [✅] **5단계: 백엔드 진입점 분석** - Spring/Servlet API 진입점 분석 - **구현 완료**
- [✅] **6단계: 프론트엔드 분석** - 통합 프론트엔드 분석, frameworks 추적 - **구현 완료**
- [✅] **7단계: 일관성 검증** - 데이터 무결성 검증, 품질 보장 - **구현 완료**
- [✅] **리포트 생성** - CallChain, ERD, Architecture, Sequence Diagram 리포트 - **구현 완료**

## 실제 개발 플로우 검증

현재 SourceAnalyzer는 다음과 같은 플로우로 동작합니다:

```
1. 파일 스캔 → files 테이블 등록 ✅ **구현 완료**
2. CSV 로드 → tables/columns 테이블 등록 → TABLE 컴포넌트 등록 ✅ **구현 완료**
3. XML 분석 + JOIN 관계 분석 (통합 처리, 메모리 최적화) → SQL_* 컴포넌트 등록 + JOIN 관계 등록 ✅ **구현 완료**
   - 한 번의 XML 읽기로 SQL 추출과 JOIN 분석을 동시 처리
   - ✅ **SQL Content DB에 gzip 압축 저장** (SqlContentProcessor 적용 완료)
   - ✅ **공통 SQL 조인 분석 모듈** 적용 (SqlJoinAnalyzer)
   - Explicit JOIN (ANSI SQL) 및 Implicit JOIN (Oracle 전통 구문) 모두 지원
   - 별칭 해석 및 별칭 생략 처리로 정확한 테이블 관계 추출
   - 쿼리에서 도출된 테이블이 기존 tables에 없을 수 있음 (정상 상황)
   - project_id, table_name으로 tables에서 조회 시:
     * table_owner가 'UNKNOWN'이 아닌 테이블을 우선 선택 (LIMIT 1)
     * table_owner가 'UNKNOWN'이 아닌 테이블이 없으면 'UNKNOWN' 테이블 선택
   - 기존 테이블이 없으면 inferred 테이블 생성:
     * table_owner='UNKNOWN', HASH_VALUE='INFERRED'로 tables에 등록
   - inferred 테이블의 table_id로 relationships 등록
4. Java 분석 + 관계 생성 + **SQL 추출** (메모리 최적화) → classes 테이블 등록 + METHOD 컴포넌트 등록 + **SQL_* 컴포넌트 등록** + 관계 등록 ✅ **구현 완료**
   - 한 번의 Java 읽기로 클래스/메서드 추출과 관계 분석을 동시 처리
   - ✅ **StringBuilder SQL 추출**: Java 코드에서 StringBuilder 패턴으로 작성된 SQL 자동 추출
   - ✅ **SQL 압축 저장**: 추출된 SQL을 gzip 압축하여 SqlContent.db에 저장
   - ✅ **공통 SQL 조인 분석**: XML과 동일한 수준의 오라클 조인 분석 (EXPLICIT/IMPLICIT)
   - CALL_QUERY_M2S/CALL_METHOD_C2S/CALL_METHOD_S2D/USE_TABLE_S2D 관계를 relationships 테이블에 등록
   - inferred 컴포넌트 자동 생성 (기존에 없는 클래스/메서드/쿼리/테이블)
5. 백엔드 진입점 분석 → API_URL 컴포넌트 생성 + 백엔드 API 진입점 분석 ✅ **구현 완료**
   - Spring Framework (@Controller, @RequestMapping) 분석
   - Servlet 진입점 분석
   - components 테이블에 API_URL 컴포넌트 생성
   - relationships 테이블에 API → METHOD 관계 생성
6. 프론트엔드 통합 분석 → 범용 프론트엔드 지원 + frameworks 추적 ✅ **구현 완료**
   - JSP, JSX, Vue, TS, JS, HTML 통합 처리
   - jQuery, Axios, Fetch, XMLHttpRequest 지원
   - 프론트엔드 API와 백엔드 API 자동 매칭
   - files.frameworks 필드에 사용 기술 스택 저장
   - 완전한 호출 체인: 프론트엔드 파일 → API_URL → METHOD → SQL_* → TABLE
7. 일관성 검증 → 데이터 무결성 검증 및 품질 보장 ✅ **구현 완료**
   - 외래키 무결성 위반 검출
   - API_URL 중복 검출
   - parent_id 타입 불일치 검출
   - 치명적 문제 발견 시 프로그램 종료
```

### 시스템 특징

- **연관관계 중심**: 완전한 프론트엔드 → 백엔드 → 데이터베이스 연결고리 도출
- **안정적 파싱**: 정규식 기반으로 복잡도를 낮추고 안정성 확보
- **메모리 최적화**: 스트리밍 처리로 대용량 프로젝트 효율적 처리
- **범용 프론트엔드**: JSP, JSX, Vue, TS, JS, HTML 통합 지원
- **Frameworks 추적**: jQuery, Axios, Fetch, XHR 등 기술 스택 자동 수집
- **중앙 관계 관리**: RelationshipBuilder를 통한 통합 연관관계 구축
- **데이터 품질 보장**: 일관성 검증을 통한 메타데이터베이스 신뢰성 확보

---

## 📚 관련 문서

- **[요구사항정의서.md](./요구사항정의서.md)**: 비즈니스 요구사항 및 기능 명세
- **[메타데이터베이스스키마정의서.md](./메타데이터베이스스키마정의서.md)**: 데이터베이스 스키마 구조 상세
- **[create_table_script.sql](../database/create_table_script.sql)**: 스키마 정의 원본 파일
- **[처리플로우_상세_1단계_파일정보저장.md](./처리플로우_상세_1단계_파일정보저장.md)**: 1단계 파일 정보 저장 상세 구현 가이드
- **[처리플로우_상세_2단계_데이터베이스구조저장.md](./처리플로우_상세_2단계_데이터베이스구조저장.md)**: 2단계 데이터베이스 구조 저장 상세 구현 가이드
- **[처리플로우_상세_3단계_XML분석및SQL컴포넌트등록.md](./처리플로우_상세_3단계_XML분석및SQL컴포넌트등록.md)**: 3단계 XML 파일 분석 및 SQL 컴포넌트 등록 상세 구현 가이드
- **[처리플로우_상세_4단계_Java소스코드분석및관계생성.md](./처리플로우_상세_4단계_Java소스코드분석및관계생성.md)**: 4단계 Java 소스코드 분석 및 관계 생성 상세 구현 가이드
- **[처리플로우_상세_5단계_API진입점분석.md](./처리플로우_상세_5단계_API진입점분석.md)**: 5단계 API 진입점 분석 상세 구현 가이드
- **[처리플로우_상세_6단계_JSP파일분석.md](./처리플로우_상세_6단계_JSP파일분석.md)**: 6단계 JSP 파일 분석 상세 구현 가이드
- **[처리플로우_상세_7단계_QwenCoder7B보완분석.md](./처리플로우_상세_7단계_QwenCoder7B보완분석.md)**: 7단계 Qwen Coder 7B 보완 분석 상세 구현 가이드
- **[DOM_vs_SAX_비교분석.md](./DOM_vs_SAX_비교분석.md)**: DOM과 SAX 파서 비교 및 SAX Fallback 구조 분석
