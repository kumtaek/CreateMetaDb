# 4단계 개발계획서 - 클래스/메서드 추출 로직

## 문서 정보
- **작성일**: 2025-01-13 23:52:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서
- **대상 단계**: 4단계 - 클래스/메서드 추출 로직

## 1. 클래스 정보 추출 로직

### 1.1 클래스 추출 패턴

#### 1.1.1 지원하는 클래스 타입
```java
// 일반 클래스
public class UserService {
    // 클래스 내용
}

// 인터페이스
public interface UserServiceInterface {
    // 인터페이스 내용
}

// 열거형
public enum UserStatus {
    ACTIVE, INACTIVE, PENDING
}

// 어노테이션
public @interface UserValidation {
    // 어노테이션 내용
}
```

#### 1.1.2 정규식 패턴 (java_keyword.yaml 기반)
```yaml
java_class_extraction_patterns:
  - "public\\s+class\\s+(\\w+)(?:\\s+extends\\s+(\\w+))?(?:\\s+implements\\s+([\\w,\\s]+))?"
  - "class\\s+(\\w+)(?:\\s+extends\\s+(\\w+))?(?:\\s+implements\\s+([\\w,\\s]+))?"
  - "public\\s+interface\\s+(\\w+)(?:\\s+extends\\s+([\\w,\\s]+))?"
  - "interface\\s+(\\w+)(?:\\s+extends\\s+([\\w,\\s]+))?"
  - "public\\s+enum\\s+(\\w+)(?:\\s+implements\\s+([\\w,\\s]+))?"
  - "enum\\s+(\\w+)(?:\\s+implements\\s+([\\w,\\s]+))?"
  - "public\\s+@interface\\s+(\\w+)"
  - "@interface\\s+(\\w+)"
```

### 1.2 클래스 정보 추출 구현

```python
def _extract_class_info(self, java_content: str, file_path: str) -> List[Dict[str, Any]]:
    """
    Java 파일에서 클래스 정보 추출
    
    Args:
        java_content: Java 파일 내용
        file_path: 파일 경로
        
    Returns:
        클래스 정보 리스트
    """
    try:
        classes = []
        
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        class_patterns = self.config.get('java_class_extraction_patterns', [])
        
        for pattern in class_patterns:
            matches = re.finditer(pattern, java_content, re.MULTILINE)
            for match in matches:
                class_info = self._parse_class_match(match, java_content, file_path)
                if class_info:
                    classes.append(class_info)
        
        return classes
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"클래스 정보 추출 실패: {str(e)}")
        return []

def _parse_class_match(self, match: re.Match, java_content: str, file_path: str) -> Optional[Dict[str, Any]]:
    """
    클래스 매치 결과를 파싱하여 클래스 정보 생성
    
    Args:
        match: 정규식 매치 결과
        java_content: Java 파일 내용
        file_path: 파일 경로
        
    Returns:
        클래스 정보 딕셔너리
    """
    try:
        # 클래스명 추출
        class_name = match.group(1)
        
        # 클래스 타입 결정
        class_type = self._determine_class_type(match.group(0))
        
        # 패키지명 추출 (파일 경로에서)
        package_name = self._extract_package_name(file_path)
        
        # 라인 번호 추출
        line_start = java_content[:match.start()].count('\n') + 1
        line_end = self._find_class_end_line(java_content, match.start())
        
        # 상속 정보 추출
        parent_class_name = None
        interfaces = []
        
        if len(match.groups()) > 1 and match.group(2):
            if class_type in ['class', 'enum']:
                parent_class_name = match.group(2)
            elif class_type == 'interface':
                # 인터페이스 상속은 메타DB에 표현하지 않음
                pass
        
        if len(match.groups()) > 2 and match.group(3):
            # implements 절 파싱
            implements_clause = match.group(3)
            interfaces = [iface.strip() for iface in implements_clause.split(',')]
        
        # 클래스 내용 추출 및 해시 생성
        class_content = self._extract_class_content(java_content, match.start(), line_end)
        hash_value = HashUtils().generate_md5(class_content)
        
        return {
            'class_name': class_name,
            'class_type': class_type,
            'package_name': package_name,
            'line_start': line_start,
            'line_end': line_end,
            'parent_class_name': parent_class_name,
            'interfaces': interfaces,
            'hash_value': hash_value
        }
        
    except Exception as e:
        warning(f"클래스 매치 파싱 실패: {str(e)}")
        return None

def _determine_class_type(self, class_declaration: str) -> str:
    """
    클래스 선언문에서 클래스 타입 결정
    
    Args:
        class_declaration: 클래스 선언문
        
    Returns:
        클래스 타입 ('class', 'interface', 'enum', 'annotation')
    """
    if '@interface' in class_declaration:
        return 'annotation'
    elif 'enum' in class_declaration:
        return 'enum'
    elif 'interface' in class_declaration:
        return 'interface'
    else:
        return 'class'

def _extract_package_name(self, file_path: str) -> str:
    """
    파일 경로에서 패키지명 추출
    
    Args:
        file_path: 파일 경로
        
    Returns:
        패키지명
    """
    try:
        # 파일 경로를 패키지 경로로 변환
        # 예: /src/main/java/com/example/service/UserService.java
        # -> com.example.service
        
        # src/main/java 또는 src 경로 찾기
        path_parts = file_path.replace('\\', '/').split('/')
        
        java_index = -1
        for i, part in enumerate(path_parts):
            if part == 'java':
                java_index = i
                break
            elif part == 'src' and i + 1 < len(path_parts) and path_parts[i + 1] == 'main':
                java_index = i + 2
                break
        
        if java_index >= 0 and java_index + 1 < len(path_parts):
            # java 폴더 다음부터 .java 파일 전까지가 패키지 경로
            package_parts = path_parts[java_index + 1:-1]  # .java 파일 제외
            return '.'.join(package_parts)
        
        return 'default'
        
    except Exception as e:
        warning(f"패키지명 추출 실패: {str(e)}")
        return 'default'

def _find_class_end_line(self, java_content: str, class_start_pos: int) -> int:
    """
    클래스의 종료 라인 번호 찾기
    
    Args:
        java_content: Java 파일 내용
        class_start_pos: 클래스 시작 위치
        
    Returns:
        클래스 종료 라인 번호
    """
    try:
        # 중괄호 매칭을 통한 클래스 종료 위치 찾기
        brace_count = 0
        in_string = False
        escape_next = False
        
        for i in range(class_start_pos, len(java_content)):
            char = java_content[i]
            
            if escape_next:
                escape_next = False
                continue
            
            if char == '\\':
                escape_next = True
                continue
            
            if char in ['"', "'"]:
                in_string = not in_string
                continue
            
            if not in_string:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        # 클래스 종료 위치 찾음
                        return java_content[:i].count('\n') + 1
        
        # 클래스 종료를 찾지 못한 경우 파일 끝
        return java_content.count('\n') + 1
        
    except Exception as e:
        warning(f"클래스 종료 라인 찾기 실패: {str(e)}")
        return java_content.count('\n') + 1

def _extract_class_content(self, java_content: str, start_pos: int, end_line: int) -> str:
    """
    클래스 내용 추출 (해시 생성용)
    
    Args:
        java_content: Java 파일 내용
        start_pos: 클래스 시작 위치
        end_line: 클래스 종료 라인
        
    Returns:
        클래스 내용
    """
    try:
        lines = java_content.split('\n')
        start_line = java_content[:start_pos].count('\n') + 1
        
        if start_line <= len(lines) and end_line <= len(lines):
            class_lines = lines[start_line - 1:end_line]
            return '\n'.join(class_lines)
        
        return java_content[start_pos:]
        
    except Exception as e:
        warning(f"클래스 내용 추출 실패: {str(e)}")
        return ""
```

## 2. 메서드 정보 추출 로직

### 2.1 메서드 필터링 전략

#### 2.1.1 제외 대상 메서드
```java
// 기본 Object 메서드
public String toString() { ... }
public boolean equals(Object obj) { ... }
public int hashCode() { ... }
public Class<?> getClass() { ... }

// 기본 getter/setter
public String getName() { ... }
public void setName(String name) { ... }
public boolean isActive() { ... }

// 생성자
public UserService() { ... }

// main 메서드
public static void main(String[] args) { ... }

// 로깅 메서드
public void logInfo(String message) { ... }
public void printDebug(String message) { ... }
```

#### 2.1.2 포함 대상 메서드 (비즈니스 로직)
```java
// CRUD 생성
public User createUser(UserDto userDto) { ... }
public void insertUser(User user) { ... }
public void addUser(User user) { ... }

// CRUD 조회
public User findUserById(Long id) { ... }
public List<User> getUserList() { ... }
public User searchUser(String name) { ... }

// CRUD 수정
public void updateUser(User user) { ... }
public void modifyUser(User user) { ... }

// CRUD 삭제
public void deleteUser(Long id) { ... }
public void removeUser(Long id) { ... }

// 비즈니스 처리
public void processUser(User user) { ... }
public void handleUserRequest(UserRequest request) { ... }

// 검증
public boolean validateUser(User user) { ... }
public void checkUserPermission(User user) { ... }
```

### 2.2 메서드 추출 구현

```python
def _extract_method_info(self, java_content: str, file_path: str) -> List[Dict[str, Any]]:
    """
    Java 파일에서 메서드 정보 추출
    
    Args:
        java_content: Java 파일 내용
        file_path: 파일 경로
        
    Returns:
        메서드 정보 리스트
    """
    try:
        methods = []
        
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        method_patterns = self.config.get('method_filter_patterns', {})
        exclude_patterns = method_patterns.get('exclude_patterns', [])
        include_patterns = method_patterns.get('include_patterns', [])
        
        # 메서드 정의 패턴 (기본)
        method_definition_pattern = r'(?:public|private|protected)?\s*(?:static\s+)?(?:final\s+)?(?:synchronized\s+)?(?:abstract\s+)?(?:native\s+)?(?:strictfp\s+)?(?:\w+(?:<[^>]*>)?\s+)*(\w+)\s*\([^)]*\)\s*(?:throws\s+[^{]+)?\s*\{'
        
        matches = re.finditer(method_definition_pattern, java_content, re.MULTILINE)
        
        for match in matches:
            method_name = match.group(1)
            
            # 메서드 필터링
            if self._should_exclude_method(method_name, exclude_patterns):
                continue
            
            if not self._should_include_method(method_name, include_patterns):
                continue
            
            # 클래스명 추출 (메서드가 속한 클래스)
            class_name = self._find_class_for_method(java_content, match.start())
            if not class_name:
                continue
            
            # 메서드 정보 생성
            method_info = self._create_method_info(match, java_content, file_path, class_name)
            if method_info:
                methods.append(method_info)
        
        return methods
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"메서드 정보 추출 실패: {str(e)}")
        return []

def _should_exclude_method(self, method_name: str, exclude_patterns: List[str]) -> bool:
    """
    메서드 제외 여부 확인
    
    Args:
        method_name: 메서드명
        exclude_patterns: 제외 패턴 리스트
        
    Returns:
        제외 여부
    """
    try:
        for pattern in exclude_patterns:
            if re.match(pattern, method_name, re.IGNORECASE):
                return True
        return False
    except Exception as e:
        warning(f"메서드 제외 패턴 확인 실패: {str(e)}")
        return False

def _should_include_method(self, method_name: str, include_patterns: List[str]) -> bool:
    """
    메서드 포함 여부 확인
    
    Args:
        method_name: 메서드명
        include_patterns: 포함 패턴 리스트
        
    Returns:
        포함 여부
    """
    try:
        # 포함 패턴이 없으면 모든 메서드 포함
        if not include_patterns:
            return True
        
        for pattern in include_patterns:
            if re.match(pattern, method_name, re.IGNORECASE):
                return True
        return False
    except Exception as e:
        warning(f"메서드 포함 패턴 확인 실패: {str(e)}")
        return True

def _find_class_for_method(self, java_content: str, method_pos: int) -> Optional[str]:
    """
    메서드가 속한 클래스명 찾기
    
    Args:
        java_content: Java 파일 내용
        method_pos: 메서드 위치
        
    Returns:
        클래스명
    """
    try:
        # 메서드 위치 이전의 내용에서 가장 가까운 클래스 찾기
        content_before_method = java_content[:method_pos]
        
        # 클래스 정의 패턴
        class_patterns = [
            r'public\s+class\s+(\w+)',
            r'class\s+(\w+)',
            r'public\s+interface\s+(\w+)',
            r'interface\s+(\w+)',
            r'public\s+enum\s+(\w+)',
            r'enum\s+(\w+)'
        ]
        
        last_class = None
        for pattern in class_patterns:
            matches = re.finditer(pattern, content_before_method, re.MULTILINE)
            for match in matches:
                last_class = match.group(1)
        
        return last_class
        
    except Exception as e:
        warning(f"메서드의 클래스 찾기 실패: {str(e)}")
        return None

def _create_method_info(self, match: re.Match, java_content: str, file_path: str, class_name: str) -> Optional[Dict[str, Any]]:
    """
    메서드 정보 생성
    
    Args:
        match: 메서드 매치 결과
        java_content: Java 파일 내용
        file_path: 파일 경로
        class_name: 클래스명
        
    Returns:
        메서드 정보 딕셔너리
    """
    try:
        method_name = match.group(1)
        
        # 라인 번호 추출
        line_start = java_content[:match.start()].count('\n') + 1
        line_end = self._find_method_end_line(java_content, match.start())
        
        # 메서드 내용 추출 및 해시 생성
        method_content = self._extract_method_content(java_content, match.start(), line_end)
        hash_value = HashUtils().generate_md5(method_content)
        
        return {
            'method_name': method_name,
            'class_name': class_name,
            'line_start': line_start,
            'line_end': line_end,
            'hash_value': hash_value,
            'file_path': file_path
        }
        
    except Exception as e:
        warning(f"메서드 정보 생성 실패: {str(e)}")
        return None

def _find_method_end_line(self, java_content: str, method_start_pos: int) -> int:
    """
    메서드의 종료 라인 번호 찾기
    
    Args:
        java_content: Java 파일 내용
        method_start_pos: 메서드 시작 위치
        
    Returns:
        메서드 종료 라인 번호
    """
    try:
        # 중괄호 매칭을 통한 메서드 종료 위치 찾기
        brace_count = 0
        in_string = False
        escape_next = False
        
        for i in range(method_start_pos, len(java_content)):
            char = java_content[i]
            
            if escape_next:
                escape_next = False
                continue
            
            if char == '\\':
                escape_next = True
                continue
            
            if char in ['"', "'"]:
                in_string = not in_string
                continue
            
            if not in_string:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        # 메서드 종료 위치 찾음
                        return java_content[:i].count('\n') + 1
        
        # 메서드 종료를 찾지 못한 경우 파일 끝
        return java_content.count('\n') + 1
        
    except Exception as e:
        warning(f"메서드 종료 라인 찾기 실패: {str(e)}")
        return java_content.count('\n') + 1

def _extract_method_content(self, java_content: str, start_pos: int, end_line: int) -> str:
    """
    메서드 내용 추출 (해시 생성용)
    
    Args:
        java_content: Java 파일 내용
        start_pos: 메서드 시작 위치
        end_line: 메서드 종료 라인
        
    Returns:
        메서드 내용
    """
    try:
        lines = java_content.split('\n')
        start_line = java_content[:start_pos].count('\n') + 1
        
        if start_line <= len(lines) and end_line <= len(lines):
            method_lines = lines[start_line - 1:end_line]
            return '\n'.join(method_lines)
        
        return java_content[start_pos:]
        
    except Exception as e:
        warning(f"메서드 내용 추출 실패: {str(e)}")
        return ""
```

## 3. 고급 메서드 필터링

### 3.1 복잡한 getter/setter 패턴

```python
def _is_complex_getter_setter(self, method_name: str) -> bool:
    """
    복잡한 getter/setter 패턴 확인
    
    Args:
        method_name: 메서드명
        
    Returns:
        복잡한 getter/setter 여부
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        complex_patterns = self.config.get('complex_getter_setter_patterns', [])
        
        for pattern in complex_patterns:
            if re.match(pattern, method_name, re.IGNORECASE):
                return True
        return False
    except Exception as e:
        warning(f"복잡한 getter/setter 패턴 확인 실패: {str(e)}")
        return False

# 복잡한 getter/setter 예시
# getUserWithDetails() - 포함 대상
# getUserByStatus() - 포함 대상
# setUserForRole() - 포함 대상
# getUserFromCache() - 포함 대상
```

### 3.2 비즈니스 도메인 분류

```python
def _classify_method_domain(self, method_name: str, class_name: str) -> str:
    """
    메서드의 비즈니스 도메인 분류
    
    Args:
        method_name: 메서드명
        class_name: 클래스명
        
    Returns:
        도메인 분류
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 도메인 분류 로드
        domain_classification = self.config.get('domain_classification', {})
        
        search_text = f"{method_name} {class_name}".lower()
        
        for domain, config in domain_classification.items():
            keywords = config.get('keywords', [])
            for keyword in keywords:
                if keyword.lower() in search_text:
                    return domain
        
        return 'general'
    except Exception as e:
        warning(f"메서드 도메인 분류 실패: {str(e)}")
        return 'general'
```

### 3.3 아키텍처 레이어 분류

```python
def _classify_method_layer(self, class_name: str) -> str:
    """
    메서드의 아키텍처 레이어 분류
    
    Args:
        class_name: 클래스명
        
    Returns:
        레이어 분류
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 레이어 분류 로드
        layer_classification = self.config.get('layer_classification', {})
        
        class_name_lower = class_name.lower()
        
        for layer, config in layer_classification.items():
            suffixes = config.get('suffixes', [])
            keywords = config.get('keywords', [])
            
            # 접미사 확인
            for suffix in suffixes:
                if class_name_lower.endswith(suffix.lower()):
                    return layer
            
            # 키워드 확인
            for keyword in keywords:
                if keyword.lower() in class_name_lower:
                    return layer
        
        return 'unknown'
    except Exception as e:
        warning(f"메서드 레이어 분류 실패: {str(e)}")
        return 'unknown'
```

## 4. 성능 최적화

### 4.1 정규식 컴파일 최적화

```python
class JavaParser:
    def __init__(self, config_path: str = None, project_name: str = None):
        # ... 기존 초기화 코드 ...
        
        # 정규식 패턴 미리 컴파일 (성능 최적화)
        self._compile_patterns()
    
    def _compile_patterns(self):
        """정규식 패턴 미리 컴파일"""
        try:
            # 클래스 추출 패턴 컴파일
            class_patterns = self.config.get('java_class_extraction_patterns', [])
            self.compiled_class_patterns = [re.compile(pattern, re.MULTILINE) for pattern in class_patterns]
            
            # 메서드 필터링 패턴 컴파일
            method_patterns = self.config.get('method_filter_patterns', {})
            exclude_patterns = method_patterns.get('exclude_patterns', [])
            include_patterns = method_patterns.get('include_patterns', [])
            
            self.compiled_exclude_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in exclude_patterns]
            self.compiled_include_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in include_patterns]
            
            # 메서드 정의 패턴 컴파일
            self.method_definition_pattern = re.compile(
                r'(?:public|private|protected)?\s*(?:static\s+)?(?:final\s+)?(?:synchronized\s+)?(?:abstract\s+)?(?:native\s+)?(?:strictfp\s+)?(?:\w+(?:<[^>]*>)?\s+)*(\w+)\s*\([^)]*\)\s*(?:throws\s+[^{]+)?\s*\{',
                re.MULTILINE
            )
            
        except Exception as e:
            warning(f"정규식 패턴 컴파일 실패: {str(e)}")
            self.compiled_class_patterns = []
            self.compiled_exclude_patterns = []
            self.compiled_include_patterns = []
            self.method_definition_pattern = None
```

### 4.2 메모리 효율적인 처리

```python
def _extract_class_info(self, java_content: str, file_path: str) -> List[Dict[str, Any]]:
    """
    메모리 효율적인 클래스 정보 추출
    """
    try:
        classes = []
        
        # 컴파일된 패턴 사용
        for compiled_pattern in self.compiled_class_patterns:
            matches = compiled_pattern.finditer(java_content)
            for match in matches:
                class_info = self._parse_class_match(match, java_content, file_path)
                if class_info:
                    classes.append(class_info)
                    
                    # 메모리 최적화: 대용량 파일의 경우 배치 처리
                    if len(classes) >= 100:  # 배치 크기
                        yield classes
                        classes = []
        
        # 남은 클래스들 반환
        if classes:
            yield classes
            
    except Exception as e:
        warning(f"클래스 정보 추출 실패: {str(e)}")
        return []
```

## 5. 다음 단계

다음 문서에서는 상속 관계 분석 로직을 제시합니다:
- [4. 상속 관계 분석 로직](./20250113_235300_4단계개발계획서_상속관계분석.md)
