# 4단계 개발계획서 - 개요 및 현황 분석

## 문서 정보
- **작성일**: 2025-01-13 23:50:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서
- **대상 단계**: 4단계 - Java 소스코드 분석 및 컴포넌트 등록

## 1. 개요

### 1.1 4단계 목적
Java 파일에서 CLASS, METHOD 추출하여 각각의 테이블에 등록하고 상속 관계 분석을 수행합니다.

### 1.2 핵심 기능
- Java 파일 파싱 및 클래스 정보 추출
- 메서드 정보 추출 및 비즈니스 로직 필터링
- 상속 관계 분석 (extends 키워드)
- 메모리 최적화를 통한 스트리밍 처리
- 컴포넌트 등록 및 관계 저장

### 1.3 실행 함수
- `JavaLoadingEngine.execute_java_loading()`
- `JavaParser.parse_java_file()`

### 1.4 구현 상태
🔄 **개발 예정** (현재 미구현)

## 2. 현재 개발 현황 분석

### 2.1 3단계 소스 현황 (xml_loading.py, xml_parser.py)

#### 2.1.1 구현 완료된 기능
- ✅ XML 파일 수집 및 필터링
- ✅ MyBatis XML 파싱 (DOM + 정규식 Fallback)
- ✅ SQL 쿼리 추출 및 정제
- ✅ JOIN 관계 분석 (Explicit/Implicit)
- ✅ inferred 테이블/컬럼 생성
- ✅ 메모리 최적화 (스트리밍 처리)

#### 2.1.2 미완성/문제점
- ❌ `_save_sql_components_to_database()` 메서드 미완성 (207-211라인)
- ❌ SQL Content Processor 보류 상태 (주석 처리됨)
- ❌ DOM 파싱과 정규식 파싱 혼재로 복잡성 증가
- ❌ 일부 메서드에서 하드코딩된 경로 사용

### 2.2 4단계 개발 필요사항

#### 2.2.1 새로운 파일 구조
```
CreateMetaDb/
├── java_loading.py          # 4단계 메인 엔진 (새로 생성)
├── parser/
│   ├── java_parser.py       # Java 파싱 로직 (새로 생성)
│   └── xml_parser.py        # 3단계 (기존 유지)
```

#### 2.2.2 3단계와의 독립성
- **배타적 개발**: 3단계 소스에 영향 없이 별도 파일로 개발
- **공통 함수 활용**: util 모듈의 공통 함수들 재사용
- **설정 파일 분리**: `config/parser/java_keyword.yaml` 활용

## 3. 기술적 요구사항

### 3.1 User Rules 준수사항
- **하드코딩 금지**: `config/parser/java_keyword.yaml` 설정 파일 사용
- **공통함수 사용**: `DatabaseUtils`, `FileUtils`, `HashUtils`, `PathUtils` 등 util 모듈 활용
- **예외 처리**: 
  - 파싱 에러: `has_error='Y'`, `error_message` 저장 후 계속 진행
  - 시스템 에러: `handle_error()` 공통함수로 exit
- **프로젝트 해시값**: 하드코딩된 '-' 사용
- **메뉴얼 기반**: `parser/manual/01_java` 참고

### 3.2 메모리 최적화 요구사항
- **스트리밍 처리**: 한 파일씩만 메모리에 로드하여 처리
- **즉시 해제**: 파일 처리 완료 후 `del java_content`로 메모리에서 즉시 해제
- **배치 저장**: `batch_insert_or_replace()`로 대량 데이터 효율적 저장

### 3.3 데이터베이스 스키마 활용
- **classes 테이블**: Java 클래스 정보 저장
- **components 테이블**: Java 메서드 컴포넌트 저장
- **상속 관계**: classes 테이블의 `parent_class_id` 컬럼으로 셀프조인 표현

## 4. 개발 전략

### 4.1 점진적 개발 접근법
1. **1단계**: 기본 Java 파싱 로직 구현
2. **2단계**: 클래스/메서드 추출 로직 구현
3. **3단계**: 상속 관계 분석 로직 구현
4. **4단계**: 메모리 최적화 및 성능 튜닝
5. **5단계**: 오류 처리 및 예외 상황 대응

### 4.2 3단계 소스 재사용 전략
- **공통 함수**: util 모듈의 공통 함수들 재사용
- **설정 파일**: 기존 설정 파일 구조 활용
- **데이터베이스**: 기존 데이터베이스 스키마 활용
- **로깅**: 기존 로깅 시스템 활용

### 4.3 독립성 보장 전략
- **별도 파일**: `java_loading.py`, `parser/java_parser.py`로 완전 분리
- **네임스페이스**: 독립적인 클래스명과 메서드명 사용
- **의존성**: 3단계 소스에 대한 의존성 최소화

## 5. 예상 개발 일정

### 5.1 1주차: 기본 구조 및 파싱 로직
- Java 파서 기본 구조 설계
- Java 파일 수집 및 필터링
- 기본 클래스/메서드 추출 로직

### 5.2 2주차: 고급 분석 로직
- 상속 관계 분석 로직
- 메서드 필터링 및 비즈니스 로직 식별
- 데이터베이스 저장 로직

### 5.3 3주차: 최적화 및 안정화
- 메모리 최적화 구현
- 오류 처리 및 예외 상황 대응
- 성능 테스트 및 튜닝

### 5.4 4주차: 통합 테스트 및 문서화
- 전체 시스템 통합 테스트
- 문서화 및 사용자 가이드 작성
- 최종 검증 및 배포 준비

## 6. 성공 기준

### 6.1 기능적 요구사항
- ✅ Java 파일에서 클래스 정보 추출
- ✅ Java 파일에서 메서드 정보 추출
- ✅ 상속 관계 분석 및 저장
- ✅ 메모리 효율적 처리
- ✅ 오류 상황 적절한 처리

### 6.2 비기능적 요구사항
- ✅ 3단계 소스와의 독립성 보장
- ✅ User Rules 완전 준수
- ✅ 설정 파일 기반 동작
- ✅ 공통 함수 활용
- ✅ 상세한 로깅 및 통계

## 7. 위험 요소 및 대응 방안

### 7.1 기술적 위험
- **위험**: Java 파싱 복잡성
- **대응**: 정규식 기반 단순한 파싱으로 시작, 점진적 고도화

### 7.2 성능 위험
- **위험**: 대용량 Java 파일 처리 시 메모리 부족
- **대응**: 스트리밍 처리 및 즉시 해제 전략

### 7.3 호환성 위험
- **위험**: 3단계 소스와의 충돌
- **대응**: 완전 분리된 파일 구조 및 독립적인 네임스페이스

## 8. 다음 단계

다음 문서에서는 구체적인 설계 및 구현 방안을 제시합니다:
- [2. Java 파서 설계 및 구현 방안](./20250113_235100_4단계개발계획서_Java파서설계.md)
- [3. 클래스/메서드 추출 로직](./20250113_235200_4단계개발계획서_클래스메서드추출.md)
- [4. 상속 관계 분석 로직](./20250113_235300_4단계개발계획서_상속관계분석.md)
- [5. 메모리 최적화 전략](./20250113_235400_4단계개발계획서_메모리최적화.md)
- [6. 오류 처리 및 예외 상황](./20250113_235500_4단계개발계획서_오류처리.md)
