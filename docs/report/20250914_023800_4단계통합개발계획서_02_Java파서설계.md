# 4~5단계 통합 개발계획서 - Java 파서 설계

## 문서 정보
- **작성일**: 2025-09-14 02:38:00
- **작성자**: AI Assistant
- **문서 유형**: 통합 개발계획서
- **대상 단계**: 4~5단계 통합 - Java 파서 설계

## 1. Java 파서 아키텍처 설계

### 1.1 전체 아키텍처

```
JavaLoadingEngine (java_loading.py) - 4~5단계 통합 메인 엔진
├── JavaParser (parser/java_parser.py) - 통합 파싱 로직
│   ├── 클래스 정보 추출
│   ├── 메서드 정보 추출
│   ├── 상속 관계 분석
│   ├── CALL_QUERY 관계 분석 (통합)
│   ├── CALL_METHOD 관계 분석 (통합)
│   └── USE_TABLE 관계 분석 (통합)
├── DatabaseUtils (util/database_utils.py)
├── FileUtils (util/file_utils.py)
└── ConfigUtils (util/config_utils.py)
```

### 1.2 파일 구조

```
CreateMetaDb/
├── java_loading.py              # 4~5단계 통합 메인 엔진
├── parser/
│   ├── java_parser.py           # Java 통합 파싱 로직
│   └── xml_parser.py            # 3단계 (기존 유지)
├── config/parser/
│   └── java_keyword.yaml        # Java 파싱 설정
└── util/                        # 공통 유틸리티 (기존)
```

## 2. JavaLoadingEngine 설계

### 2.1 클래스 구조

```python
class JavaLoadingEngine:
    """Java 로딩 엔진 - 4~5단계 통합 처리"""
    
    def __init__(self, project_name: str):
        """Java 로딩 엔진 초기화"""
        
    def execute_java_loading(self) -> bool:
        """4~5단계 통합 처리 실행"""
        
    def _save_classes_to_database(self, classes: List[Dict[str, Any]]) -> bool:
        """클래스 정보를 classes 테이블에 저장"""
        
    def _save_method_components_to_database(self, methods: List[Dict[str, Any]]) -> bool:
        """메서드 정보를 components 테이블에 저장"""
        
    def _save_relationships_to_database(self, relationships: List[Dict[str, Any]]) -> bool:
        """관계 정보를 relationships 테이블에 저장 (통합)"""
```

### 2.2 초기화 과정

```python
def __init__(self, project_name: str):
    """
    Java 로딩 엔진 초기화
    
    Args:
        project_name: 프로젝트명
    """
    self.project_name = project_name
    
    # USER RULES: 공통함수 사용 - 하드코딩 지양
    from util.path_utils import get_project_source_path, get_project_metadata_db_path
    self.project_source_path = get_project_source_path(project_name)
    self.metadata_db_path = get_project_metadata_db_path(project_name)
    self.db_utils = None
    
    # Java 파서 초기화 (USER RULES: 공통함수 사용, 전역 프로젝트 정보 활용)
    self.java_parser = JavaParser()
    
    # 통계 정보
    self.stats = {
        'java_files_processed': 0,
        'classes_extracted': 0,
        'methods_extracted': 0,
        'method_components_created': 0,
        'inheritance_relationships_created': 0,
        'call_query_relationships_created': 0,
        'call_method_relationships_created': 0,
        'use_table_relationships_created': 0,
        'errors': 0
    }
```

### 2.3 메인 실행 로직 (통합 처리)

```python
def execute_java_loading(self) -> bool:
    """
    Java 로딩 실행: 4~5단계 통합 처리
    
    Returns:
        실행 성공 여부
    """
    try:
        info("=== Java 로딩 시작: 4~5단계 통합 처리 ===")
        
        # 데이터베이스 연결 (USER RULES: 공통함수 사용)
        from util.database_utils import DatabaseUtils
        self.db_utils = DatabaseUtils(self.metadata_db_path)
        if not self.db_utils.connect():
            error("메타데이터베이스 연결 실패")
            return False
        
        # 1. Java 파일 수집
        java_files = self.java_parser.get_filtered_java_files(self.project_source_path)
        if not java_files:
            warning("Java 파일이 없습니다")
            return True
        
        info(f"Java 파일 수집 완료: {len(java_files)}개")
        
        # 2. Java 파일별 통합 처리 (메모리 최적화)
        for java_file in java_files:
            try:
                # 4~5단계 통합 처리: 클래스/메서드 추출 + 관계 분석
                analysis_result = self.java_parser.parse_java_file(java_file)
                
                # 파싱 에러 체크 (USER RULES: 파싱 에러는 계속 진행)
                if analysis_result.get('has_error') == 'Y':
                    warning(f"Java 파싱 에러로 건너뜀: {java_file} - {analysis_result.get('error_message', '')}")
                    self.stats['errors'] += 1
                    continue
                
                # 클래스 정보 저장
                if analysis_result['classes']:
                    try:
                        if self._save_classes_to_database(analysis_result['classes']):
                            self.stats['classes_extracted'] += len(analysis_result['classes'])
                    except Exception as e:
                        # USER RULES: Exception 발생시 handle_error()로 exit()
                        from util.logger import handle_error
                        handle_error(e, f"클래스 정보 저장 실패: {java_file}")
                        return False
                
                # 메서드 컴포넌트 저장
                if analysis_result['methods']:
                    try:
                        if self._save_method_components_to_database(analysis_result['methods']):
                            self.stats['method_components_created'] += len(analysis_result['methods'])
                    except Exception as e:
                        # USER RULES: Exception 발생시 handle_error()로 exit()
                        from util.logger import handle_error
                        handle_error(e, f"메서드 컴포넌트 저장 실패: {java_file}")
                        return False
                
                # 관계 정보 저장 (통합)
                if analysis_result['relationships']:
                    try:
                        if self._save_relationships_to_database(analysis_result['relationships']):
                            self._update_relationship_stats(analysis_result['relationships'])
                    except Exception as e:
                        # USER RULES: Exception 발생시 handle_error()로 exit()
                        from util.logger import handle_error
                        handle_error(e, f"관계 정보 저장 실패: {java_file}")
                        return False
                
                self.stats['java_files_processed'] += 1
                self.stats['methods_extracted'] += len(analysis_result['methods'])
                
                # 메모리 최적화: 처리 후 즉시 해제
                del analysis_result
                
            except Exception as e:
                # 시스템 에러 (데이터베이스, 메모리 등) - 프로그램 종료
                from util.logger import handle_error
                handle_error(e, f"Java 파일 처리 실패: {java_file}")
                return False
        
        # 3. 통계 정보 출력
        self._print_java_loading_statistics()
        
        info("=== Java 로딩 완료 ===")
        return True
        
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, "Java 로딩 실행 실패")
        return False
    finally:
        # 데이터베이스 연결 해제
        if self.db_utils:
            self.db_utils.disconnect()

def _update_relationship_stats(self, relationships: List[Dict[str, Any]]):
    """관계 통계 업데이트"""
    for rel in relationships:
        rel_type = rel.get('rel_type')
        if rel_type == 'INHERITANCE':
            self.stats['inheritance_relationships_created'] += 1
        elif rel_type == 'CALL_QUERY':
            self.stats['call_query_relationships_created'] += 1
        elif rel_type == 'CALL_METHOD':
            self.stats['call_method_relationships_created'] += 1
        elif rel_type == 'USE_TABLE':
            self.stats['use_table_relationships_created'] += 1
```

## 3. JavaParser 설계 (통합)

### 3.1 클래스 구조

```python
class JavaParser:
    """Java 파서 - 4~5단계 통합 처리"""
    
    def __init__(self, config_path: str = None, project_name: str = None):
        """Java 파서 초기화"""
        
    def get_filtered_java_files(self, project_path: str = None) -> List[str]:
        """Java 파일 수집 및 필터링"""
        
    def parse_java_file(self, java_file: str) -> Dict[str, Any]:
        """Java 파일에서 모든 정보 추출 및 관계 분석 (통합)"""
        
    def _extract_class_info(self, java_content: str, file_path: str) -> List[Dict[str, Any]]:
        """Java 파일에서 클래스 정보 추출"""
        
    def _extract_method_info(self, java_content: str, file_path: str) -> List[Dict[str, Any]]:
        """Java 파일에서 메서드 정보 추출"""
        
    def _analyze_inheritance_relationships(self, java_content: str) -> List[Dict[str, Any]]:
        """Java 파일에서 상속 관계 분석"""
        
    def _analyze_call_query_relationships(self, java_content: str, methods: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Java 파일에서 CALL_QUERY 관계 분석 (통합)"""
        
    def _analyze_call_method_relationships(self, java_content: str, methods: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Java 파일에서 CALL_METHOD 관계 분석 (통합)"""
        
    def _analyze_use_table_relationships(self, java_content: str, methods: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Java 파일에서 USE_TABLE 관계 분석 (통합)"""
```

### 3.2 초기화 과정

```python
def __init__(self, config_path: str = None, project_name: str = None):
    """
    Java 파서 초기화
    
    Args:
        config_path: 설정 파일 경로
        project_name: 프로젝트명 (선택적, 전역에서 가져옴)
    """
    # USER RULES: 하드코딩 지양 - 프로젝트 정보 전역 관리
    from util.global_project import get_global_project_name, get_global_project_id, is_global_project_info_set
    
    # 전역 프로젝트 정보 활용 (실행 중 변경되지 않는 값)
    if is_global_project_info_set():
        self.project_name = get_global_project_name()
        self.project_id = get_global_project_id()
    else:
        # 개별 설정이 있는 경우 (테스트 등)
        self.project_name = project_name
        self.project_id = None
    
    if config_path is None:
        # USER RULES: 하드코딩 지양 - 설정 파일 경로
        java_config_path = "config/parser/java_keyword.yaml"
        self.config = self._load_config(java_config_path)
    else:
        self.config_path = config_path
        self.config = self._load_config()
    
    self.stats = {
        'files_processed': 0,
        'files_skipped': 0,
        'classes_extracted': 0,
        'methods_extracted': 0,
        'inheritance_relationships_created': 0,
        'call_query_relationships_created': 0,
        'call_method_relationships_created': 0,
        'use_table_relationships_created': 0,
        'errors': 0
    }
```

### 3.3 Java 파일 수집

```python
def get_filtered_java_files(self, project_path: str = None) -> List[str]:
    """
    Java 파일 수집 및 필터링
    
    Args:
        project_path: 프로젝트 경로
        
    Returns:
        Java 파일 경로 리스트
    """
    try:
        # USER RULES: 공통함수 사용 지향
        from util.file_utils import FileUtils
        file_utils = FileUtils()
        
        # USER RULES: 하드코딩 지양 - PathUtils 공통함수 사용
        if project_path is None and self.project_name:
            from util.path_utils import PathUtils
            path_utils = PathUtils()
            project_path = path_utils.get_project_source_path(self.project_name)
        
        if not project_path:
            # USER RULES: Exception 발생시 handle_error()로 exit()
            from util.logger import handle_error
            handle_error(Exception("프로젝트 경로가 지정되지 않았습니다"), "Java 파일 수집 실패")
        
        java_files = []
        for root, dirs, files in os.walk(project_path):
            for file in files:
                if file.endswith('.java'):
                    file_path = os.path.join(root, file)
                    if self._is_valid_java_file(file_path):
                        java_files.append(file_path)
        
        info(f"Java 파일 수집 완료: {len(java_files)}개")
        return java_files
        
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, "Java 파일 수집 실패")
        return []

def _is_valid_java_file(self, file_path: str) -> bool:
    """
    유효한 Java 파일인지 확인
    
    Args:
        file_path: 파일 경로
        
    Returns:
        유효성 여부
    """
    try:
        from util.file_utils import FileUtils
        file_utils = FileUtils()
        content = file_utils.read_file(file_path)
        if not content:
            return False
        
        # 기본적인 Java 파일 검증
        java_indicators = ['class', 'interface', 'enum', 'package', 'import']
        content_lower = content.lower()
        return any(indicator in content_lower for indicator in java_indicators)
        
    except Exception as e:
        warning(f"Java 파일 확인 실패: {file_path}, 오류: {str(e)}")
        return False
```

### 3.4 통합 분석 메서드 (핵심)

```python
def parse_java_file(self, java_file: str) -> Dict[str, Any]:
    """
    Java 파일에서 모든 정보 추출 및 관계 분석 (통합)
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        분석 결과 딕셔너리
    """
    try:
        # 1. Java 파일 읽기
        from util.file_utils import FileUtils
        file_utils = FileUtils()
        java_content = file_utils.read_file(java_file)
        if not java_content:
            return {
                'classes': [],
                'methods': [],
                'relationships': [],
                'file_path': java_file,
                'has_error': 'Y',
                'error_message': 'Java 파일 읽기 실패'
            }
        
        # 2. 클래스 정보 추출
        classes = self._extract_class_info(java_content, java_file)
        
        # 3. 메서드 정보 추출
        methods = self._extract_method_info(java_content, java_file)
        
        # 4. 관계 분석 (통합 처리)
        relationships = []
        
        # 4-1. 상속 관계 분석
        inheritance_rels = self._analyze_inheritance_relationships(java_content)
        relationships.extend(inheritance_rels)
        
        # 4-2. CALL_QUERY 관계 분석 (통합)
        call_query_rels = self._analyze_call_query_relationships(java_content, methods)
        relationships.extend(call_query_rels)
        
        # 4-3. CALL_METHOD 관계 분석 (통합)
        call_method_rels = self._analyze_call_method_relationships(java_content, methods)
        relationships.extend(call_method_rels)
        
        # 4-4. USE_TABLE 관계 분석 (통합)
        use_table_rels = self._analyze_use_table_relationships(java_content, methods)
        relationships.extend(use_table_rels)
        
        # 5. 통계 업데이트
        self.stats['files_processed'] += 1
        self.stats['classes_extracted'] += len(classes)
        self.stats['methods_extracted'] += len(methods)
        self.stats['inheritance_relationships_created'] += len(inheritance_rels)
        self.stats['call_query_relationships_created'] += len(call_query_rels)
        self.stats['call_method_relationships_created'] += len(call_method_rels)
        self.stats['use_table_relationships_created'] += len(use_table_rels)
        
        return {
            'classes': classes,
            'methods': methods,
            'relationships': relationships,
            'file_path': java_file
        }
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        error_message = f"Java 파싱 중 예외 발생: {str(e)}"
        warning(f"{error_message} - {java_file}")
        self.stats['errors'] += 1
        return {
            'classes': [],
            'methods': [],
            'relationships': [],
            'file_path': java_file,
            'has_error': 'Y',
            'error_message': error_message
        }
```

## 4. 설정 파일 활용

### 4.1 java_keyword.yaml 활용

```python
def _load_config(self, config_path: str = None) -> Dict[str, Any]:
    """
    설정 파일 로드
    
    Args:
        config_path: 설정 파일 경로
        
    Returns:
        설정 딕셔너리
    """
    try:
        # USER RULES: 공통함수 사용 지향
        from util.config_utils import ConfigUtils
        config_utils = ConfigUtils()
        path = config_path or self.config_path
        config = config_utils.load_yaml_config(path)
        if not config:
            # USER RULES: Exception 발생시 handle_error()로 exit()
            from util.logger import handle_error
            handle_error(Exception(f"설정 파일을 로드할 수 없습니다: {path}"), "설정 파일 로드 실패")
            return self._get_default_config()
        return config
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, f"설정 파일 로드 실패: {config_path or self.config_path}")
        return self._get_default_config()

def _get_default_config(self) -> Dict[str, Any]:
    """기본 설정 반환"""
    return {
        'java_class_extraction_patterns': [
            r'public\s+class\s+(\w+)',
            r'class\s+(\w+)',
            r'public\s+interface\s+(\w+)',
            r'interface\s+(\w+)',
            r'public\s+enum\s+(\w+)',
            r'enum\s+(\w+)'
        ],
        'method_filter_patterns': {
            'exclude_patterns': [
                r'^<init>$',
                r'^<clinit>$',
                r'^toString$',
                r'^equals$',
                r'^hashCode$',
                r'^getClass$'
            ],
            'include_patterns': [
                r'^(create|insert|add|register).*',
                r'^(read|get|find|search|select|list).*',
                r'^(update|modify|edit|change).*',
                r'^(delete|remove|cancel).*'
            ]
        },
        'relationship_patterns': {
            'call_query_patterns': [
                r'sqlSession\.selectOne\s*\(',
                r'sqlSession\.selectList\s*\(',
                r'sqlSession\.insert\s*\(',
                r'sqlSession\.update\s*\(',
                r'sqlSession\.delete\s*\(',
                r'mapper\.\w+\s*\('
            ],
            'call_method_patterns': [
                r'this\.\w+\s*\(',
                r'\w+\.\w+\s*\('
            ],
            'use_table_patterns': [
                r'FROM\s+(\w+)',
                r'JOIN\s+(\w+)',
                r'UPDATE\s+(\w+)',
                r'INSERT\s+INTO\s+(\w+)',
                r'DELETE\s+FROM\s+(\w+)'
            ]
        }
    }
```

## 5. 다음 단계

다음 문서에서는 구체적인 클래스/메서드 추출 로직을 제시합니다:
- [3. 클래스/메서드 추출 로직](./20250914_023800_4~5단계통합개발계획서_03_클래스메서드추출로직.md)
