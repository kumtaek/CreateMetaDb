# 개발계획서 2차 검토 결과 (재검토): EXPLICIT JOIN 분석 로직 수정

**작성일**: 2025-09-13 16:30:00  
**검토 대상**: `20250913_162537_개발계획서_EXPLICIT_JOIN_분석_로직_수정_2차.md` (최종본)  
**참고 자료**: `메타데이터베이스정답지3.md`

---

## 1. 검토 개요

`EXPLICIT JOIN` 분석 정확도 85% 달성을 목표로 하는 2차 개발계획서를 재검토했습니다.

1차 계획서 대비 **정규식 패턴의 견고성**과 **ON 조건절 분석**이 상당히 개선되었습니다. 특히 별칭(Alias) 유무, `테이블.컬럼` 형태 파싱 등 세부적인 사항들이 반영된 점은 긍정적입니다.

하지만, `정답지`의 복잡한 JOIN 구문들과 비교했을 때, **JOIN 관계의 주체(Source)와 대상(Target)을 결정하는 핵심 로직에 여전히 심각한 한계**가 존재합니다. 현재 계획으로는 목표 정확도인 85% 달성이 어려울 것으로 판단됩니다.

---

## 2. 핵심 문제점: JOIN 관계의 시작점(Source) 부재

2차 계획서의 가장 큰 문제는 **모든 JOIN을 개별적으로만 처리**하려 한다는 점입니다. 이로 인해 SQL 구문 전체의 문맥을 놓치고, JOIN 관계의 정확한 시작점을 파악하지 못합니다.

### 2.1. `FROM` 절의 기본 테이블을 무시하는 로직

- **문제 상황**: `SELECT * FROM A LEFT JOIN B ON A.id = B.id` 라는 구문이 있을 때, 2차 계획서의 로직은 `LEFT JOIN` 패턴에만 집중합니다. 정규식은 `B` 테이블과 `ON` 조건절(`A.id = B.id`)을 찾을 뿐, 이 관계의 명백한 시작점인 `FROM` 절의 `A` 테이블은 분석 대상에 포함하지 않습니다.

- **분석 로직의 한계**:
  - `_analyze_explicit_joins_for_table` 함수는 `ON` 절에 명시된 테이블(`A`, `B`)을 `source_table`과 `target_table`로 지정합니다.
  - 하지만 `A JOIN B JOIN C` 와 같이 여러 테이블이 체인 형태로 연결될 때, `B JOIN C`를 분석하는 시점에서는 `A`와의 관계를 잊어버리게 됩니다. 즉, **SQL 전체의 JOIN 연결 구조를 파악하지 못하고 단편적인 관계만 생성**하게 됩니다.

- **정답지와의 불일치**: `정답지`의 `ImplicitJoinTestMapper.xml`에 있는 `selectComplexQueryExample` 쿼리는 `users JOIN departments`, `users JOIN project_members`, `project_members JOIN projects` 와 같이 여러 테이블이 순차적으로 JOIN 됩니다. 현재 로직으로는 이 관계들을 독립적으로만 볼 뿐, `users` 테이블에서 시작되는 전체적인 연결 관계를 그려낼 수 없습니다.

### 2.2. `CROSS JOIN` 및 `NATURAL JOIN`의 불완전한 분석

- **문제**: 2차 계획서는 `CROSS JOIN`과 `NATURAL JOIN` 패턴을 추가했지만, 이 JOIN들은 `ON` 조건절이 없어 관계의 양쪽 당사자를 결정할 수 없습니다. 계획서의 로직은 `(테이블1, 별칭1)` 두 개의 정보만으로 관계를 생성하려 시도하는데, 이는 불완전합니다.
- **결과**: `A CROSS JOIN B`에서 `B`만 포착할 뿐, `A`와의 관계를 생성할 수 없습니다. `정답지`의 목표를 달성하려면 `FROM`절이나 바로 앞선 `JOIN`절의 테이블을 `source_table`로 가져와야 합니다.

---

## 3. 개선 제안 (재검토)

단편적인 패턴 매칭을 넘어, **SQL 구문을 하나의 문맥(Context)으로 이해하고 순차적으로 분석**하는 방식으로 로직을 근본적으로 변경해야 합니다.

### 3.1. SQL 분석 단계를 명확히 분리

하나의 거대한 정규식이 아닌, 각 절(Clause)을 분석하는 작은 함수들의 조합으로 로직을 구성해야 합니다.

1.  **`find_base_table_from_from_clause`**: `FROM` 절을 찾아 **기본 테이블**과 별칭을 추출합니다. 모든 JOIN 관계 분석의 시작점이 됩니다.
2.  **`find_all_join_clauses`**: `FROM` 절 이후의 모든 `JOIN` 구문(`LEFT JOIN ... ON ...`, `INNER JOIN ... ON ...` 등)을 순서대로 잘라내어 리스트로 만듭니다.
3.  **`parse_join_clause`**: 개별 `JOIN` 구문에서 `JOIN` 타입, `JOIN` 대상 테이블, 별칭, `ON` 조건절 텍스트를 추출합니다.

### 3.2. JOIN 관계 추적 로직 구현

추출된 정보를 바탕으로, 테이블 간의 관계를 순차적으로 쌓아나가는 로직이 필요합니다.

#### **의사 코드 (Pseudo-code) - 개선안**
```python
def analyze_explicit_joins(sql_content):
    # 1. FROM 절에서 기본 테이블(base_table)과 별칭(base_alias)을 찾는다.
    # 이것이 모든 관계의 시작점이자 첫 번째 "source_table"이 된다.
    source_table, source_alias = find_base_table_from_from_clause(sql_content)
    if not source_table:
        return [] # FROM 절이 없으면 분석 불가

    # 별칭과 실제 테이블명을 매핑하여 관리한다.
    alias_to_table_map = {source_alias or source_table: source_table}
    
    # 2. 모든 JOIN 절을 순서대로 찾는다.
    join_clauses = find_all_join_clauses(sql_content)
    
    relationships = []
    
    # 이전 JOIN의 테이블을 현재 JOIN의 소스로 사용하기 위한 변수
    previous_table = source_table

    for clause_text in join_clauses:
        # 3. 개별 JOIN 절 파싱
        join_type, join_table, join_alias, on_condition_text = parse_join_clause(clause_text)
        
        # 별칭 맵에 현재 JOIN 테이블 추가
        alias_to_table_map[join_alias or join_table] = join_table

        # 4. 관계 생성
        # CROSS/NATURAL JOIN: ON이 없으므로, 이전 테이블(previous_table)과 관계를 맺는다.
        if join_type in ['CROSS_JOIN', 'NATURAL_JOIN']:
            target_table = join_table
            source_of_relation = previous_table
        # 일반 JOIN: ON 조건절을 분석하여 관계를 찾는다.
        else:
            # ON t1.col = t2.col 에서 t1, t2 별칭 추출
            on_alias1, on_alias2 = find_aliases_in_on_condition(on_condition_text)
            
            # 별칭을 실제 테이블명으로 변환
            table1 = alias_to_table_map.get(on_alias1)
            table2 = alias_to_table_map.get(on_alias2)

            # 관계의 양쪽을 결정 (현재 join_table이 포함되도록)
            if join_table == table1:
                source_of_relation = table2
                target_table = table1
            else:
                source_of_relation = table1
                target_table = table2

        if source_of_relation and target_table:
            relationships.append({
                'source_table': source_of_relation,
                'target_table': target_table,
                'join_type': join_type
            })
        
        # 5. 다음 순회를 위해 현재 JOIN 테이블을 "previous_table"로 업데이트
        previous_table = join_table
            
    return relationships
```

### 3.3. `sql_keyword.yaml` 설정 파일 활용 방안

- **`explicit_joins` 패턴 수정**: `FROM`절 패턴, `JOIN`절 전체를 포착하는 패턴, `ON` 조건절 내부를 분석하는 패턴 등 **역할별로 패턴을 분리하여 정의**해야 합니다.
- **`join_type_mapping`**: 2차 계획서의 아이디어는 매우 좋습니다. 그대로 유지하고 활용합니다.

---

## 4. 결론 (재검토)

2차 개발계획서는 1차에 비해 크게 발전했으나, **SQL 구문 전체의 연결 구조를 파악하는 문맥적 분석 능력**이 결여되어 있습니다. 각 `JOIN`을 독립된 사건으로 취급하는 현재 방식으로는 `정답지`에 기술된 복잡한 JOIN 체인을 올바르게 분석할 수 없습니다.

**`FROM` 절에서 관계의 뿌리(root)를 찾고, 각 `JOIN`을 순차적으로 따라가며 관계의 나무(tree)를 그려나가는 방식으로의 근본적인 사고 전환이 필요합니다.**

위에 제시된 **단계적 분석 로직**과 **의사 코드**를 반영하여 개발 계획을 수정한다면, `정답지` 기준 EXPLICIT JOIN 정확도 85% 이상을 달성하고, 나아가 IMPLICIT JOIN 분석 로직 개선의 발판까지 마련할 수 있을 것입니다.
