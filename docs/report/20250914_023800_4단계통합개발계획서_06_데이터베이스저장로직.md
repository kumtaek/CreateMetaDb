# 4~5단계 통합 개발계획서 - 데이터베이스 저장 로직

## 문서 정보
- **작성일**: 2025-09-14 02:38:00
- **작성자**: AI Assistant
- **문서 유형**: 통합 개발계획서
- **대상 단계**: 4~5단계 통합 - 데이터베이스 저장 로직

## 1. 개요

### 1.1 저장 대상 테이블
- **classes 테이블**: Java 클래스 정보 저장
- **components 테이블**: Java 메서드 컴포넌트 저장
- **relationships 테이블**: Java 컴포넌트 간 관계 저장

### 1.2 저장 순서
1. **클래스 정보 저장**: classes 테이블에 클래스 정보 저장
2. **메서드 컴포넌트 저장**: components 테이블에 메서드 정보 저장
3. **관계 정보 저장**: relationships 테이블에 모든 관계 정보 저장

### 1.3 저장 원칙
- **배치 저장**: 대량 데이터를 효율적으로 저장
- **트랜잭션 처리**: 원자성 보장
- **오류 처리**: 저장 실패 시 적절한 오류 처리
- **공통함수 활용**: DatabaseUtils 공통함수 사용

## 2. 클래스 정보 저장 로직

### 2.1 클래스 정보 저장 메서드

```python
def _save_classes_to_database(self, classes: List[Dict[str, Any]]) -> bool:
    """
    클래스 정보를 classes 테이블에 저장
    
    Args:
        classes: 클래스 정보 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not classes:
            warning("저장할 클래스가 없습니다")
            return True
        
        # 프로젝트 ID 조회 (USER RULES: 공통함수 사용)
        project_id = self._get_project_id()
        if not project_id:
            # USER RULES: Exception 발생시 handle_error()로 exit()
            from util.logger import handle_error
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "클래스 정보 저장 실패")
            return False
        
        # 클래스 데이터 변환
        class_data_list = []
        for class_info in classes:
            # 파일 ID 조회
            file_id = self._get_file_id(class_info['file_path'])
            if not file_id:
                warning(f"파일 ID를 찾을 수 없습니다: {class_info['file_path']}")
                continue
            
            class_data = {
                'project_id': project_id,
                'file_id': file_id,
                'class_name': class_info['class_name'],
                'parent_class_id': None,  # 나중에 상속 관계 분석에서 업데이트
                'line_start': class_info['line_start'],
                'line_end': class_info['line_end'],
                'hash_value': class_info['hash_value'],
                'has_error': 'N',
                'error_message': None,
                'del_yn': 'N'
            }
            class_data_list.append(class_data)
        
        # 배치 저장 (USER RULES: 공통함수 사용)
        if class_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('classes', class_data_list)
            if processed_count > 0:
                info(f"클래스 정보 저장 완료: {processed_count}개")
                return True
            else:
                # USER RULES: Exception 발생시 handle_error()로 exit()
                from util.logger import handle_error
                handle_error(Exception("클래스 정보 저장 실패"), "클래스 정보 저장 실패")
                return False
        else:
            warning("저장할 유효한 클래스가 없습니다")
            return True
            
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, "클래스 정보 저장 실패")
        return False
```

### 2.2 프로젝트 ID 조회

```python
def _get_project_id(self) -> Optional[int]:
    """
    프로젝트 ID 조회
    
    Returns:
        프로젝트 ID 또는 None
    """
    try:
        # USER RULES: 공통함수 사용
        from util.global_project import get_global_project_id
        project_id = get_global_project_id()
        
        if not project_id:
            # 데이터베이스에서 직접 조회
            query = "SELECT project_id FROM projects WHERE project_name = ?"
            result = self.db_utils.execute_query(query, (self.project_name,))
            if result:
                project_id = result[0]['project_id']
        
        return project_id
        
    except Exception as e:
        warning(f"프로젝트 ID 조회 실패: {str(e)}")
        return None
```

### 2.3 파일 ID 조회

```python
def _get_file_id(self, file_path: str) -> Optional[int]:
    """
    파일 ID 조회
    
    Args:
        file_path: 파일 경로
        
    Returns:
        파일 ID 또는 None
    """
    try:
        # USER RULES: 공통함수 사용
        from util.path_utils import PathUtils
        path_utils = PathUtils()
        
        # 프로젝트 ID 조회
        project_id = self._get_project_id()
        if not project_id:
            return None
        
        # 파일 경로 정규화
        normalized_path = path_utils.normalize_path(file_path)
        
        # 파일 ID 조회
        query = "SELECT file_id FROM files WHERE project_id = ? AND file_path = ?"
        result = self.db_utils.execute_query(query, (project_id, normalized_path))
        
        if result:
            return result[0]['file_id']
        else:
            warning(f"파일 ID를 찾을 수 없습니다: {file_path}")
            return None
        
    except Exception as e:
        warning(f"파일 ID 조회 실패: {file_path} - {str(e)}")
        return None
```

## 3. 메서드 컴포넌트 저장 로직

### 3.1 메서드 컴포넌트 저장 메서드

```python
def _save_method_components_to_database(self, methods: List[Dict[str, Any]]) -> bool:
    """
    메서드 정보를 components 테이블에 저장
    
    Args:
        methods: 메서드 정보 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not methods:
            warning("저장할 메서드가 없습니다")
            return True
        
        # 프로젝트 ID 조회 (USER RULES: 공통함수 사용)
        project_id = self._get_project_id()
        if not project_id:
            # USER RULES: Exception 발생시 handle_error()로 exit()
            from util.logger import handle_error
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "메서드 컴포넌트 저장 실패")
            return False
        
        # 메서드 데이터 변환
        method_data_list = []
        for method_info in methods:
            # 클래스 ID 조회 (classes 테이블에서)
            class_id = self._get_class_id(project_id, method_info['class_name'])
            if not class_id:
                warning(f"클래스 ID를 찾을 수 없습니다: {method_info['class_name']}")
                continue
            
            # 파일 ID 조회
            file_id = self._get_file_id(method_info['file_path'])
            if not file_id:
                warning(f"파일 ID를 찾을 수 없습니다: {method_info['file_path']}")
                continue
            
            method_data = {
                'project_id': project_id,
                'component_type': 'METHOD',
                'component_name': method_info['method_name'],  # 메서드명만
                'parent_id': class_id,  # 클래스의 class_id를 FK로 연결
                'file_id': file_id,
                'line_start': method_info['line_start'],
                'line_end': method_info['line_end'],
                'hash_value': method_info['hash_value'],
                'has_error': 'N',
                'error_message': None,
                'del_yn': 'N'
            }
            method_data_list.append(method_data)
        
        # 배치 저장 (USER RULES: 공통함수 사용)
        if method_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('components', method_data_list)
            if processed_count > 0:
                info(f"메서드 컴포넌트 저장 완료: {processed_count}개")
                return True
            else:
                # USER RULES: Exception 발생시 handle_error()로 exit()
                from util.logger import handle_error
                handle_error(Exception("메서드 컴포넌트 저장 실패"), "메서드 컴포넌트 저장 실패")
                return False
        else:
            warning("저장할 유효한 메서드가 없습니다")
            return True
            
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, "메서드 컴포넌트 저장 실패")
        return False
```

### 3.2 클래스 ID 조회

```python
def _get_class_id(self, project_id: int, class_name: str) -> Optional[int]:
    """
    클래스 ID 조회
    
    Args:
        project_id: 프로젝트 ID
        class_name: 클래스명
        
    Returns:
        클래스 ID 또는 None
    """
    try:
        # 클래스 ID 조회
        query = "SELECT class_id FROM classes WHERE project_id = ? AND class_name = ? AND del_yn = 'N'"
        result = self.db_utils.execute_query(query, (project_id, class_name))
        
        if result:
            return result[0]['class_id']
        else:
            warning(f"클래스 ID를 찾을 수 없습니다: {class_name}")
            return None
        
    except Exception as e:
        warning(f"클래스 ID 조회 실패: {class_name} - {str(e)}")
        return None
```

## 4. 관계 정보 저장 로직

### 4.1 관계 정보 저장 메서드

```python
def _save_relationships_to_database(self, relationships: List[Dict[str, Any]]) -> bool:
    """
    관계 정보를 relationships 테이블에 저장
    
    Args:
        relationships: 관계 정보 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not relationships:
            warning("저장할 관계가 없습니다")
            return True
        
        # 프로젝트 ID 조회 (USER RULES: 공통함수 사용)
        project_id = self._get_project_id()
        if not project_id:
            # USER RULES: Exception 발생시 handle_error()로 exit()
            from util.logger import handle_error
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "관계 정보 저장 실패")
            return False
        
        # 관계 데이터 변환
        relationship_data_list = []
        for rel_info in relationships:
            # 소스 컴포넌트 ID 조회
            src_component_id = self._get_component_id(project_id, rel_info['src_name'])
            if not src_component_id:
                warning(f"소스 컴포넌트 ID를 찾을 수 없습니다: {rel_info['src_name']}")
                continue
            
            # 대상 컴포넌트 ID 조회
            dst_component_id = self._get_component_id(project_id, rel_info['dst_name'])
            if not dst_component_id:
                warning(f"대상 컴포넌트 ID를 찾을 수 없습니다: {rel_info['dst_name']}")
                continue
            
            relationship_data = {
                'project_id': project_id,
                'src_id': src_component_id,
                'dst_id': dst_component_id,
                'rel_type': rel_info['rel_type'],
                'line_number': rel_info.get('line_number', 0),
                'relationship_detail': rel_info.get('relationship_detail', ''),
                'has_error': 'N',
                'error_message': None,
                'del_yn': 'N'
            }
            relationship_data_list.append(relationship_data)
        
        # 배치 저장 (USER RULES: 공통함수 사용)
        if relationship_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('relationships', relationship_data_list)
            if processed_count > 0:
                info(f"관계 정보 저장 완료: {processed_count}개")
                return True
            else:
                # USER RULES: Exception 발생시 handle_error()로 exit()
                from util.logger import handle_error
                handle_error(Exception("관계 정보 저장 실패"), "관계 정보 저장 실패")
                return False
        else:
            warning("저장할 유효한 관계가 없습니다")
            return True
            
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, "관계 정보 저장 실패")
        return False
```

### 4.2 컴포넌트 ID 조회

```python
def _get_component_id(self, project_id: int, component_name: str) -> Optional[int]:
    """
    컴포넌트 ID 조회
    
    Args:
        project_id: 프로젝트 ID
        component_name: 컴포넌트명
        
    Returns:
        컴포넌트 ID 또는 None
    """
    try:
        # 컴포넌트 ID 조회
        query = "SELECT component_id FROM components WHERE project_id = ? AND component_name = ? AND del_yn = 'N'"
        result = self.db_utils.execute_query(query, (project_id, component_name))
        
        if result:
            return result[0]['component_id']
        else:
            warning(f"컴포넌트 ID를 찾을 수 없습니다: {component_name}")
            return None
        
    except Exception as e:
        warning(f"컴포넌트 ID 조회 실패: {component_name} - {str(e)}")
        return None
```

## 5. 상속 관계 업데이트 로직

### 5.1 상속 관계 업데이트

```python
def _update_inheritance_relationships(self, classes: List[Dict[str, Any]]) -> bool:
    """
    상속 관계 업데이트
    
    Args:
        classes: 클래스 정보 리스트
        
    Returns:
        업데이트 성공 여부
    """
    try:
        if not classes:
            return True
        
        project_id = self._get_project_id()
        if not project_id:
            return False
        
        # 상속 관계가 있는 클래스들 처리
        for class_info in classes:
            if class_info.get('parent_class_name'):
                # 자식 클래스 ID 조회
                child_class_id = self._get_class_id(project_id, class_info['class_name'])
                if not child_class_id:
                    continue
                
                # 부모 클래스 ID 조회
                parent_class_id = self._get_class_id(project_id, class_info['parent_class_name'])
                if not parent_class_id:
                    continue
                
                # 상속 관계 업데이트
                query = "UPDATE classes SET parent_class_id = ? WHERE class_id = ?"
                self.db_utils.execute_update(query, (parent_class_id, child_class_id))
        
        info("상속 관계 업데이트 완료")
        return True
        
    except Exception as e:
        warning(f"상속 관계 업데이트 실패: {str(e)}")
        return False
```

## 6. 배치 저장 최적화

### 6.1 트랜잭션 처리

```python
def _save_with_transaction(self, data_dict: Dict[str, List[Dict[str, Any]]]) -> bool:
    """
    트랜잭션으로 배치 저장
    
    Args:
        data_dict: 저장할 데이터 딕셔너리
        
    Returns:
        저장 성공 여부
    """
    try:
        # 트랜잭션 시작
        self.db_utils.begin_transaction()
        
        try:
            # 클래스 정보 저장
            if 'classes' in data_dict and data_dict['classes']:
                if not self._save_classes_to_database(data_dict['classes']):
                    raise Exception("클래스 정보 저장 실패")
            
            # 메서드 정보 저장
            if 'methods' in data_dict and data_dict['methods']:
                if not self._save_method_components_to_database(data_dict['methods']):
                    raise Exception("메서드 정보 저장 실패")
            
            # 관계 정보 저장
            if 'relationships' in data_dict and data_dict['relationships']:
                if not self._save_relationships_to_database(data_dict['relationships']):
                    raise Exception("관계 정보 저장 실패")
            
            # 트랜잭션 커밋
            self.db_utils.commit_transaction()
            return True
            
        except Exception as e:
            # 트랜잭션 롤백
            self.db_utils.rollback_transaction()
            # USER RULES: Exception 발생시 handle_error()로 exit()
            from util.logger import handle_error
            handle_error(e, "트랜잭션 저장 실패")
            return False
        
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, "트랜잭션 시작 실패")
        return False
```

### 6.2 배치 크기 최적화

```python
def _save_with_optimal_batch_size(self, table_name: str, data_list: List[Dict[str, Any]]) -> bool:
    """
    최적 배치 크기로 저장
    
    Args:
        table_name: 테이블명
        data_list: 데이터 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not data_list:
            return True
        
        # 최적 배치 크기 결정
        optimal_batch_size = self._calculate_optimal_batch_size(table_name, data_list)
        
        # 배치 단위로 저장
        for i in range(0, len(data_list), optimal_batch_size):
            batch_data = data_list[i:i+optimal_batch_size]
            
            # USER RULES: 공통함수 사용
            processed_count = self.db_utils.batch_insert_or_replace(table_name, batch_data)
            if processed_count == 0:
                # USER RULES: Exception 발생시 handle_error()로 exit()
                from util.logger import handle_error
                handle_error(Exception(f"{table_name} 저장 실패"), f"{table_name} 저장 실패")
                return False
        
        info(f"{table_name} 최적 배치 저장 완료: {len(data_list)}개")
        return True
        
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, f"{table_name} 최적 배치 저장 실패")
        return False

def _calculate_optimal_batch_size(self, table_name: str, data_list: List[Dict[str, Any]]) -> int:
    """
    최적 배치 크기 계산
    
    Args:
        table_name: 테이블명
        data_list: 데이터 리스트
        
    Returns:
        최적 배치 크기
    """
    try:
        # 기본 배치 크기
        base_batch_size = 1000
        
        # 테이블별 최적화
        if table_name == 'classes':
            return min(base_batch_size, 500)  # 클래스는 보통 적음
        elif table_name == 'components':
            return min(base_batch_size, 1000)  # 메서드는 많을 수 있음
        elif table_name == 'relationships':
            return min(base_batch_size, 2000)  # 관계는 가장 많음
        else:
            return base_batch_size
            
    except Exception as e:
        warning(f"최적 배치 크기 계산 실패: {str(e)}")
        return 1000
```

## 7. 오류 처리 및 로깅

### 7.1 저장 오류 처리

```python
def _handle_save_error(self, error: Exception, table_name: str, data_count: int) -> bool:
    """
    저장 오류 처리
    
    Args:
        error: 발생한 오류
        table_name: 테이블명
        data_count: 데이터 개수
        
    Returns:
        오류 처리 성공 여부
    """
    try:
        error_message = f"{table_name} 저장 실패: {str(error)} (데이터 개수: {data_count})"
        error(error_message)
        
        # 오류 통계 업데이트
        self.stats['errors'] += 1
        
        # 심각한 오류인 경우 프로그램 종료
        if "connection" in str(error).lower() or "database" in str(error).lower():
            # USER RULES: Exception 발생시 handle_error()로 exit()
            from util.logger import handle_error
            handle_error(error, f"{table_name} 데이터베이스 오류")
            return False
        
        # 일반적인 저장 오류는 계속 진행
        return True
        
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, "저장 오류 처리 실패")
        return False
```

### 7.2 저장 통계 출력

```python
def _print_save_statistics(self):
    """
    저장 통계 정보 출력
    """
    try:
        info("=== 데이터베이스 저장 통계 ===")
        info(f"처리된 Java 파일 수: {self.stats['java_files_processed']}")
        info(f"추출된 클래스 수: {self.stats['classes_extracted']}")
        info(f"추출된 메서드 수: {self.stats['methods_extracted']}")
        info(f"생성된 메서드 컴포넌트 수: {self.stats['method_components_created']}")
        info(f"생성된 상속 관계 수: {self.stats['inheritance_relationships_created']}")
        info(f"생성된 CALL_QUERY 관계 수: {self.stats['call_query_relationships_created']}")
        info(f"생성된 CALL_METHOD 관계 수: {self.stats['call_method_relationships_created']}")
        info(f"생성된 USE_TABLE 관계 수: {self.stats['use_table_relationships_created']}")
        info(f"오류 발생 수: {self.stats['errors']}")
        
    except Exception as e:
        warning(f"저장 통계 출력 실패: {str(e)}")
```

## 8. 다음 단계

다음 문서에서는 문서화 완료를 제시합니다:
- [7. 문서화 완료](./20250914_023800_4~5단계통합개발계획서_07_문서화완료.md)
