# 5단계 개발계획서 - JSP 파서 설계 및 구현 제안4 답변

## 1. 개요

`20250914_022700_5단계개발계획서_제안4.md` 파일의 추가 검토 의견에 대한 답변을 제공합니다.

## 2. 추가 검토 의견 답변

### 2.1. `_extract_class_name_from_object` 및 `_infer_class_name_from_context` 함수의 반환 타입

**답변**: 제안하신 의견을 수용합니다.

**수정된 구현**:
```python
def _extract_class_name_from_object(self, object_name: str) -> str:
    """객체명에서 클래스명 추출 (통일된 inferred 처리)"""
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 클래스명 매핑 로드
        from util import ConfigUtils
        config_utils = ConfigUtils()
        class_name_mapping = config_utils.load_yaml_config(
            config_utils.get_config_path("jsp_keyword.yaml")
        ).get('class_name_mapping', {})
        
        if object_name in class_name_mapping:
            return class_name_mapping[object_name]
        
        # 매핑에 없는 경우 inferred 클래스명으로 통일
        return 'InferredClass'
        
    except Exception as e:
        # 시스템 에러 - 프로그램 종료
        handle_error(e, f"클래스명 추출 시스템 에러: {object_name}")

def _infer_class_name_from_context(self, method_name: str) -> str:
    """컨텍스트에서 클래스명 추론 (통일된 inferred 처리)"""
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 메서드-클래스 매핑 로드
        from util import ConfigUtils
        config_utils = ConfigUtils()
        method_class_mapping = config_utils.load_yaml_config(
            config_utils.get_config_path("jsp_keyword.yaml")
        ).get('method_class_mapping', {})
        
        if method_name in method_class_mapping:
            return method_class_mapping[method_name]
        
        # 매핑에 없는 경우 inferred 클래스명으로 통일
        return 'InferredClass'
        
    except Exception as e:
        # 시스템 에러 - 프로그램 종료
        handle_error(e, f"클래스명 추론 시스템 에러: {method_name}")
```

**장점**:
- 함수의 주된 목적(클래스명 반환)에 집중
- 시스템 에러는 `handle_error()`로 프로그램 종료 처리
- 더 일반적이고 직관적인 함수 설계

### 2.2. `DatabaseUtils` 싱글톤 패턴 구현 (재검토)

**답변**: 제안하신 의견을 수용합니다.

**수정된 구현**:
```python
class DatabaseUtils:
    """데이터베이스 유틸리티 - 싱글톤 패턴"""
    
    _instance = None
    _initialized = False
    
    def __new__(cls, db_path: str = None):
        if cls._instance is None:
            cls._instance = super(DatabaseUtils, cls).__new__(cls)
        return cls._instance
    
    def __init__(self, db_path: str = None):
        if not self._initialized:
            self.db_path = db_path
            self.connection = None
            self._initialized = True
    
    def connect(self, db_path: str = None):
        """데이터베이스 연결"""
        if db_path:
            self.db_path = db_path
        
        if not self.db_path:
            raise ValueError("데이터베이스 경로가 설정되지 않았습니다")
        
        try:
            self.connection = sqlite3.connect(self.db_path)
            self.connection.row_factory = sqlite3.Row
            app_logger.debug(f"데이터베이스 연결 성공: {self.db_path}")
        except Exception as e:
            handle_error(e, f"데이터베이스 연결 실패: {self.db_path}")
    
    def get_connection(self):
        """연결된 데이터베이스 커넥션 반환"""
        if not self.connection:
            self.connect()
        return self.connection
```

**사용 방식**:
```python
# JspLoadingEngine에서 초기화
self.db_utils = DatabaseUtils(self.metadata_db_path)
self.db_utils.connect()

# 다른 곳에서는 인자 없이 호출하여 싱글톤 인스턴스 사용
db_utils = DatabaseUtils()
connection = db_utils.get_connection()
```

### 2.3. `util/path_utils.py`의 `DatabaseUtils` 인스턴스 전달

**답변**: 제안하신 의견을 수용합니다.

**수정된 구현**:
```python
# JspLoadingEngine에서
class JspLoadingEngine:
    def __init__(self, project_name: str):
        # DatabaseUtils 싱글톤 인스턴스 생성
        self.db_utils = DatabaseUtils(self.metadata_db_path)
        self.db_utils.connect()
        
        # JspParser에 db_utils 전달
        self.jsp_parser = JspParser(self.db_utils)

# JspParser에서
class JspParser:
    def __init__(self, db_utils: DatabaseUtils):
        self.db_utils = db_utils
    
    def _create_inferred_class(self, project_id: int, class_name: str, file_id: int) -> Optional[int]:
        # path_utils 함수에 db_utils 전달
        return get_jsp_component_id(project_id, class_name, 'CLASS', file_id, self.db_utils)

# util/path_utils.py에서
def get_file_id(project_id: int, file_path: str, db_utils: DatabaseUtils) -> Optional[int]:
    """파일 ID 조회"""
    try:
        query = "SELECT file_id FROM files WHERE project_id = ? AND file_path = ? AND del_yn = 'N'"
        result = db_utils.execute_query(query, (project_id, file_path))
        return result[0]['file_id'] if result else None
    except Exception as e:
        handle_error(e, f"파일 ID 조회 실패: {file_path}")
        return None
```

### 2.4. `util/file_utils.py`의 `is_included_file` 함수 내 `handle_error` 호출

**답변**: 제안하신 의견을 수용합니다. 예외 유형에 따라 구분하여 처리하겠습니다.

**수정된 구현**:
```python
def is_included_file(file_path: str, project_name: str = None) -> bool:
    """
    target_source_config.yaml 설정을 기반으로 파일 포함/제외 여부 판단
    
    Args:
        file_path: 파일 경로
        project_name: 프로젝트명 (선택적)
        
    Returns:
        포함 여부
    """
    try:
        # USER RULES: 공통함수 사용 지향
        from util import ConfigUtils, PathUtils
        
        # target_source_config.yaml 로드
        config_utils = ConfigUtils()
        config_path = PathUtils().get_config_path("target_source_config.yaml")
        config = config_utils.load_yaml_config(config_path)
        
        if not config:
            # 설정 파일 로드 실패 시 기본적으로 포함
            return True
        
        # 1. exclude_directories 확인 (우선순위 높음)
        exclude_directories = config.get('exclude_directories', [])
        if exclude_directories:
            from fnmatch import fnmatch
            for pattern in exclude_directories:
                if fnmatch(file_path, pattern):
                    return False
        
        # 2. include_patterns 확인
        include_patterns = config.get('include_patterns', [])
        if include_patterns:
            from fnmatch import fnmatch
            for pattern in include_patterns:
                if fnmatch(file_path, pattern):
                    # 3. exclude_files 확인
                    exclude_files = config.get('exclude_files', [])
                    for exclude_pattern in exclude_files:
                        if fnmatch(file_path, exclude_pattern):
                            return False
                    return True
        
        # include_patterns에 매칭되지 않으면 제외
        return False
        
    except (FileNotFoundError, PermissionError, OSError) as e:
        # 파일 시스템 관련 예외 - 해당 파일만 제외하고 계속 진행
        warning(f"파일 접근 오류로 제외: {file_path}, 오류: {str(e)}")
        return False
        
    except (yaml.YAMLError, UnicodeDecodeError) as e:
        # 설정 파일 파싱 오류 - 해당 파일만 제외하고 계속 진행
        warning(f"설정 파일 파싱 오류로 제외: {file_path}, 오류: {str(e)}")
        return False
        
    except (ImportError, AttributeError, TypeError) as e:
        # 시스템 에러 - 프로그램 종료
        handle_error(e, f"파일 포함 여부 확인 실패: {file_path}")
        return False
```

**예외 처리 구분**:
- **파일 시스템 오류**: `warning` 로그 후 `False` 반환 (해당 파일만 제외)
- **설정 파일 파싱 오류**: `warning` 로그 후 `False` 반환 (해당 파일만 제외)
- **시스템 에러**: `handle_error()` 호출 (프로그램 종료)

### 2.5. `_create_inferred_class` 및 `_create_inferred_method` 함수 내 `db_utils.insert_component` 호출

**답변**: `DatabaseUtils`에 `insert_component` 함수를 새로 추가하겠습니다.

**수정된 구현**:
```python
# DatabaseUtils에 추가
def insert_component(self, project_id: int, component_name: str, component_type: str, 
                    file_id: int, parent_id: int = None, has_error: str = 'N', 
                    error_message: str = None) -> Optional[int]:
    """
    단일 컴포넌트 삽입
    
    Args:
        project_id: 프로젝트 ID
        component_name: 컴포넌트명
        component_type: 컴포넌트 타입
        file_id: 파일 ID
        parent_id: 부모 컴포넌트 ID (선택적)
        has_error: 오류 여부
        error_message: 오류 메시지 (선택적)
        
    Returns:
        component_id 또는 None
    """
    try:
        query = """
            INSERT INTO components 
            (project_id, component_name, component_type, file_id, parent_id, has_error, error_message, del_yn, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, 'N', datetime('now'))
        """
        cursor = self.get_connection().execute(query, (
            project_id, component_name, component_type, file_id, 
            parent_id, has_error, error_message
        ))
        self.get_connection().commit()
        
        component_id = cursor.lastrowid
        app_logger.debug(f"컴포넌트 삽입 성공: {component_name} (ID: {component_id})")
        return component_id
        
    except Exception as e:
        handle_error(e, f"컴포넌트 삽입 실패: {component_name}")
        return None

# JspParser에서 사용
def _create_inferred_class(self, project_id: int, class_name: str, file_id: int) -> Optional[int]:
    """inferred 클래스 생성"""
    try:
        component_id = self.db_utils.insert_component(
            project_id=project_id,
            component_name=class_name,
            component_type='CLASS',
            file_id=file_id
        )
        
        if component_id:
            info(f"inferred 클래스 생성: {class_name} (ID: {component_id})")
        
        return component_id
        
    except Exception as e:
        handle_error(e, f"inferred 클래스 생성 실패: {class_name}")
        return None

def _create_inferred_method(self, project_id: int, method_name: str, file_id: int, 
                           parent_id: int) -> Optional[int]:
    """inferred 메서드 생성"""
    try:
        component_id = self.db_utils.insert_component(
            project_id=project_id,
            component_name=method_name,
            component_type='METHOD',
            file_id=file_id,
            parent_id=parent_id
        )
        
        if component_id:
            info(f"inferred 메서드 생성: {method_name} (ID: {component_id})")
        
        return component_id
        
    except Exception as e:
        handle_error(e, f"inferred 메서드 생성 실패: {method_name}")
        return None
```

## 3. 수정된 구현 계획

### 3.1. 함수 반환 타입 단순화
- 클래스명 추출 함수들은 문자열만 반환
- 오류 정보는 로그로 기록, 컴포넌트 저장 시점에 `has_error='Y'` 처리

### 3.2. DatabaseUtils 싱글톤 패턴 개선
- `db_path` 없이도 인스턴스 생성 가능
- `connect()` 메서드에서 `db_path` 검증
- 명확한 인스턴스 전달 방식

### 3.3. 예외 처리 구분
- **파일 필터링 오류**: `warning` 후 해당 파일만 제외
- **시스템 에러**: `handle_error()` 호출로 프로그램 종료

### 3.4. DatabaseUtils 기능 확장
- `insert_component` 함수 추가
- 단일 컴포넌트 삽입 및 ID 반환 기능

## 4. 결론

제안하신 모든 추가 검토 의견을 수용하여 5단계 JSP 파서를 구현하겠습니다. 특히 함수 설계의 단순화, 예외 처리의 구분, 그리고 DatabaseUtils의 기능 확장을 통해 더욱 견고하고 효율적인 코드를 작성하겠습니다.

---

**문서 작성 완료**: 2025-01-14 16:45:00  
**답변 완료**: 모든 추가 검토 의견에 대한 답변 제공
