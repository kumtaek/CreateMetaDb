# 6단계 개발계획서 - 메모리 최적화 전략

## 문서 정보
- **작성일**: 2025-09-14 02:30:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서
- **대상 단계**: 6단계 - 메모리 최적화

## 1. 메모리 최적화 개요

### 1.1 최적화 목표
- **메모리 사용량 최소화**: 대용량 JSP 파일 처리 시 메모리 부족 방지
- **처리 성능 향상**: 스트리밍 처리로 효율적인 파일 처리
- **안정성 확보**: 메모리 누수 방지 및 안정적인 처리

### 1.2 최적화 전략
1. **스트리밍 처리**: 한 파일씩만 메모리에 로드하여 처리
2. **즉시 해제**: 파일 처리 완료 후 즉시 메모리에서 해제
3. **배치 저장**: 여러 컴포넌트를 한 번에 저장하여 DB 연결 횟수 최소화
4. **정규식 기반 파싱**: AST 파서 대신 정규식으로 메모리 효율성 확보

## 2. 스트리밍 처리 구현

### 2.1 파일별 스트리밍 처리

```python
def execute_jsp_loading(self) -> bool:
    """
    JSP 로딩 실행: 6단계 처리 (메모리 최적화)
    
    Returns:
        실행 성공 여부
    """
    try:
        info("=== JSP 로딩 시작: 6단계 처리 ===")
        
        # 데이터베이스 연결 (USER RULES: 공통함수 사용)
        self.db_utils = DatabaseUtils(self.metadata_db_path)
        if not self.db_utils.connect():
            error("메타데이터베이스 연결 실패")
            return False
        
        # 1. JSP 파일 수집
        jsp_files = self.jsp_parser.get_filtered_jsp_files(self.project_source_path)
        if not jsp_files:
            warning("JSP 파일이 없습니다")
            return True
        
        # 2. JSP 파일별 스트리밍 처리 (메모리 최적화)
        for jsp_file in jsp_files:
            try:
                # 메모리 최적화: 한 파일씩만 메모리에 로드하여 처리
                analysis_result = self.jsp_parser.parse_jsp_file(jsp_file)
                
                # 파싱 에러 체크 (USER RULES: 파싱 에러는 계속 진행)
                if analysis_result.get('has_error') == 'Y':
                    warning(f"JSP 파싱 에러로 건너뜀: {jsp_file} - {analysis_result.get('error_message', '')}")
                    self.stats['errors'] += 1
                    continue
                
                # JSP 컴포넌트 저장
                if analysis_result['jsp_component']:
                    try:
                        if self._save_jsp_components_to_database([analysis_result['jsp_component']]):
                            self.stats['jsp_components_created'] += 1
                    except Exception as e:
                        handle_error(e, f"JSP 컴포넌트 저장 실패: {jsp_file}")
                        return False
                
                # JSP → METHOD 관계 저장
                if analysis_result['java_method_relationships']:
                    try:
                        if self._save_jsp_method_relationships_to_database(analysis_result['java_method_relationships']):
                            self.stats['jsp_method_relationships_created'] += len(analysis_result['java_method_relationships'])
                    except Exception as e:
                        handle_error(e, f"JSP → METHOD 관계 저장 실패: {jsp_file}")
                        return False
                
                self.stats['jsp_files_processed'] += 1
                
                # 메모리 최적화: 처리 후 즉시 해제
                del analysis_result
                
            except Exception as e:
                # 시스템 에러 (데이터베이스, 메모리 등) - 프로그램 종료
                handle_error(e, f"JSP 파일 처리 실패: {jsp_file}")
                return False
        
        # 3. 통계 정보 출력
        self._print_jsp_loading_statistics()
        
        info("=== JSP 로딩 완료 ===")
        return True
        
    except Exception as e:
        handle_error(e, "JSP 로딩 실행 실패")
        return False
    finally:
        # 데이터베이스 연결 해제
        if self.db_utils:
            self.db_utils.disconnect()
```

### 2.2 JSP 파일 스트리밍 파싱

```python
def parse_jsp_file(self, jsp_file: str) -> Dict[str, Any]:
    """
    JSP 파일에서 컴포넌트 정보 추출 및 Java 메서드 관계 분석 (메모리 최적화)
    
    Args:
        jsp_file: JSP 파일 경로
        
    Returns:
        분석 결과 딕셔너리
    """
    try:
        # 1. JSP 파일 읽기 (스트리밍 처리)
        file_utils = FileUtils()
        jsp_content = file_utils.read_file(jsp_file)
        if not jsp_content:
            return {
                'jsp_component': None,
                'java_method_relationships': [],
                'file_path': jsp_file,
                'has_error': 'Y',
                'error_message': 'JSP 파일 읽기 실패'
            }
        
        # 2. JSP 컴포넌트 정보 추출
        jsp_component = self._extract_jsp_component_info(jsp_content, jsp_file)
        
        # 3. Java 메서드 호출 분석
        java_method_relationships = self._analyze_java_method_calls(jsp_content)
        
        # 4. 통계 업데이트
        self.stats['files_processed'] += 1
        if jsp_component:
            self.stats['jsp_components_extracted'] += 1
        self.stats['java_method_relationships_created'] += len(java_method_relationships)
        
        # 5. 메모리 최적화: JSP 내용 즉시 해제
        del jsp_content
        
        return {
            'jsp_component': jsp_component,
            'java_method_relationships': java_method_relationships,
            'file_path': jsp_file
        }
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        error_message = f"JSP 파싱 중 예외 발생: {str(e)}"
        warning(f"{error_message} - {jsp_file}")
        self.stats['errors'] += 1
        return {
            'jsp_component': None,
            'java_method_relationships': [],
            'file_path': jsp_file,
            'has_error': 'Y',
            'error_message': error_message
        }
```

## 3. 즉시 해제 전략

### 3.1 파일 내용 즉시 해제

```python
def _extract_jsp_component_info(self, jsp_content: str, file_path: str) -> Dict[str, Any]:
    """
    JSP 파일에서 JSP 컴포넌트 정보 추출 (메모리 최적화)
    
    Args:
        jsp_content: JSP 파일 내용
        file_path: 파일 경로
        
    Returns:
        JSP 컴포넌트 정보
    """
    try:
        # JSP 파일명 추출
        jsp_name = os.path.basename(file_path)
        
        # JSP 경로 추출 (웹 애플리케이션 기준 상대 경로)
        jsp_path = self._extract_jsp_path(file_path)
        
        # 라인 번호 추출
        line_start = 1
        line_end = jsp_content.count('\n') + 1
        
        # 해시 값 생성 (메모리 효율적)
        hash_value = HashUtils().generate_md5(jsp_content)
        
        # 메모리 최적화: JSP 내용 즉시 해제
        del jsp_content
        
        return {
            'jsp_name': jsp_name,
            'jsp_path': jsp_path,
            'line_start': line_start,
            'line_end': line_end,
            'hash_value': hash_value
        }
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"JSP 컴포넌트 정보 추출 실패: {str(e)}")
        return None
```

### 3.2 분석 결과 즉시 해제

```python
def _analyze_java_method_calls(self, jsp_content: str) -> List[Dict[str, Any]]:
    """
    JSP 파일에서 Java 메서드 호출 분석 (메모리 최적화)
    
    Args:
        jsp_content: JSP 파일 내용
        
    Returns:
        Java 메서드 호출 관계 정보 리스트
    """
    try:
        method_calls = []
        
        # 1. 스크립틀릿 분석
        scriptlet_method_calls = self._analyze_scriptlets(jsp_content)
        method_calls.extend(scriptlet_method_calls)
        
        # 2. 표현식 분석
        expression_method_calls = self._analyze_expressions(jsp_content)
        method_calls.extend(expression_method_calls)
        
        # 3. EL 분석
        el_method_calls = self._analyze_el_expressions(jsp_content)
        method_calls.extend(el_method_calls)
        
        # 4. JSTL 분석
        jstl_method_calls = self._analyze_jstl_tags(jsp_content)
        method_calls.extend(jstl_method_calls)
        
        # 5. 중복 제거
        unique_method_calls = self._remove_duplicate_method_calls(method_calls)
        
        # 메모리 최적화: 중간 결과 즉시 해제
        del method_calls
        del scriptlet_method_calls
        del expression_method_calls
        del el_method_calls
        del jstl_method_calls
        
        return unique_method_calls
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"Java 메서드 호출 분석 실패: {str(e)}")
        return []
```

## 4. 배치 저장 최적화

### 4.1 JSP 컴포넌트 배치 저장

```python
def _save_jsp_components_to_database(self, jsp_components: List[Dict[str, Any]]) -> bool:
    """
    JSP 컴포넌트를 components 테이블에 저장 (배치 처리)
    
    Args:
        jsp_components: JSP 컴포넌트 정보 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not jsp_components:
            warning("저장할 JSP 컴포넌트가 없습니다")
            return True
        
        # 프로젝트 ID 조회 (USER RULES: 공통함수 사용)
        project_id = self._get_project_id()
        if not project_id:
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "JSP 컴포넌트 저장 실패")
            return False
        
        # JSP 데이터 변환 (메모리 효율적)
        jsp_data_list = []
        for jsp_info in jsp_components:
            # 파일 ID 조회
            file_id = self._get_file_id(jsp_info['file_path'])
            if not file_id:
                warning(f"파일 ID를 찾을 수 없습니다: {jsp_info['file_path']}")
                continue
            
            jsp_data = {
                'project_id': project_id,
                'component_type': 'JSP',
                'component_name': jsp_info['jsp_name'],
                'parent_id': None,  # JSP는 독립적인 컴포넌트
                'file_id': file_id,
                'line_start': jsp_info['line_start'],
                'line_end': jsp_info['line_end'],
                'hash_value': jsp_info['hash_value'],
                'has_error': 'N',
                'error_message': None,
                'del_yn': 'N'
            }
            jsp_data_list.append(jsp_data)
        
        # 배치 저장 (USER RULES: 공통함수 사용)
        if jsp_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('components', jsp_data_list)
            if processed_count > 0:
                info(f"JSP 컴포넌트 저장 완료: {processed_count}개")
                
                # 메모리 최적화: 저장 후 즉시 해제
                del jsp_data_list
                return True
            else:
                handle_error(Exception("JSP 컴포넌트 저장 실패"), "JSP 컴포넌트 저장 실패")
                return False
        else:
            warning("저장할 유효한 JSP 컴포넌트가 없습니다")
            return True
            
    except Exception as e:
        handle_error(e, "JSP 컴포넌트 저장 실패")
        return False
```

### 4.2 JSP → METHOD 관계 배치 저장

```python
def _save_jsp_method_relationships_to_database(self, relationships: List[Dict[str, Any]]) -> bool:
    """
    JSP → METHOD 관계를 relationships 테이블에 저장 (배치 처리)
    
    Args:
        relationships: JSP → METHOD 관계 정보 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not relationships:
            warning("저장할 JSP → METHOD 관계가 없습니다")
            return True
        
        # 프로젝트 ID 조회 (USER RULES: 공통함수 사용)
        project_id = self._get_project_id()
        if not project_id:
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "JSP → METHOD 관계 저장 실패")
            return False
        
        # 관계 데이터 변환 (메모리 효율적)
        relationship_data_list = []
        for rel_info in relationships:
            # JSP 컴포넌트 ID 조회
            jsp_component_id = self._get_jsp_component_id(project_id, rel_info['jsp_name'])
            if not jsp_component_id:
                warning(f"JSP 컴포넌트 ID를 찾을 수 없습니다: {rel_info['jsp_name']}")
                continue
            
            # METHOD 컴포넌트 ID 조회
            method_component_id = self._get_method_component_id(
                project_id, rel_info['class_name'], rel_info['method_name']
            )
            if not method_component_id:
                warning(f"METHOD 컴포넌트 ID를 찾을 수 없습니다: {rel_info['class_name']}.{rel_info['method_name']}")
                continue
            
            relationship_data = {
                'src_id': jsp_component_id,
                'dst_id': method_component_id,
                'rel_type': 'CALL_METHOD',
                'confidence': 1.0,
                'has_error': 'N',
                'error_message': None,
                'hash_value': '-',  # USER RULES: 하드코딩된 '-'
                'del_yn': 'N'
            }
            relationship_data_list.append(relationship_data)
        
        # 배치 저장 (USER RULES: 공통함수 사용)
        if relationship_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('relationships', relationship_data_list)
            if processed_count > 0:
                info(f"JSP → METHOD 관계 저장 완료: {processed_count}개")
                
                # 메모리 최적화: 저장 후 즉시 해제
                del relationship_data_list
                return True
            else:
                handle_error(Exception("JSP → METHOD 관계 저장 실패"), "JSP → METHOD 관계 저장 실패")
                return False
        else:
            warning("저장할 유효한 JSP → METHOD 관계가 없습니다")
            return True
            
    except Exception as e:
        handle_error(e, "JSP → METHOD 관계 저장 실패")
        return False
```

## 5. 정규식 기반 파싱 최적화

### 5.1 정규식 패턴 최적화

```python
def _optimize_regex_patterns(self) -> Dict[str, List[str]]:
    """
    정규식 패턴 최적화
    
    Returns:
        최적화된 정규식 패턴 딕셔너리
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        config = self.config
        
        # 정규식 패턴 최적화
        optimized_patterns = {
            'jsp_scriptlet_patterns': [
                r'<%([^%]+)%>',  # 스크립틀릿 (최적화된 패턴)
            ],
            'jsp_expression_patterns': [
                r'<%=([^%]+)%>',  # 표현식 (최적화된 패턴)
            ],
            'jsp_el_patterns': [
                r'\$\{([^}]+)\}',  # EL 표현식 (최적화된 패턴)
            ],
            'jsp_jstl_patterns': [
                r'<c:([^>]+)>',  # JSTL Core (최적화된 패턴)
                r'<fmt:([^>]+)>',  # JSTL Formatting (최적화된 패턴)
                r'<sql:([^>]+)>',  # JSTL SQL (최적화된 패턴)
            ],
            'java_method_call_patterns': [
                r'(\w+)\.(\w+)\s*\(',  # object.method() (최적화된 패턴)
                r'(\w+)\s*\([^)]*\)',  # method() (최적화된 패턴)
            ]
        }
        
        return optimized_patterns
        
    except Exception as e:
        warning(f"정규식 패턴 최적화 실패: {str(e)}")
        return self._get_default_config()
```

### 5.2 메모리 효율적 정규식 매칭

```python
def _extract_method_calls_efficiently(self, content: str, pattern: str) -> List[Dict[str, Any]]:
    """
    메모리 효율적인 정규식 매칭
    
    Args:
        content: 분석할 내용
        pattern: 정규식 패턴
        
    Returns:
        메서드 호출 정보 리스트
    """
    try:
        method_calls = []
        
        # 메모리 효율적인 정규식 매칭
        # re.finditer()를 사용하여 메모리 효율성 확보
        matches = re.finditer(pattern, content, re.MULTILINE | re.DOTALL)
        
        for match in matches:
            try:
                # 매칭 결과 즉시 처리
                method_call_info = self._parse_method_call(match, 0)
                if method_call_info:
                    method_calls.append(method_call_info)
                    
                # 메모리 최적화: 매칭 결과 즉시 해제
                del match
                
            except Exception as e:
                warning(f"메서드 호출 파싱 실패: {str(e)}")
                continue
        
        return method_calls
        
    except Exception as e:
        warning(f"메모리 효율적 정규식 매칭 실패: {str(e)}")
        return []
```

## 6. 메모리 모니터링

### 6.1 메모리 사용량 모니터링

```python
def _monitor_memory_usage(self) -> Dict[str, Any]:
    """
    메모리 사용량 모니터링
    
    Returns:
        메모리 사용량 정보
    """
    try:
        import psutil
        import os
        
        # 현재 프로세스 정보
        process = psutil.Process(os.getpid())
        
        # 메모리 사용량 정보
        memory_info = {
            'rss': process.memory_info().rss,  # 물리 메모리 사용량
            'vms': process.memory_info().vms,  # 가상 메모리 사용량
            'percent': process.memory_percent(),  # 메모리 사용률
            'available': psutil.virtual_memory().available,  # 사용 가능한 메모리
            'total': psutil.virtual_memory().total  # 전체 메모리
        }
        
        return memory_info
        
    except Exception as e:
        warning(f"메모리 사용량 모니터링 실패: {str(e)}")
        return {}

def _log_memory_usage(self, stage: str):
    """
    메모리 사용량 로깅
    
    Args:
        stage: 처리 단계
    """
    try:
        memory_info = self._monitor_memory_usage()
        if memory_info:
            info(f"[{stage}] 메모리 사용량: {memory_info['rss'] / 1024 / 1024:.2f}MB "
                 f"({memory_info['percent']:.1f}%)")
            
            # 메모리 사용률이 80% 이상이면 경고
            if memory_info['percent'] > 80:
                warning(f"[{stage}] 메모리 사용률이 높습니다: {memory_info['percent']:.1f}%")
                
    except Exception as e:
        warning(f"메모리 사용량 로깅 실패: {str(e)}")
```

### 6.2 메모리 사용량 로깅

```python
def execute_jsp_loading(self) -> bool:
    """
    JSP 로딩 실행: 6단계 처리 (메모리 모니터링 포함)
    
    Returns:
        실행 성공 여부
    """
    try:
        info("=== JSP 로딩 시작: 6단계 처리 ===")
        
        # 메모리 사용량 모니터링
        self._log_memory_usage("시작")
        
        # 데이터베이스 연결 (USER RULES: 공통함수 사용)
        self.db_utils = DatabaseUtils(self.metadata_db_path)
        if not self.db_utils.connect():
            error("메타데이터베이스 연결 실패")
            return False
        
        # 1. JSP 파일 수집
        jsp_files = self.jsp_parser.get_filtered_jsp_files(self.project_source_path)
        if not jsp_files:
            warning("JSP 파일이 없습니다")
            return True
        
        # 메모리 사용량 모니터링
        self._log_memory_usage("파일 수집 완료")
        
        # 2. JSP 파일별 스트리밍 처리 (메모리 최적화)
        for i, jsp_file in enumerate(jsp_files):
            try:
                # 메모리 사용량 모니터링 (10개 파일마다)
                if i % 10 == 0:
                    self._log_memory_usage(f"파일 처리 중 ({i+1}/{len(jsp_files)})")
                
                # 메모리 최적화: 한 파일씩만 메모리에 로드하여 처리
                analysis_result = self.jsp_parser.parse_jsp_file(jsp_file)
                
                # 파싱 에러 체크 (USER RULES: 파싱 에러는 계속 진행)
                if analysis_result.get('has_error') == 'Y':
                    warning(f"JSP 파싱 에러로 건너뜀: {jsp_file} - {analysis_result.get('error_message', '')}")
                    self.stats['errors'] += 1
                    continue
                
                # JSP 컴포넌트 저장
                if analysis_result['jsp_component']:
                    try:
                        if self._save_jsp_components_to_database([analysis_result['jsp_component']]):
                            self.stats['jsp_components_created'] += 1
                    except Exception as e:
                        handle_error(e, f"JSP 컴포넌트 저장 실패: {jsp_file}")
                        return False
                
                # JSP → METHOD 관계 저장
                if analysis_result['java_method_relationships']:
                    try:
                        if self._save_jsp_method_relationships_to_database(analysis_result['java_method_relationships']):
                            self.stats['jsp_method_relationships_created'] += len(analysis_result['java_method_relationships'])
                    except Exception as e:
                        handle_error(e, f"JSP → METHOD 관계 저장 실패: {jsp_file}")
                        return False
                
                self.stats['jsp_files_processed'] += 1
                
                # 메모리 최적화: 처리 후 즉시 해제
                del analysis_result
                
            except Exception as e:
                # 시스템 에러 (데이터베이스, 메모리 등) - 프로그램 종료
                handle_error(e, f"JSP 파일 처리 실패: {jsp_file}")
                return False
        
        # 메모리 사용량 모니터링
        self._log_memory_usage("처리 완료")
        
        # 3. 통계 정보 출력
        self._print_jsp_loading_statistics()
        
        info("=== JSP 로딩 완료 ===")
        return True
        
    except Exception as e:
        handle_error(e, "JSP 로딩 실행 실패")
        return False
    finally:
        # 데이터베이스 연결 해제
        if self.db_utils:
            self.db_utils.disconnect()
```

## 7. 다음 단계

다음 문서에서는 오류 처리 및 예외 상황을 제시합니다:
- [6. 오류 처리 및 예외 상황](./20250914_023100_6단계개발계획서_06_오류처리.md)
