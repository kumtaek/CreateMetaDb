# 4단계 개발계획서 - 오류 처리 및 예외 상황 대응 방안

## 문서 정보
- **작성일**: 2025-01-13 23:55:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서
- **대상 단계**: 4단계 - 오류 처리 및 예외 상황 대응

## 1. 오류 처리 개요

### 1.1 오류 처리 원칙
- **파싱 오류**: `has_error='Y'`, `error_message` 저장 후 계속 실행
- **시스템 오류**: `handle_error()` 호출 후 즉시 종료
- **경고 메시지**: 계속 실행하지 않고 적절한 조치 후 종료
- **예외 상황**: 명확한 오류 메시지와 함께 적절한 처리

### 1.2 오류 분류
```
1. 파싱 오류 (Parsing Errors)
   - Java 파일 구문 오류
   - 인코딩 문제
   - 파일 손상
   → has_error='Y', error_message 저장, 계속 실행

2. 시스템 오류 (System Errors)
   - 데이터베이스 연결 실패
   - 메모리 부족
   - 파일 시스템 오류
   → handle_error() 호출, 즉시 종료

3. 설정 오류 (Configuration Errors)
   - 설정 파일 누락
   - 잘못된 설정 값
   → handle_error() 호출, 즉시 종료

4. 데이터 오류 (Data Errors)
   - 중복 데이터
   - 잘못된 데이터 형식
   → 경고 후 계속 실행 또는 적절한 처리
```

## 2. 파싱 오류 처리

### 2.1 Java 파일 파싱 오류

```python
def parse_java_file(self, java_file: str) -> Optional[Dict[str, Any]]:
    """
    Java 파일 파싱 (오류 처리 포함)
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        분석 결과 또는 None
    """
    try:
        # 1. 파일 읽기 시도
        java_content = self._read_java_file_safe(java_file)
        if not java_content:
            return self._create_error_result(java_file, "파일 읽기 실패")
        
        # 2. 클래스 추출 시도
        classes = self._extract_classes_safe(java_content, java_file)
        
        # 3. 메서드 추출 시도
        methods = self._extract_methods_safe(java_content, java_file)
        
        # 4. 상속 관계 분석 시도
        relationships = self._analyze_inheritance_safe(java_content, java_file)
        
        # 5. 결과 반환
        return {
            'file_path': java_file,
            'classes': classes,
            'methods': methods,
            'inheritance_relationships': relationships,
            'has_error': 'N',
            'error_message': None
        }
        
    except Exception as e:
        # 파싱 오류는 계속 실행
        warning(f"Java 파일 파싱 오류: {java_file} - {str(e)}")
        return self._create_error_result(java_file, str(e))

def _read_java_file_safe(self, java_file: str) -> Optional[str]:
    """
    안전한 Java 파일 읽기
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        파일 내용 또는 None
    """
    try:
        # USER RULES: 공통함수 사용
        file_utils = FileUtils()
        
        # 파일 존재 확인
        if not os.path.exists(java_file):
            warning(f"파일이 존재하지 않음: {java_file}")
            return None
        
        # 파일 크기 확인
        file_size = os.path.getsize(java_file)
        if file_size == 0:
            warning(f"빈 파일: {java_file}")
            return None
        
        # 인코딩 시도
        encodings = ['utf-8', 'cp949', 'euc-kr', 'latin-1']
        for encoding in encodings:
            try:
                content = file_utils.read_file(java_file, encoding=encoding)
                if content:
                    return content
            except UnicodeDecodeError:
                continue
        
        warning(f"인코딩 실패: {java_file}")
        return None
        
    except Exception as e:
        warning(f"파일 읽기 오류: {java_file} - {str(e)}")
        return None

def _extract_classes_safe(self, java_content: str, java_file: str) -> List[Dict[str, Any]]:
    """
    안전한 클래스 추출
    
    Args:
        java_content: Java 파일 내용
        java_file: Java 파일 경로
        
    Returns:
        클래스 정보 리스트
    """
    try:
        classes = []
        
        # 정규식 패턴으로 클래스 추출
        for pattern in self.compiled_class_patterns:
            try:
                matches = pattern.findall(java_content)
                for match in matches:
                    if isinstance(match, tuple):
                        class_info = self._parse_class_match(match, java_file)
                    else:
                        class_info = self._parse_class_match([match], java_file)
                    
                    if class_info:
                        classes.append(class_info)
                        
            except Exception as e:
                warning(f"클래스 추출 패턴 오류: {str(e)}")
                continue
        
        return classes
        
    except Exception as e:
        warning(f"클래스 추출 오류: {java_file} - {str(e)}")
        return []

def _create_error_result(self, java_file: str, error_message: str) -> Dict[str, Any]:
    """
    오류 결과 생성
    
    Args:
        java_file: Java 파일 경로
        error_message: 오류 메시지
        
    Returns:
        오류 결과 딕셔너리
    """
    return {
        'file_path': java_file,
        'classes': [],
        'methods': [],
        'inheritance_relationships': [],
        'has_error': 'Y',
        'error_message': error_message
    }
```

### 2.2 정규식 패턴 오류 처리

```python
def _compile_patterns_safe(self):
    """안전한 정규식 패턴 컴파일"""
    try:
        # 클래스 추출 패턴 컴파일
        class_patterns = self.config.get('java_class_extraction_patterns', [])
        self.compiled_class_patterns = []
        
        for pattern in class_patterns:
            try:
                compiled_pattern = re.compile(pattern, re.MULTILINE)
                self.compiled_class_patterns.append(compiled_pattern)
            except re.error as e:
                warning(f"정규식 패턴 컴파일 실패: {pattern} - {str(e)}")
                continue
        
        # 메서드 필터링 패턴 컴파일
        method_patterns = self.config.get('method_filter_patterns', {})
        exclude_patterns = method_patterns.get('exclude_patterns', [])
        include_patterns = method_patterns.get('include_patterns', [])
        
        self.compiled_exclude_patterns = []
        for pattern in exclude_patterns:
            try:
                compiled_pattern = re.compile(pattern, re.IGNORECASE)
                self.compiled_exclude_patterns.append(compiled_pattern)
            except re.error as e:
                warning(f"제외 패턴 컴파일 실패: {pattern} - {str(e)}")
                continue
        
        self.compiled_include_patterns = []
        for pattern in include_patterns:
            try:
                compiled_pattern = re.compile(pattern, re.IGNORECASE)
                self.compiled_include_patterns.append(compiled_pattern)
            except re.error as e:
                warning(f"포함 패턴 컴파일 실패: {pattern} - {str(e)}")
                continue
        
        info(f"정규식 패턴 컴파일 완료: 클래스 {len(self.compiled_class_patterns)}개, "
             f"제외 {len(self.compiled_exclude_patterns)}개, "
             f"포함 {len(self.compiled_include_patterns)}개")
        
    except Exception as e:
        warning(f"정규식 패턴 컴파일 전체 실패: {str(e)}")
        self.compiled_class_patterns = []
        self.compiled_exclude_patterns = []
        self.compiled_include_patterns = []
```

## 3. 시스템 오류 처리

### 3.1 데이터베이스 오류 처리

```python
def _save_classes_to_database(self, classes: List[Dict[str, Any]]) -> bool:
    """
    클래스 정보 데이터베이스 저장 (오류 처리 포함)
    
    Args:
        classes: 클래스 정보 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not classes:
            return True
        
        # USER RULES: 공통함수 사용
        db_utils = DatabaseUtils()
        
        # 데이터베이스 연결 확인
        if not db_utils.is_connected():
            handle_error("데이터베이스 연결이 끊어졌습니다.")
            return False
        
        # 배치 저장
        batch_size = 100
        for i in range(0, len(classes), batch_size):
            batch = classes[i:i + batch_size]
            
            try:
                # 클래스 정보 저장
                for class_info in batch:
                    self._save_single_class_safe(class_info)
                
                # 트랜잭션 커밋
                db_utils.commit()
                
            except Exception as e:
                # 배치 저장 실패 시 롤백
                db_utils.rollback()
                warning(f"클래스 배치 저장 실패: {str(e)}")
                continue
        
        return True
        
    except Exception as e:
        handle_error(e, "클래스 데이터베이스 저장 실패")
        return False

def _save_single_class_safe(self, class_info: Dict[str, Any]) -> bool:
    """
    단일 클래스 정보 안전 저장
    
    Args:
        class_info: 클래스 정보
        
    Returns:
        저장 성공 여부
    """
    try:
        # 필수 필드 검증
        required_fields = ['class_name', 'package_name', 'file_path']
        for field in required_fields:
            if field not in class_info or not class_info[field]:
                warning(f"클래스 정보 필수 필드 누락: {field}")
                return False
        
        # 중복 확인
        if self._is_class_duplicate(class_info):
            warning(f"중복 클래스: {class_info['class_name']}")
            return False
        
        # 데이터베이스 저장
        db_utils = DatabaseUtils()
        query = """
        INSERT INTO classes (
            class_name, package_name, file_path, class_type, 
            access_modifier, is_abstract, is_final, is_interface,
            super_class, interfaces, annotations, line_start, line_end,
            project_id, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        values = (
            class_info['class_name'],
            class_info['package_name'],
            class_info['file_path'],
            class_info.get('class_type', 'class'),
            class_info.get('access_modifier', 'package'),
            class_info.get('is_abstract', False),
            class_info.get('is_final', False),
            class_info.get('is_interface', False),
            class_info.get('super_class'),
            class_info.get('interfaces'),
            class_info.get('annotations'),
            class_info.get('line_start'),
            class_info.get('line_end'),
            self.project_id,
            datetime.now()
        )
        
        db_utils.execute_query(query, values)
        return True
        
    except Exception as e:
        warning(f"단일 클래스 저장 실패: {str(e)}")
        return False
```

### 3.2 파일 시스템 오류 처리

```python
def _get_filtered_java_files_safe(self, project_source_path: str) -> List[str]:
    """
    안전한 Java 파일 수집
    
    Args:
        project_source_path: 프로젝트 소스 경로
        
    Returns:
        Java 파일 경로 리스트
    """
    try:
        # USER RULES: 공통함수 사용
        path_utils = PathUtils()
        
        # 프로젝트 경로 검증
        if not os.path.exists(project_source_path):
            handle_error(f"프로젝트 소스 경로가 존재하지 않습니다: {project_source_path}")
            return []
        
        if not os.path.isdir(project_source_path):
            handle_error(f"프로젝트 소스 경로가 디렉토리가 아닙니다: {project_source_path}")
            return []
        
        # Java 파일 수집
        java_files = []
        for root, dirs, files in os.walk(project_source_path):
            # 숨김 디렉토리 제외
            dirs[:] = [d for d in dirs if not d.startswith('.')]
            
            for file in files:
                if file.endswith('.java'):
                    file_path = os.path.join(root, file)
                    
                    # 파일 접근 권한 확인
                    if not os.access(file_path, os.R_OK):
                        warning(f"파일 읽기 권한 없음: {file_path}")
                        continue
                    
                    # 파일 크기 확인
                    try:
                        file_size = os.path.getsize(file_path)
                        if file_size == 0:
                            warning(f"빈 파일: {file_path}")
                            continue
                        
                        if file_size > 100 * 1024 * 1024:  # 100MB 이상
                            warning(f"대용량 파일: {file_path} ({file_size/1024/1024:.1f}MB)")
                            continue
                        
                    except OSError as e:
                        warning(f"파일 크기 확인 실패: {file_path} - {str(e)}")
                        continue
                    
                    java_files.append(file_path)
        
        info(f"Java 파일 수집 완료: {len(java_files)}개")
        return java_files
        
    except Exception as e:
        handle_error(e, "Java 파일 수집 실패")
        return []
```

## 4. 설정 오류 처리

### 4.1 설정 파일 검증

```python
def _validate_configuration(self) -> bool:
    """
    설정 파일 검증
    
    Returns:
        검증 성공 여부
    """
    try:
        # USER RULES: 공통함수 사용
        config_utils = ConfigUtils()
        
        # 설정 파일 존재 확인
        if not os.path.exists(self.config_path):
            handle_error(f"설정 파일이 존재하지 않습니다: {self.config_path}")
            return False
        
        # 설정 파일 읽기
        try:
            self.config = config_utils.load_config(self.config_path)
        except Exception as e:
            handle_error(e, f"설정 파일 읽기 실패: {self.config_path}")
            return False
        
        # 필수 설정 검증
        required_sections = [
            'java_class_extraction_patterns',
            'method_filter_patterns',
            'business_domain_patterns',
            'architecture_layer_patterns'
        ]
        
        for section in required_sections:
            if section not in self.config:
                handle_error(f"필수 설정 섹션이 누락되었습니다: {section}")
                return False
        
        # 설정 값 검증
        if not self._validate_config_values():
            return False
        
        info("설정 파일 검증 완료")
        return True
        
    except Exception as e:
        handle_error(e, "설정 파일 검증 실패")
        return False

def _validate_config_values(self) -> bool:
    """
    설정 값 검증
    
    Returns:
        검증 성공 여부
    """
    try:
        # 클래스 추출 패턴 검증
        class_patterns = self.config.get('java_class_extraction_patterns', [])
        if not isinstance(class_patterns, list) or len(class_patterns) == 0:
            handle_error("java_class_extraction_patterns가 비어있거나 리스트가 아닙니다.")
            return False
        
        # 메서드 필터링 패턴 검증
        method_patterns = self.config.get('method_filter_patterns', {})
        if not isinstance(method_patterns, dict):
            handle_error("method_filter_patterns가 딕셔너리가 아닙니다.")
            return False
        
        # 비즈니스 도메인 패턴 검증
        domain_patterns = self.config.get('business_domain_patterns', {})
        if not isinstance(domain_patterns, dict):
            handle_error("business_domain_patterns가 딕셔너리가 아닙니다.")
            return False
        
        # 아키텍처 레이어 패턴 검증
        layer_patterns = self.config.get('architecture_layer_patterns', {})
        if not isinstance(layer_patterns, dict):
            handle_error("architecture_layer_patterns가 딕셔너리가 아닙니다.")
            return False
        
        return True
        
    except Exception as e:
        handle_error(e, "설정 값 검증 실패")
        return False
```

### 4.2 프로젝트 설정 검증

```python
def _validate_project_configuration(self) -> bool:
    """
    프로젝트 설정 검증
    
    Returns:
        검증 성공 여부
    """
    try:
        # USER RULES: 공통함수 사용
        global_project = global_project
        
        # 프로젝트명 검증
        if not self.project_name:
            handle_error("프로젝트명이 설정되지 않았습니다.")
            return False
        
        if not isinstance(self.project_name, str) or len(self.project_name.strip()) == 0:
            handle_error("프로젝트명이 유효하지 않습니다.")
            return False
        
        # 프로젝트 ID 검증
        if not hasattr(global_project, 'project_id') or not global_project.project_id:
            handle_error("프로젝트 ID가 설정되지 않았습니다.")
            return False
        
        # 프로젝트 소스 경로 검증
        if not self.project_source_path:
            handle_error("프로젝트 소스 경로가 설정되지 않았습니다.")
            return False
        
        if not os.path.exists(self.project_source_path):
            handle_error(f"프로젝트 소스 경로가 존재하지 않습니다: {self.project_source_path}")
            return False
        
        if not os.path.isdir(self.project_source_path):
            handle_error(f"프로젝트 소스 경로가 디렉토리가 아닙니다: {self.project_source_path}")
            return False
        
        info(f"프로젝트 설정 검증 완료: {self.project_name}")
        return True
        
    except Exception as e:
        handle_error(e, "프로젝트 설정 검증 실패")
        return False
```

## 5. 데이터 오류 처리

### 5.1 중복 데이터 처리

```python
def _is_class_duplicate(self, class_info: Dict[str, Any]) -> bool:
    """
    클래스 중복 확인
    
    Args:
        class_info: 클래스 정보
        
    Returns:
        중복 여부
    """
    try:
        db_utils = DatabaseUtils()
        query = """
        SELECT COUNT(*) FROM classes 
        WHERE class_name = ? AND package_name = ? AND project_id = ?
        """
        
        result = db_utils.fetch_one(query, (
            class_info['class_name'],
            class_info['package_name'],
            self.project_id
        ))
        
        return result[0] > 0 if result else False
        
    except Exception as e:
        warning(f"클래스 중복 확인 실패: {str(e)}")
        return False

def _is_method_duplicate(self, method_info: Dict[str, Any]) -> bool:
    """
    메서드 중복 확인
    
    Args:
        method_info: 메서드 정보
        
    Returns:
        중복 여부
    """
    try:
        db_utils = DatabaseUtils()
        query = """
        SELECT COUNT(*) FROM components 
        WHERE component_name = ? AND component_type = 'METHOD' 
        AND parent_component_id = ? AND project_id = ?
        """
        
        result = db_utils.fetch_one(query, (
            method_info['method_name'],
            method_info['class_id'],
            self.project_id
        ))
        
        return result[0] > 0 if result else False
        
    except Exception as e:
        warning(f"메서드 중복 확인 실패: {str(e)}")
        return False
```

### 5.2 데이터 형식 검증

```python
def _validate_class_info(self, class_info: Dict[str, Any]) -> bool:
    """
    클래스 정보 형식 검증
    
    Args:
        class_info: 클래스 정보
        
    Returns:
        검증 성공 여부
    """
    try:
        # 필수 필드 검증
        required_fields = ['class_name', 'package_name', 'file_path']
        for field in required_fields:
            if field not in class_info:
                warning(f"클래스 정보 필수 필드 누락: {field}")
                return False
            
            if not isinstance(class_info[field], str) or len(class_info[field].strip()) == 0:
                warning(f"클래스 정보 필드 형식 오류: {field}")
                return False
        
        # 클래스명 형식 검증
        class_name = class_info['class_name']
        if not re.match(r'^[A-Za-z_$][A-Za-z0-9_$]*$', class_name):
            warning(f"클래스명 형식 오류: {class_name}")
            return False
        
        # 패키지명 형식 검증
        package_name = class_info['package_name']
        if package_name and not re.match(r'^[a-z][a-z0-9]*(\.[a-z][a-z0-9]*)*$', package_name):
            warning(f"패키지명 형식 오류: {package_name}")
            return False
        
        # 라인 번호 검증
        line_start = class_info.get('line_start')
        line_end = class_info.get('line_end')
        
        if line_start is not None and (not isinstance(line_start, int) or line_start < 1):
            warning(f"시작 라인 번호 형식 오류: {line_start}")
            return False
        
        if line_end is not None and (not isinstance(line_end, int) or line_end < 1):
            warning(f"종료 라인 번호 형식 오류: {line_end}")
            return False
        
        if line_start and line_end and line_start > line_end:
            warning(f"라인 번호 범위 오류: {line_start} > {line_end}")
            return False
        
        return True
        
    except Exception as e:
        warning(f"클래스 정보 검증 실패: {str(e)}")
        return False

def _validate_method_info(self, method_info: Dict[str, Any]) -> bool:
    """
    메서드 정보 형식 검증
    
    Args:
        method_info: 메서드 정보
        
    Returns:
        검증 성공 여부
    """
    try:
        # 필수 필드 검증
        required_fields = ['method_name', 'class_id']
        for field in required_fields:
            if field not in method_info:
                warning(f"메서드 정보 필수 필드 누락: {field}")
                return False
        
        # 메서드명 형식 검증
        method_name = method_info['method_name']
        if not isinstance(method_name, str) or len(method_name.strip()) == 0:
            warning(f"메서드명 형식 오류: {method_name}")
            return False
        
        # 클래스 ID 검증
        class_id = method_info['class_id']
        if not isinstance(class_id, int) or class_id <= 0:
            warning(f"클래스 ID 형식 오류: {class_id}")
            return False
        
        # 반환 타입 검증
        return_type = method_info.get('return_type')
        if return_type and not isinstance(return_type, str):
            warning(f"반환 타입 형식 오류: {return_type}")
            return False
        
        # 매개변수 검증
        parameters = method_info.get('parameters', [])
        if not isinstance(parameters, list):
            warning(f"매개변수 형식 오류: {parameters}")
            return False
        
        return True
        
    except Exception as e:
        warning(f"메서드 정보 검증 실패: {str(e)}")
        return False
```

## 6. 복구 및 재시도 메커니즘

### 6.1 데이터베이스 연결 복구

```python
def _ensure_database_connection(self) -> bool:
    """
    데이터베이스 연결 보장
    
    Returns:
        연결 성공 여부
    """
    try:
        db_utils = DatabaseUtils()
        
        # 연결 상태 확인
        if db_utils.is_connected():
            return True
        
        # 재연결 시도
        max_retries = 3
        for attempt in range(max_retries):
            try:
                info(f"데이터베이스 재연결 시도 {attempt + 1}/{max_retries}")
                db_utils.connect()
                
                if db_utils.is_connected():
                    info("데이터베이스 재연결 성공")
                    return True
                
            except Exception as e:
                warning(f"데이터베이스 재연결 실패 {attempt + 1}: {str(e)}")
                if attempt < max_retries - 1:
                    time.sleep(2 ** attempt)  # 지수 백오프
                continue
        
        handle_error("데이터베이스 재연결 최종 실패")
        return False
        
    except Exception as e:
        handle_error(e, "데이터베이스 연결 확인 실패")
        return False
```

### 6.2 파일 처리 재시도

```python
def _process_file_with_retry(self, java_file: str, max_retries: int = 3) -> Optional[Dict[str, Any]]:
    """
    재시도 메커니즘이 포함된 파일 처리
    
    Args:
        java_file: Java 파일 경로
        max_retries: 최대 재시도 횟수
        
    Returns:
        분석 결과 또는 None
    """
    for attempt in range(max_retries):
        try:
            # 파일 처리 시도
            result = self._process_single_java_file(java_file)
            if result:
                return result
            
        except Exception as e:
            warning(f"파일 처리 실패 {attempt + 1}/{max_retries}: {java_file} - {str(e)}")
            
            if attempt < max_retries - 1:
                # 재시도 전 대기
                time.sleep(1)
                continue
            else:
                # 최종 실패
                warning(f"파일 처리 최종 실패: {java_file}")
                return self._create_error_result(java_file, f"재시도 실패: {str(e)}")
    
    return None
```

## 7. 오류 로깅 및 모니터링

### 7.1 상세 오류 로깅

```python
def _log_parsing_error(self, java_file: str, error: Exception, context: str = ""):
    """
    파싱 오류 상세 로깅
    
    Args:
        java_file: Java 파일 경로
        error: 발생한 오류
        context: 오류 발생 컨텍스트
    """
    try:
        error_info = {
            'timestamp': datetime.now().isoformat(),
            'file_path': java_file,
            'error_type': type(error).__name__,
            'error_message': str(error),
            'context': context,
            'project_name': self.project_name,
            'project_id': self.project_id
        }
        
        # 오류 로그 파일에 기록
        error_log_path = os.path.join(self.temp_dir, f"java_parsing_errors_{datetime.now().strftime('%Y%m%d')}.log")
        
        with open(error_log_path, 'a', encoding='utf-8') as f:
            f.write(json.dumps(error_info, ensure_ascii=False) + '\n')
        
        # 일반 로그에도 기록
        warning(f"파싱 오류: {java_file} - {str(error)}")
        
    except Exception as e:
        warning(f"오류 로깅 실패: {str(e)}")

def _log_system_error(self, error: Exception, context: str = ""):
    """
    시스템 오류 상세 로깅
    
    Args:
        error: 발생한 오류
        context: 오류 발생 컨텍스트
    """
    try:
        error_info = {
            'timestamp': datetime.now().isoformat(),
            'error_type': type(error).__name__,
            'error_message': str(error),
            'context': context,
            'project_name': self.project_name,
            'project_id': self.project_id,
            'traceback': traceback.format_exc()
        }
        
        # 시스템 오류 로그 파일에 기록
        error_log_path = os.path.join(self.temp_dir, f"java_system_errors_{datetime.now().strftime('%Y%m%d')}.log")
        
        with open(error_log_path, 'a', encoding='utf-8') as f:
            f.write(json.dumps(error_info, ensure_ascii=False) + '\n')
        
        # 일반 로그에도 기록
        error(f"시스템 오류: {str(error)}")
        
    except Exception as e:
        warning(f"시스템 오류 로깅 실패: {str(e)}")
```

### 7.2 오류 통계 수집

```python
def _collect_error_statistics(self) -> Dict[str, Any]:
    """
    오류 통계 수집
    
    Returns:
        오류 통계 딕셔너리
    """
    try:
        error_stats = {
            'total_files_processed': self.stats['java_files_processed'],
            'parsing_errors': 0,
            'system_errors': 0,
            'validation_errors': 0,
            'database_errors': 0,
            'file_errors': 0,
            'error_rate': 0.0
        }
        
        # 오류 로그 파일 분석
        error_log_path = os.path.join(self.temp_dir, f"java_parsing_errors_{datetime.now().strftime('%Y%m%d')}.log")
        
        if os.path.exists(error_log_path):
            with open(error_log_path, 'r', encoding='utf-8') as f:
                for line in f:
                    try:
                        error_info = json.loads(line.strip())
                        error_type = error_info.get('error_type', '')
                        
                        if 'UnicodeDecodeError' in error_type:
                            error_stats['file_errors'] += 1
                        elif 'DatabaseError' in error_type:
                            error_stats['database_errors'] += 1
                        elif 'ValidationError' in error_type:
                            error_stats['validation_errors'] += 1
                        else:
                            error_stats['parsing_errors'] += 1
                            
                    except json.JSONDecodeError:
                        continue
        
        # 오류율 계산
        total_errors = sum([
            error_stats['parsing_errors'],
            error_stats['system_errors'],
            error_stats['validation_errors'],
            error_stats['database_errors'],
            error_stats['file_errors']
        ])
        
        if error_stats['total_files_processed'] > 0:
            error_stats['error_rate'] = (total_errors / error_stats['total_files_processed']) * 100
        
        return error_stats
        
    except Exception as e:
        warning(f"오류 통계 수집 실패: {str(e)}")
        return {}
```

## 8. 다음 단계

다음 문서에서는 개발계획서 문서화 및 챕터별 분리를 완료합니다:
- [7. 개발계획서 문서화 및 챕터별 분리](./20250113_235600_4단계개발계획서_문서화완료.md)
