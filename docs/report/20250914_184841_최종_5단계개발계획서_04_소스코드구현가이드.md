# 최종 5단계 개발계획서 - 4장: 소스코드 구현 가이드

## 문서 정보
- **작성일**: 2025-09-14 18:48:41
- **작성자**: AI Assistant
- **문서 유형**: 최종 통합 개발계획서
- **대상 단계**: 5단계 - JSP 파일 분석 및 컴포넌트 등록
- **문서 버전**: v1.0 (최종 통합본)

## 📋 목차

1. [개요 및 요구사항](./20250914_184841_최종_5단계개발계획서_01_개요및요구사항.md)
2. [아키텍처 설계](./20250914_184841_최종_5단계개발계획서_02_아키텍처설계.md)
3. [상세 구현 계획](./20250914_184841_최종_5단계개발계획서_03_상세구현계획.md)
4. [소스코드 구현 가이드](./20250914_184841_최종_5단계개발계획서_04_소스코드구현가이드.md) ← **현재 문서**
5. [테스트 및 검증 계획](./20250914_184841_최종_5단계개발계획서_05_테스트및검증계획.md)

---

## 1. User Rules 준수사항 (반드시 준수)

### 1.1 예외 처리 규칙 (중요!)
- **파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함**
- **파싱에러는 has_error='Y', error_message 저장 후 계속 실행(exit 안함)**
- **그 밖에 warning 후 계속 실행하는 경우는 없음**

### 1.2 공통함수 사용 지향
- **경로관련 함수**: Windows, RHEL 크로스플랫폼 대응
- **중복공통함수 생성 지양**: ./util/ 확인 후 신규 공통함수 개발
- **하드코딩 지양**: 모든 설정은 파일에서 로드

---

## 2. jsp_loading.py 구현

### 2.1 전체 파일 구조
```python
"""
5단계 JSP 파일 분석 및 컴포넌트 등록
- JSP 파일 파싱 및 JSP 컴포넌트 정보 추출
- JSP → Java 메서드 관계 분석
- 메모리 최적화를 통한 스트리밍 처리
"""

import os
import re
from typing import List, Dict, Any, Optional
from util.logger import info, warning, handle_error
from util.database_utils import DatabaseUtils
from util.file_utils import FileUtils
from util.path_utils import PathUtils
from util.config_utils import ConfigUtils
from util.hash_utils import HashUtils
from parser.jsp_parser import JspParser

class JspLoadingEngine:
    """5단계 JSP 로딩 엔진"""
    
    def __init__(self, project_name: str):
        """JSP 로딩 엔진 초기화"""
        try:
            self.project_name = project_name
            
            # USER RULES: 공통함수 사용 지향
            self.path_utils = PathUtils()
            self.config_utils = ConfigUtils()
            
            # 프로젝트 경로 설정 (하드코딩 금지)
            self.project_source_path = self.path_utils.get_project_source_path(project_name)
            self.metadata_db_path = self.path_utils.get_project_metadata_db_path(project_name)
            
            # JSP 파서 초기화
            self.jsp_parser = JspParser(project_name=project_name)
            
            # 통계 정보 초기화
            self.stats = {
                'jsp_files_processed': 0,
                'jsp_components_created': 0,
                'jsp_method_relationships_created': 0,
                'errors': 0
            }
            
            info(f"JSP 로딩 엔진 초기화 완료: {project_name}")
            
        except Exception as e:
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(e, "JSP 로딩 엔진 초기화 실패")
```

### 2.2 execute_jsp_loading() 메서드
```python
def execute_jsp_loading(self) -> bool:
    """5단계 처리 실행"""
    try:
        info("=== JSP 로딩 시작: 5단계 처리 ===")
        
        # 데이터베이스 연결
        self.db_utils = DatabaseUtils(self.metadata_db_path)
        
        # USER RULES: target_source_config.yaml 활용
        target_config = self.config_utils.load_target_source_config(self.project_name)
        
        # JSP 파일 수집
        jsp_files = self.jsp_parser.get_filtered_jsp_files(self.project_source_path, target_config)
        if not jsp_files:
            info("분석할 JSP 파일이 없습니다")
            return True
        
        info(f"JSP 파일 수집 완료: {len(jsp_files)}개")
        
        # JSP 파일별 통합 처리
        for jsp_file in jsp_files:
            try:
                # JSP 파일 파싱
                result = self.jsp_parser.parse_jsp_file(jsp_file)
                
                # JSP 컴포넌트 저장
                if result['jsp_component']:
                    if self._save_jsp_components_to_database([result['jsp_component']]):
                        self.stats['jsp_components_created'] += 1
                
                # JSP → METHOD 관계 저장
                if result['java_method_relationships']:
                    if self._save_jsp_method_relationships_to_database(result['java_method_relationships']):
                        self.stats['jsp_method_relationships_created'] += len(result['java_method_relationships'])
                
                # 오류 통계 업데이트
                if result.get('has_error') == 'Y':
                    self.stats['errors'] += 1
                
                self.stats['jsp_files_processed'] += 1
                
            except Exception as e:
                # USER RULES: 파싱에러는 has_error='Y', error_message 저장 후 계속 실행(exit안함)
                warning(f"JSP 파일 처리 실패: {jsp_file}, 오류: {str(e)}")
                self.stats['errors'] += 1
                continue
        
        # 통계 정보 출력
        self._print_jsp_loading_statistics()
        
        # 데이터베이스 연결 해제
        self.db_utils.close()
        
        info("=== JSP 로딩 완료 ===")
        return True
        
    except Exception as e:
        # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
        handle_error(e, "JSP 로딩 실행 실패")
        return False
```

### 2.3 데이터베이스 저장 메서드들
```python
def _save_jsp_components_to_database(self, jsp_components: List[Dict[str, Any]]) -> bool:
    """JSP 컴포넌트를 components 테이블에 저장"""
    try:
        if not jsp_components:
            return True
        
        # 프로젝트 ID 조회
        project_id = self._get_project_id()
        if not project_id:
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "JSP 컴포넌트 저장 실패")
            return False
        
        # JSP 데이터 변환
        jsp_data_list = []
        for jsp_info in jsp_components:
            if not jsp_info:
                continue
                
            # 파일 ID 조회
            file_id = self._get_file_id(jsp_info['file_path'])
            if not file_id:
                # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
                handle_error(Exception(f"파일 ID를 찾을 수 없습니다: {jsp_info['file_path']}"), "파일 ID 조회 실패")
            
            jsp_data = {
                'project_id': project_id,
                'component_type': 'JSP',
                'component_name': jsp_info['jsp_name'],
                'parent_id': None,
                'file_id': file_id,
                'line_start': jsp_info['line_start'],
                'line_end': jsp_info['line_end'],
                'hash_value': jsp_info['hash_value'],
                'has_error': 'N',
                'error_message': None,
                'del_yn': 'N'
            }
            jsp_data_list.append(jsp_data)
        
        # 배치 저장
        if jsp_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('components', jsp_data_list)
            if processed_count > 0:
                info(f"JSP 컴포넌트 저장 완료: {processed_count}개")
                return True
            else:
                # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
                handle_error(Exception("JSP 컴포넌트 저장 실패"), "JSP 컴포넌트 저장 실패")
                return False
        else:
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(Exception("저장할 유효한 JSP 컴포넌트가 없습니다"), "JSP 컴포넌트 데이터 없음")
            
    except Exception as e:
        # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
        handle_error(e, "JSP 컴포넌트 저장 실패")
        return False

def _save_jsp_method_relationships_to_database(self, relationships: List[Dict[str, Any]]) -> bool:
    """JSP → METHOD 관계를 relationships 테이블에 저장"""
    try:
        if not relationships:
            return True
        
        # 프로젝트 ID 조회
        project_id = self._get_project_id()
        if not project_id:
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "JSP → METHOD 관계 저장 실패")
            return False
        
        # 관계 데이터 변환
        relationship_data_list = []
        for rel_info in relationships:
            # JSP 컴포넌트 ID 조회
            jsp_component_id = self._get_jsp_component_id(project_id, rel_info['jsp_name'])
            if not jsp_component_id:
                # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
                handle_error(Exception(f"JSP 컴포넌트 ID를 찾을 수 없습니다: {rel_info['jsp_name']}"), "JSP 컴포넌트 ID 조회 실패")
            
            # METHOD 컴포넌트 ID 조회
            method_component_id = self._get_method_component_id(
                project_id, rel_info['class_name'], rel_info['method_name']
            )
            if not method_component_id:
                # inferred 메서드 생성
                method_component_id = self._create_inferred_method_component(
                    project_id, rel_info['class_name'], rel_info['method_name']
                )
            
            if not method_component_id:
                # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
                handle_error(Exception(f"METHOD 컴포넌트 ID를 생성할 수 없습니다: {rel_info['class_name']}.{rel_info['method_name']}"), "METHOD 컴포넌트 생성 실패")
            
            relationship_data = {
                'src_id': jsp_component_id,
                'dst_id': method_component_id,
                'rel_type': 'CALL_METHOD',
                'confidence': 1.0,
                'has_error': 'N',
                'error_message': None,
                'hash_value': '-',  # USER RULES: 하드코딩된 '-'
                'del_yn': 'N'
            }
            relationship_data_list.append(relationship_data)
        
        # 배치 저장
        if relationship_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('relationships', relationship_data_list)
            if processed_count > 0:
                info(f"JSP → METHOD 관계 저장 완료: {processed_count}개")
                return True
            else:
                # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
                handle_error(Exception("JSP → METHOD 관계 저장 실패"), "JSP → METHOD 관계 저장 실패")
                return False
        else:
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(Exception("저장할 유효한 JSP → METHOD 관계가 없습니다"), "관계 데이터 없음")
            
    except Exception as e:
        # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
        handle_error(e, "JSP → METHOD 관계 저장 실패")
        return False
```

---

## 3. parser/jsp_parser.py 구현

### 3.1 전체 파일 구조
```python
"""
JSP 파일 파싱 및 분석 로직
- JSP 파일 수집 및 필터링
- JSP 컴포넌트 정보 추출
- Java 메서드 호출 분석
"""

import os
import re
from typing import List, Dict, Any, Optional
from util.logger import info, warning, handle_error
from util.file_utils import FileUtils
from util.path_utils import PathUtils
from util.config_utils import ConfigUtils
from util.hash_utils import HashUtils

class JspParser:
    """JSP 파서 - 5단계 통합 처리"""
    
    def __init__(self, project_name: str):
        """JSP 파서 초기화"""
        try:
            self.project_name = project_name
            
            # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
            self.path_utils = PathUtils()
            self.config_utils = ConfigUtils()
            
            # JSP 키워드 설정 로드
            config_path = self.path_utils.get_jsp_keyword_config_path()
            self.config = self.config_utils.load_yaml_config(config_path)
            
            info(f"JSP 파서 초기화 완료: {config_path}")
            
        except Exception as e:
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(e, "JSP 파서 초기화 실패")
```

### 3.2 JSP 파일 수집 구현
```python
def get_filtered_jsp_files(self, project_path: str, target_config: Dict[str, Any]) -> List[str]:
    """JSP 파일 수집 및 필터링"""
    try:
        # USER RULES: 공통함수 사용 지향
        file_utils = FileUtils()
        
        # USER RULES: target_source_config.yaml 활용
        include_patterns = target_config.get('include_patterns', [])
        exclude_patterns = target_config.get('exclude_patterns', [])
        
        jsp_files = []
        for root, dirs, files in os.walk(project_path):
            for file in files:
                if file.endswith('.jsp'):
                    file_path = os.path.join(root, file)
                    
                    # 포함/제외 패턴 확인
                    if self._is_file_included(file_path, include_patterns, exclude_patterns):
                        if self._is_valid_jsp_file(file_path):
                            jsp_files.append(file_path)
        
        info(f"JSP 파일 수집 완료: {len(jsp_files)}개")
        return jsp_files
        
    except Exception as e:
        # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
        handle_error(e, "JSP 파일 수집 실패")
        return []

def _is_file_included(self, file_path: str, include_patterns: List[str], exclude_patterns: List[str]) -> bool:
    """파일 포함/제외 패턴 확인"""
    try:
        # 포함 패턴 확인
        if include_patterns:
            if not any(pattern in file_path for pattern in include_patterns):
                return False
        
        # 제외 패턴 확인
        if exclude_patterns:
            if any(pattern in file_path for pattern in exclude_patterns):
                return False
        
        return True
        
    except Exception as e:
        # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
        handle_error(e, f"파일 포함/제외 패턴 확인 실패: {file_path}")

def _is_valid_jsp_file(self, file_path: str) -> bool:
    """유효한 JSP 파일인지 확인"""
    try:
        file_utils = FileUtils()
        content = file_utils.read_file(file_path)
        if not content:
            return False
        
        # JSP 지시어나 태그 확인
        jsp_indicators = [
            '<%@',  # JSP 지시어
            '<%',   # 스크립틀릿
            '<%=',  # 표현식
            '<jsp:', # JSP 액션
            '<c:',  # JSTL Core
            '<fmt:', # JSTL Formatting
            '<sql:', # JSTL SQL
            '<x:'   # JSTL XML
        ]
        
        content_lower = content.lower()
        return any(indicator in content_lower for indicator in jsp_indicators)
        
    except Exception as e:
        # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
        handle_error(e, f"JSP 파일 확인 실패: {file_path}")
```

### 3.3 JSP 파일 파싱 구현
```python
def parse_jsp_file(self, jsp_file: str) -> Dict[str, Any]:
    """JSP 파일에서 컴포넌트 정보 추출 및 Java 메서드 관계 분석"""
    try:
        # JSP 파일 읽기
        file_utils = FileUtils()
        jsp_content = file_utils.read_file(jsp_file)
        
        if not jsp_content:
            # USER RULES: 파싱에러는 has_error='Y', error_message 저장 후 계속 실행(exit안함)
            return {
                'jsp_component': None,
                'java_method_relationships': [],
                'file_path': jsp_file,
                'has_error': 'Y',
                'error_message': 'JSP 파일 읽기 실패'
            }
        
        # JSP 컴포넌트 정보 추출
        jsp_component = self._extract_jsp_component_info(jsp_content, jsp_file)
        
        # Java 메서드 호출 분석
        java_method_relationships = self._analyze_java_method_calls(jsp_content, jsp_component)
        
        return {
            'jsp_component': jsp_component,
            'java_method_relationships': java_method_relationships,
            'file_path': jsp_file,
            'has_error': 'N',
            'error_message': None
        }
        
    except Exception as e:
        # USER RULES: 파싱에러는 has_error='Y', error_message 저장 후 계속 실행(exit안함)
        warning(f"JSP 파일 파싱 실패: {jsp_file}, 오류: {str(e)}")
        return {
            'jsp_component': None,
            'java_method_relationships': [],
            'file_path': jsp_file,
            'has_error': 'Y',
            'error_message': f'JSP 파일 파싱 실패: {str(e)}'
        }
```

---

## 4. JSP 파싱 설정 파일 (path_utils.get_parser_config_path 방식)

### 4.1 전체 설정 파일 구조
```yaml
# JSP 파싱을 위한 키워드 및 패턴 설정

# JSP 태그 패턴
jsp_scriptlet_patterns:
  - r'<%([^%]+)%>'  # 스크립틀릿

jsp_expression_patterns:
  - r'<%=([^%]+)%>'  # 표현식

jsp_el_patterns:
  - r'\$\{([^}]+)\}'  # EL 표현식

jsp_jstl_patterns:
  - r'<c:([^>]+)>'  # JSTL Core
  - r'<fmt:([^>]+)>'  # JSTL Formatting
  - r'<sql:([^>]+)>'  # JSTL SQL
  - r'<x:([^>]+)>'  # JSTL XML

# Java 메서드 호출 패턴
java_method_call_patterns:
  - r'(\w+)\.(\w+)\s*\('  # object.method()
  - r'(\w+)\s*\([^)]*\)'  # method()

# 클래스명 매핑 (객체명 → 클래스명)
class_name_mapping:
  userService: UserService
  userController: UserController
  orderService: OrderService
  productService: ProductService

# 메서드-클래스 매핑 (메서드명 → 클래스명)
method_class_mapping:
  getUserList: UserService
  saveUser: UserService
  deleteUser: UserService
  getOrderList: OrderService
  saveOrder: OrderService

# JSP 예약어
jsp_reserved_keywords:
  - page
  - include
  - taglib
  - directive
```

---

## 5. main.py 통합

### 5.1 main.py 수정 (5단계 호출 추가)
```python
def main():
    """메인 실행 함수"""
    try:
        # 인자 파싱
        args = parse_arguments()
        project_name = args.project_name
        
        # 1-2단계: 파일 스캔 및 DB 구조 저장
        file_loading_engine = FileLoadingEngine(project_name)
        if not file_loading_engine.execute_file_loading():
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(Exception("1-2단계 실행 실패"), "파일 로딩 실패")
        
        # 3단계: XML 분석
        xml_loading_engine = XmlLoadingEngine(project_name)
        if not xml_loading_engine.execute_xml_loading():
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(Exception("3단계 실행 실패"), "XML 로딩 실패")
        
        # 4단계: Java 분석
        java_loading_engine = JavaLoadingEngine(project_name)
        if not java_loading_engine.execute_java_loading():
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(Exception("4단계 실행 실패"), "Java 로딩 실패")
        
        # 5단계: JSP 분석 (새로 추가)
        jsp_loading_engine = JspLoadingEngine(project_name)
        if not jsp_loading_engine.execute_jsp_loading():
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(Exception("5단계 실행 실패"), "JSP 로딩 실패")
        
        info("모든 단계 완료")
        
    except Exception as e:
        # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
        handle_error(e, "메인 실행 실패")
```

---

## 6. 다음 단계

다음 문서에서는 테스트 및 검증 계획을 제시합니다:
- [5. 테스트 및 검증 계획](./20250914_184841_최종_5단계개발계획서_05_테스트및검증계획.md)

---

**문서 작성 완료**: 2025-09-14 18:48:41  
**문서 버전**: v1.0 (최종 통합본)  
**다음 문서**: [5. 테스트 및 검증 계획](./20250914_184841_최종_5단계개발계획서_05_테스트및검증계획.md)
