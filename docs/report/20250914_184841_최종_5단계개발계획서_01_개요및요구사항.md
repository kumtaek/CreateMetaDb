# 최종 5단계 개발계획서 - 1장: 개요 및 요구사항

## 문서 정보
- **작성일**: 2025-09-14 18:48:41
- **작성자**: AI Assistant
- **문서 유형**: 최종 통합 개발계획서
- **대상 단계**: 5단계 - JSP 파일 분석 및 컴포넌트 등록
- **문서 버전**: v1.0 (최종 통합본)

## 📋 목차

1. [개요 및 요구사항](./20250914_184841_최종_5단계개발계획서_01_개요및요구사항.md) ← **현재 문서**
2. [아키텍처 설계](./20250914_184841_최종_5단계개발계획서_02_아키텍처설계.md)
3. [상세 구현 계획](./20250914_184841_최종_5단계개발계획서_03_상세구현계획.md)
4. [소스코드 구현 가이드](./20250914_184841_최종_5단계개발계획서_04_소스코드구현가이드.md)
5. [테스트 및 검증 계획](./20250914_184841_최종_5단계개발계획서_05_테스트및검증계획.md)

---

## 1. 5단계 개요

### 1.1 5단계 목적 및 핵심 기능

**목적**: JSP 파일에서 연관되는 component와의 관계(엣지)를 도출하는 것이 핵심 목표
- JSP 파일에서 JSP 컴포넌트 추출, components 테이블 등록
- JSP → Java 메서드 관계 분석 (스크립틀릿, 표현식, EL, JSTL)
- JSP → JSP 관계 분석 (include, forward 액션)
- JSP → Java Bean 관계 분석 (useBean 액션)
- JSP → 태그 라이브러리 관계 분석 (taglib 디렉티브)
- JSP → SQL 관계 분석 (JSTL SQL)
- JSP → XML 관계 분석 (JSTL XML)

**핵심 기능**:
- JSP 파일 파싱 및 JSP 컴포넌트 정보 추출
- **관계 도출 중심 JSP 분석**: 다양한 JSP 요소에서 관계 추출
- **매뉴얼 기반 분석**: Jakarta Server Pages 3.1 스펙 준수
- 메모리 최적화를 통한 스트리밍 처리
- 컴포넌트 등록 및 관계 저장

### 1.2 실행 함수 및 구현 상태

**실행 함수**:
- `JspLoadingEngine.execute_jsp_loading()` - 5단계 메인 실행 함수
- `JspParser.parse_jsp_file()` - JSP 파일 파싱 함수

**구현 상태**: 🔄 **개발 예정** (현재 미구현)

### 1.3 5단계만 개발하는 이유

- **4단계 이전 파일은 확정 픽스**: 1-4단계는 이미 완성되어 있으며 절대 영향받지 않도록 개발
- **독립적 개발**: 5단계는 완전히 독립적으로 개발되어 기존 시스템에 영향 없음
- **점진적 확장**: 기존 시스템을 건드리지 않고 새로운 기능을 추가

---

## 2. 현재 개발 현황 분석

### 2.1 3-4단계 소스 현황 (기존 완성된 단계)

#### 2.1.1 3단계 구현 완료된 기능 (xml_loading.py)
- ✅ XML 파일 수집 및 필터링
- ✅ MyBatis XML 파싱 (DOM + 정규식 Fallback)
- ✅ SQL 쿼리 추출 및 정제
- ✅ JOIN 관계 분석 (Explicit/Implicit)
- ✅ inferred 테이블/컬럼 생성
- ✅ 메모리 최적화 (스트리밍 처리)

#### 2.1.2 4단계 구현 완료된 기능 (java_loading.py)
- ✅ Java 파일 수집 및 필터링
- ✅ Java 클래스/메서드 추출
- ✅ 상속 관계 분석 (extends 키워드)
- ✅ 메모리 최적화 (스트리밍 처리)
- ✅ 컴포넌트 등록 및 관계 저장

#### 2.1.3 3-4단계 공통 특징
- ✅ **배타적 파일 구조**: xml_loading.py, java_loading.py로 완전 분리
- ✅ **공통 함수 활용**: util 모듈의 공통 함수들 재사용
- ✅ **설정 파일 기반**: config/parser/ 하위 YAML 파일 활용
- ✅ **메모리 최적화**: 스트리밍 처리로 한 파일씩만 메모리에 로드
- ✅ **오류 처리**: 파싱 에러는 계속 진행, 시스템 에러는 exit

### 2.2 5단계 개발 필요사항

#### 2.2.1 새로운 파일 구조 (4단계 이전에 영향 없음)
```
CreateMetaDb/
├── jsp_loading.py              # 5단계 메인 엔진 (새로 생성)
├── parser/
│   ├── jsp_parser.py           # JSP 파싱 로직 (새로 생성)
│   ├── xml_parser.py            # 3단계 (기존 유지 - 절대 수정 금지)
│   └── java_parser.py           # 4단계 (기존 유지 - 절대 수정 금지)
├── config\parser\
│   └── jsp_keyword.yaml        # JSP 파싱 설정 (새로 생성)
└── util/                        # 공통 유틸리티 (기존 유지 - 절대 수정 금지)
```

#### 2.2.2 3-4단계와의 완전한 독립성 보장
- **배타적 개발**: 3-4단계 소스에 영향 없이 별도 파일로 개발
- **공통 함수 활용**: util 모듈의 공통 함수들 재사용 (수정 없이)
- **설정 파일 분리**: `path_utils.get_parser_config_path("jsp")` 공통함수 활용
- **네임스페이스 분리**: 독립적인 클래스명과 메서드명 사용

---

## 3. 기술적 요구사항

### 3.1 User Rules 준수사항 (반드시 준수)

#### 3.1.1 하드코딩 금지
- **절대 금지**: 프로젝트명, 경로 등 하드코딩 금지
- **설정 파일 사용**: `path_utils.get_parser_config_path("jsp")` 공통함수 사용 (크로스플랫폼 대응)
- **공통함수 사용**: `PathUtils`, `FileUtils`, `DatabaseUtils` 등 util 모듈 활용

#### 3.1.2 예외 처리 규칙
- **파싱 에러**: `has_error='Y'`, `error_message` 저장 후 계속 진행 (exit 안함)
- **시스템 에러**: `handle_error()` 공통함수로 exit (프로그램 종료)
- **파싱 에러를 제외한 모든 exception 발생시 handle_error()로 exit()**

#### 3.1.3 기타 규칙
- **프로젝트 해시값**: 하드코딩된 '-' 사용
- **메뉴얼 기반**: `parser/manual/02_jsp` 참고
- **공통함수 중복 생성 지양**: ./util/ 확인 후 신규 공통함수 개발

### 3.2 메모리 최적화 요구사항

#### 3.2.1 스트리밍 처리
- **한 파일씩 처리**: 전체 JSP 파일을 메모리에 로드하지 않고 한 파일씩 처리
- **즉시 해제**: 파일 처리 완료 후 `del jsp_content`로 메모리에서 즉시 해제
- **배치 저장**: `batch_insert_or_replace()`로 대량 데이터 효율적 저장

#### 3.2.2 메모리 모니터링
- **메모리 사용량 모니터링**: psutil을 사용한 메모리 사용량 추적
- **메모리 사용률 경고**: 80% 이상 시 경고, 90% 이상 시 시스템 에러
- **메모리 사용량 로깅**: 처리 단계별 메모리 사용량 로깅

### 3.3 데이터베이스 스키마 활용

#### 3.3.1 components 테이블
- **JSP 컴포넌트 저장**: `component_type='JSP'`, `component_name='JSP파일명'`
- **parent_id**: None (JSP는 독립적인 컴포넌트)
- **file_id**: JSP 파일 ID (files 테이블과 연결)

#### 3.3.2 relationships 테이블 (관계 도출 중심)
- **JSP → METHOD 관계**: `rel_type='CALL_METHOD'`
- **JSP → JSP 관계**: `rel_type='INCLUDE_JSP'`, `rel_type='FORWARD_JSP'`
- **JSP → Java Bean 관계**: `rel_type='USE_BEAN'`
- **JSP → 태그 라이브러리 관계**: `rel_type='USE_TAGLIB'`
- **JSP → SQL 관계**: `rel_type='EXECUTE_SQL'`
- **JSP → XML 관계**: `rel_type='PARSE_XML'`
- **src_id**: JSP 컴포넌트 ID
- **dst_id**: 대상 컴포넌트 ID (METHOD, JSP, Java Bean, 태그 라이브러리, SQL, XML)

---

## 4. JSP 분석 대상 요소 (관계 도출 중심)

### 4.1 스크립틀릿 (Scriptlet)
```jsp
<%
    List<User> users = userService.getUserList();
    String message = userController.getMessage();
%>
```
- **분석 대상**: Java 코드 내 메서드 호출
- **관계 생성**: JSP → METHOD (CALL_METHOD)

### 4.2 표현식 (Expression)
```jsp
<%= userService.getUserName() %>
<%= userController.getCurrentTime() %>
```
- **분석 대상**: Java 표현식 내 메서드 호출
- **관계 생성**: JSP → METHOD (CALL_METHOD)

### 4.3 EL (Expression Language)
```jsp
${userService.userName}
${userController.currentUser.name}
```
- **분석 대상**: EL 표현식 내 프로퍼티 접근
- **관계 생성**: JSP → METHOD (CALL_METHOD)

### 4.4 JSTL (JSP Standard Tag Library)
```jsp
<c:forEach items="${userService.getUserList()}" var="user">
    <c:out value="${user.name}"/>
</c:forEach>
```
- **분석 대상**: JSTL 태그 내 메서드 호출
- **관계 생성**: JSP → METHOD (CALL_METHOD)

### 4.5 JSP 디렉티브 (Directives) - **매뉴얼 기반 추가**
```jsp
<%@ include file="header.jsp" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
```
- **분석 대상**: include, taglib 디렉티브
- **관계 생성**: JSP → JSP (INCLUDE_JSP), JSP → 태그 라이브러리 (USE_TAGLIB)

### 4.6 JSP 액션 태그 (Action Tags) - **매뉴얼 기반 추가**
```jsp
<jsp:include page="footer.jsp"/>
<jsp:forward page="error.jsp"/>
<jsp:useBean id="user" class="com.example.User"/>
```
- **분석 대상**: include, forward, useBean 액션 태그
- **관계 생성**: JSP → JSP (INCLUDE_JSP, FORWARD_JSP), JSP → Java Bean (USE_BEAN)

### 4.7 JSTL SQL 태그 - **매뉴얼 기반 추가**
```jsp
<sql:query var="result" dataSource="${ds}">SELECT * FROM users</sql:query>
```
- **분석 대상**: JSTL SQL 태그
- **관계 생성**: JSP → SQL (EXECUTE_SQL)

### 4.8 JSTL XML 태그 - **매뉴얼 기반 추가**
```jsp
<x:parse var="doc" xml="${xmlData}"/>
```
- **분석 대상**: JSTL XML 태그
- **관계 생성**: JSP → XML (PARSE_XML)

---

## 5. 개발 전략

### 5.1 점진적 개발 접근법
1. **1단계**: 기본 JSP 파싱 로직 구현
2. **2단계**: JSP 컴포넌트 추출 로직 구현
3. **3단계**: Java 메서드 호출 분석 로직 구현
4. **4단계**: 메모리 최적화 및 성능 튜닝
5. **5단계**: 오류 처리 및 예외 상황 대응

### 5.2 3-4단계 소스 재사용 전략
- **공통 함수**: util 모듈의 공통 함수들 재사용 (수정 없이)
- **설정 파일**: 기존 설정 파일 구조 활용
- **데이터베이스**: 기존 데이터베이스 스키마 활용
- **로깅**: 기존 로깅 시스템 활용

### 5.3 독립성 보장 전략
- **별도 파일**: `jsp_loading.py`, `parser/jsp_parser.py`로 완전 분리
- **네임스페이스**: 독립적인 클래스명과 메서드명 사용
- **의존성**: 3-4단계 소스에 대한 의존성 최소화

---

## 6. 성공 기준

### 6.1 기능적 요구사항
- ✅ JSP 파일에서 JSP 컴포넌트 정보 추출
- ✅ JSP에서 Java 메서드 호출 분석 (스크립틀릿, 표현식, EL, JSTL)
- ✅ JSP → METHOD 관계 생성 및 저장
- ✅ 메모리 효율적 처리
- ✅ 오류 상황 적절한 처리

### 6.2 비기능적 요구사항
- ✅ 3-4단계 소스와의 완전한 독립성 보장
- ✅ User Rules 완전 준수
- ✅ 설정 파일 기반 동작
- ✅ 공통 함수 활용 (수정 없이)
- ✅ 상세한 로깅 및 통계

---

## 7. 위험 요소 및 대응 방안

### 7.1 기술적 위험
- **위험**: JSP 파싱 복잡성 (다양한 JSP 태그, EL, JSTL)
- **대응**: 정규식 기반 단순한 파싱으로 시작, 점진적 고도화

### 7.2 성능 위험
- **위험**: 대용량 JSP 파일 처리 시 메모리 부족
- **대응**: 스트리밍 처리 및 즉시 해제 전략

### 7.3 호환성 위험
- **위험**: 3-4단계 소스와의 충돌
- **대응**: 완전 분리된 파일 구조 및 독립적인 네임스페이스

---

## 8. 다음 단계

다음 문서에서는 구체적인 아키텍처 설계를 제시합니다:
- [2. 아키텍처 설계](./20250914_184841_최종_5단계개발계획서_02_아키텍처설계.md)

---

## 📚 참조 문서

### 관련 문서
- **[처리플로우_상세_5단계.md](../처리플로우_상세_5단계.md)**: 5단계 처리플로우 상세 문서
- **[메타데이터베이스스키마정의서.md](../메타데이터베이스스키마정의서.md)**: 데이터베이스 스키마 구조 상세
- **[요구사항정의서.md](../요구사항정의서.md)**: 전체 시스템 요구사항 정의

### 기존 개발계획서 (참고용)
- **[20250914_022600_5단계개발계획서_01_개요및현황분석.md](./20250914_022600_5단계개발계획서_01_개요및현황분석.md)**: 기존 개요 문서
- **[20250914_023300_5단계개발계획서_통합본.md](./20250914_023300_5단계개발계획서_통합본.md)**: 기존 통합본

### 설정 파일
- **[create_table_script.sql](../../database/create_table_script.sql)**: 메타데이터베이스 스키마 정의 원본 파일

---

**문서 작성 완료**: 2025-09-14 18:48:41  
**문서 버전**: v1.0 (최종 통합본)  
**다음 문서**: [2. 아키텍처 설계](./20250914_184841_최종_5단계개발계획서_02_아키텍처설계.md)
