# 6단계 개발계획서 - 개요 및 현황 분석

## 문서 정보
- **작성일**: 2025-09-14 02:26:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서
- **대상 단계**: 6단계 - JSP 파일 분석 및 컴포넌트 등록

## 1. 개요

### 1.1 6단계 목적
JSP 파일에서 JSP 컴포넌트 추출, components 테이블 등록, JSP → Java 메서드 관계 분석을 수행합니다.

### 1.2 핵심 기능
- JSP 파일 파싱 및 JSP 컴포넌트 정보 추출
- JSP → Java 메서드 관계 분석 (스크립틀릿, 표현식, EL, JSTL)
- 메모리 최적화를 통한 스트리밍 처리
- 컴포넌트 등록 및 관계 저장

### 1.3 실행 함수
- `JspLoadingEngine.execute_jsp_loading()`
- `JspParser.parse_jsp_file()`

### 1.4 구현 상태
🔄 **개발 예정** (현재 미구현)

## 2. 현재 개발 현황 분석

### 2.1 3-4단계 소스 현황 (xml_loading.py, java_loading.py)

#### 2.1.1 3단계 구현 완료된 기능
- ✅ XML 파일 수집 및 필터링
- ✅ MyBatis XML 파싱 (DOM + 정규식 Fallback)
- ✅ SQL 쿼리 추출 및 정제
- ✅ JOIN 관계 분석 (Explicit/Implicit)
- ✅ inferred 테이블/컬럼 생성
- ✅ 메모리 최적화 (스트리밍 처리)

#### 2.1.2 4단계 구현 완료된 기능
- ✅ Java 파일 수집 및 필터링
- ✅ Java 클래스/메서드 추출
- ✅ 상속 관계 분석 (extends 키워드)
- ✅ 메모리 최적화 (스트리밍 처리)
- ✅ 컴포넌트 등록 및 관계 저장

#### 2.1.3 3-4단계 공통 특징
- ✅ **배타적 파일 구조**: xml_loading.py, java_loading.py로 완전 분리
- ✅ **공통 함수 활용**: util 모듈의 공통 함수들 재사용
- ✅ **설정 파일 기반**: config/parser/ 하위 YAML 파일 활용
- ✅ **메모리 최적화**: 스트리밍 처리로 한 파일씩만 메모리에 로드
- ✅ **오류 처리**: 파싱 에러는 계속 진행, 시스템 에러는 exit

### 2.2 6단계 개발 필요사항

#### 2.2.1 새로운 파일 구조
```
CreateMetaDb/
├── jsp_loading.py          # 6단계 메인 엔진 (새로 생성)
├── parser/
│   ├── jsp_parser.py       # JSP 파싱 로직 (새로 생성)
│   ├── xml_parser.py        # 3단계 (기존 유지)
│   └── java_parser.py       # 4단계 (기존 유지)
```

#### 2.2.2 3-4단계와의 독립성
- **배타적 개발**: 3-4단계 소스에 영향 없이 별도 파일로 개발
- **공통 함수 활용**: util 모듈의 공통 함수들 재사용
- **설정 파일 분리**: `config/parser/jsp_keyword.yaml` 활용

## 3. 기술적 요구사항

### 3.1 User Rules 준수사항
- **하드코딩 금지**: `config/parser/jsp_keyword.yaml` 설정 파일 사용
- **공통함수 사용**: `DatabaseUtils`, `FileUtils`, `HashUtils`, `PathUtils` 등 util 모듈 활용
- **예외 처리**: 
  - 파싱 에러: `has_error='Y'`, `error_message` 저장 후 계속 진행
  - 시스템 에러: `handle_error()` 공통함수로 exit
- **프로젝트 해시값**: 하드코딩된 '-' 사용
- **메뉴얼 기반**: `parser/manual/02_jsp` 참고

### 3.2 메모리 최적화 요구사항
- **스트리밍 처리**: 한 파일씩만 메모리에 로드하여 처리
- **즉시 해제**: 파일 처리 완료 후 `del jsp_content`로 메모리에서 즉시 해제
- **배치 저장**: `batch_insert_or_replace()`로 대량 데이터 효율적 저장

### 3.3 데이터베이스 스키마 활용
- **components 테이블**: JSP 컴포넌트 정보 저장
- **relationships 테이블**: JSP → METHOD 관계 저장
- **기존 컴포넌트 활용**: 4단계에서 생성된 METHOD 컴포넌트와 관계 설정

## 4. JSP 분석 대상 요소

### 4.1 스크립틀릿 (Scriptlet)
```jsp
<%
    List<User> users = userService.getUserList();
    String message = userController.getMessage();
%>
```
- **분석 대상**: Java 코드 내 메서드 호출
- **관계 생성**: JSP → METHOD (CALL_METHOD)

### 4.2 표현식 (Expression)
```jsp
<%= userService.getUserName() %>
<%= userController.getCurrentTime() %>
```
- **분석 대상**: Java 표현식 내 메서드 호출
- **관계 생성**: JSP → METHOD (CALL_METHOD)

### 4.3 EL (Expression Language)
```jsp
${userService.userName}
${userController.currentUser.name}
```
- **분석 대상**: EL 표현식 내 프로퍼티 접근
- **관계 생성**: JSP → METHOD (CALL_METHOD)

### 4.4 JSTL (JSP Standard Tag Library)
```jsp
<c:forEach items="${userService.getUserList()}" var="user">
    <c:out value="${user.name}"/>
</c:forEach>
```
- **분석 대상**: JSTL 태그 내 메서드 호출
- **관계 생성**: JSP → METHOD (CALL_METHOD)

## 5. 개발 전략

### 5.1 점진적 개발 접근법
1. **1단계**: 기본 JSP 파싱 로직 구현
2. **2단계**: JSP 컴포넌트 추출 로직 구현
3. **3단계**: Java 메서드 호출 분석 로직 구현
4. **4단계**: 메모리 최적화 및 성능 튜닝
5. **5단계**: 오류 처리 및 예외 상황 대응

### 5.2 3-4단계 소스 재사용 전략
- **공통 함수**: util 모듈의 공통 함수들 재사용
- **설정 파일**: 기존 설정 파일 구조 활용
- **데이터베이스**: 기존 데이터베이스 스키마 활용
- **로깅**: 기존 로깅 시스템 활용

### 5.3 독립성 보장 전략
- **별도 파일**: `jsp_loading.py`, `parser/jsp_parser.py`로 완전 분리
- **네임스페이스**: 독립적인 클래스명과 메서드명 사용
- **의존성**: 3-4단계 소스에 대한 의존성 최소화

## 6. 예상 개발 일정

### 6.1 1주차: 기본 구조 및 파싱 로직
- JSP 파서 기본 구조 설계
- JSP 파일 수집 및 필터링
- 기본 JSP 컴포넌트 추출 로직

### 6.2 2주차: 고급 분석 로직
- Java 메서드 호출 분석 로직
- 스크립틀릿/표현식/EL/JSTL 분석
- 데이터베이스 저장 로직

### 6.3 3주차: 최적화 및 안정화
- 메모리 최적화 구현
- 오류 처리 및 예외 상황 대응
- 성능 테스트 및 튜닝

### 6.4 4주차: 통합 테스트 및 문서화
- 전체 시스템 통합 테스트
- 문서화 및 사용자 가이드 작성
- 최종 검증 및 배포 준비

## 7. 성공 기준

### 7.1 기능적 요구사항
- ✅ JSP 파일에서 JSP 컴포넌트 정보 추출
- ✅ JSP에서 Java 메서드 호출 분석
- ✅ JSP → METHOD 관계 생성 및 저장
- ✅ 메모리 효율적 처리
- ✅ 오류 상황 적절한 처리

### 7.2 비기능적 요구사항
- ✅ 3-4단계 소스와의 독립성 보장
- ✅ User Rules 완전 준수
- ✅ 설정 파일 기반 동작
- ✅ 공통 함수 활용
- ✅ 상세한 로깅 및 통계

## 8. 위험 요소 및 대응 방안

### 8.1 기술적 위험
- **위험**: JSP 파싱 복잡성 (다양한 JSP 태그, EL, JSTL)
- **대응**: 정규식 기반 단순한 파싱으로 시작, 점진적 고도화

### 8.2 성능 위험
- **위험**: 대용량 JSP 파일 처리 시 메모리 부족
- **대응**: 스트리밍 처리 및 즉시 해제 전략

### 8.3 호환성 위험
- **위험**: 3-4단계 소스와의 충돌
- **대응**: 완전 분리된 파일 구조 및 독립적인 네임스페이스

## 9. 다음 단계

다음 문서에서는 구체적인 설계 및 구현 방안을 제시합니다:
- [2. JSP 파서 설계 및 구현 방안](./20250914_022700_6단계개발계획서_02_JSP파서설계.md)
- [3. JSP 컴포넌트 추출 로직](./20250914_022800_6단계개발계획서_03_JSP컴포넌트추출.md)
- [4. Java 메서드 호출 분석](./20250914_022900_6단계개발계획서_04_Java메서드호출분석.md)
- [5. 메모리 최적화 전략](./20250914_023000_6단계개발계획서_05_메모리최적화.md)
- [6. 오류 처리 및 예외 상황](./20250914_023100_6단계개발계획서_06_오류처리.md)
- [7. 문서화 완료](./20250914_023200_6단계개발계획서_07_문서화완료.md)
