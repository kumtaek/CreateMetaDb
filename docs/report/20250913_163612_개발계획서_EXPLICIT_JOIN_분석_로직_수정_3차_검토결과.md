# 최종 검토 보고서: EXPLICIT & IMPLICIT JOIN 분석 로직 (3차)

**작성일**: 2025-09-13 16:50:00  
**검토 대상**: `20250913_163612_개발계획서_EXPLICIT_JOIN_분석_로직_수정_3차.md`  
**참고 자료**: `docs` 폴더 내 모든 `.md` 파일 (요구사항, 스키마, 처리 플로우, 정답지 등)

---

## 1. 최종 검토 요약

3차 개발계획서는 `FROM` 절을 시작으로 JOIN 관계를 순차적으로 추적하는 **문맥적 분석 방식**을 도입하여 이전 계획서들의 핵심 문제점을 해결했습니다. 이는 매우 올바른 방향이며, 계획의 완성도를 크게 높였습니다.

하지만, 사용자가 추가로 요구한 **고급 요구사항**과 `docs` 폴더의 다른 문서들과의 **정합성** 측면에서 다음과 같은 보완점을 발견했습니다.

1.  **Inferred Column 분석 누락**: `WHERE` 절이나 `ON` 절의 조인 조건에서 컬럼 정보를 추론하여 `components`와 `relationships`를 생성하는 로직이 부재합니다.
2.  **별칭 생략(Alias-less) JOIN 조건 처리 미흡**: `WHERE table1.col = table2.col` 형태 외에, 별칭이 없는 `WHERE col1 = col2` 형태의 암시적(Implicit) JOIN 조건 분석이 명시되지 않았습니다.
3.  **테스트 케이스 불충분**: 위 두 가지 고급 시나리오를 검증할 테스트 케이스가 `sampleSrc`에 부족합니다.
4.  **문서 간 정합성**: `요구사항정의서`에 명시된 `inferred 테이블/컬럼 자동 생성` 규칙과 3차 계획서의 구현 범위 간에 약간의 차이가 있습니다.

본 문서는 이러한 최종 검토 의견을 바탕으로, **최고 수준의 정확도**를 달성하기 위한 최종 개선안을 제시합니다.

---

## 2. 핵심 개선 제안

### 2.1. Inferred Column 분석 로직 추가

`정답지`와 `요구사항정의서`에 따르면, 시스템은 쿼리에서만 사용되고 DB 스키마(CSV)에는 정의되지 않은 컬럼을 **'Inferred Column'**으로 추론하고 관계를 생성해야 합니다. 이를 위해 다음 로직을 `_analyze_explicit_joins` 함수 내에 추가해야 합니다.

- **로직 순서**:
  1.  `ON` 또는 `WHERE` 절에서 `테이블.컬럼` 또는 `별칭.컬럼` 형태의 조인 조건을 모두 추출합니다.
  2.  각 `테이블.컬럼`에 대해, `columns` 테이블에 해당 컬럼이 존재하는지 확인합니다.
  3.  만약 존재하지 않는다면, 해당 컬럼을 **Inferred Column**으로 판단합니다.
  4.  `_create_inferred_column()` 함수를 호출하여 `columns` 테이블과 `components` 테이블에 `INFERRED` 속성으로 새 컬럼을 등록합니다.
  5.  `relationships` 테이블에 `(SQL 쿼리 컴포넌트 ID)`와 `(방금 생성된 Inferred Column 컴포넌트 ID)` 간의 `USES_INFERRED_COLUMN` 관계를 생성합니다.

#### **의사 코드 (Inferred Column 생성)**
```python
def _create_inferred_column(self, table_id, column_name):
    # 1. columns 테이블에 'INFERRED' 속성으로 컬럼 추가
    column_data = {
        'table_id': table_id,
        'column_name': column_name,
        'data_type': 'INFERRED',
        'hash_value': 'INFERRED'
    }
    column_id = self.db_utils.insert_or_replace('columns', column_data)

    # 2. components 테이블에 COLUMN 타입으로 컴포넌트 추가
    table_component_id = self.db_utils.get_table_component_id(table_id)
    component_data = {
        'component_type': 'COLUMN',
        'component_name': column_name,
        'parent_id': table_component_id, # 부모인 테이블 컴포넌트와 연결
        'hash_value': 'INFERRED'
    }
    component_id = self.db_utils.insert_or_replace('components', component_data)

    # 3. columns 테이블의 component_id 업데이트
    self.db_utils.update_record('columns', {'component_id': component_id}, {'column_id': column_id})
    
    return component_id
```

### 2.2. 별칭 없는(Alias-less) WHERE 절 JOIN 분석 강화

`Implicit Join` 분석 시, `WHERE u.id = o.user_id` 처럼 별칭이 명시된 경우 외에 `WHERE id = user_id` 처럼 별칭이 없는 경우도 처리해야 합니다. 이는 매우 어려운 작업이며, 다음과 같은 추론 과정이 필요합니다.

- **추론 로직**:
  1.  `FROM` 절에서 쿼리에 참여하는 모든 테이블(`T1, T2, ...`) 목록을 확보합니다.
  2.  `WHERE` 절에서 `col1 = col2` 형태의 조건을 찾습니다.
  3.  `col1`이 `T1, T2, ...` 중 오직 하나의 테이블에만 존재하는 컬럼인지 확인합니다.
  4.  `col2` 또한 `T1, T2, ...` 중 오직 하나의 테이블에만 존재하는 컬럼인지 확인합니다.
  5.  만약 양쪽 모두 유일하게 매핑된다면, 해당 테이블 간의 `JOIN_IMPLICIT` 관계가 성립한다고 추론할 수 있습니다.

- **한계점 명시**: 이 추론은 양쪽 테이블에 동일한 이름의 컬럼이 없을 때만 유효합니다. 만약 여러 테이블에 `ID`라는 컬럼이 공통으로 존재한다면, `WHERE ID = ...` 구문은 어떤 테이블의 `ID`인지 특정할 수 없으므로 분석이 불가능합니다. 이러한 한계점은 개발 시 주석이나 문서에 명확히 기록해야 합니다.

### 2.3. 테스트 케이스 보강

현재 `sampleSrc` 프로젝트에는 위에서 제안한 고도화된 시나리오를 검증할 충분한 테스트 케이스가 부족합니다. 정확한 개발 및 검증을 위해 다음 케이스를 포함하는 신규 `XML` 매퍼 파일을 `temp` 또는 테스트용 폴더에 추가하여 테스트해야 합니다.

- **필수 추가 테스트 케이스**:
  1.  **Inferred Column 테스트**: DB 스키마에 존재하지 않는 컬럼(`ex: u.NON_EXISTENT_COL`)을 `ON` 조건절에서 사용하는 쿼리.
  2.  **별칭 없는 WHERE 절 JOIN 테스트**: `FROM A, B WHERE A.id = B.a_id AND name = 'test'` 와 같이, 일부는 별칭이 있고 일부는 없는 조건이 혼합된 쿼리.
  3.  **복합 테스트**: 위 두 가지 케이스가 하나의 쿼리 안에서 동시에 발생하는 복합적인 시나리오.

---

## 3. 문서 정합성 검토 결과

- **`요구사항정의서.md`**: "inferred 테이블/컬럼 자동 생성" 요구사항이 명시되어 있습니다. 3차 계획서는 `inferred table`은 다루고 있으나 `inferred column`이 누락되어 요구사항을 완전히 충족하지 못합니다. 위 `2.1` 개선안이 반드시 반영되어야 합니다.
- **`메타데이터베이스스키마정의서.md`**: `relationships` 테이블의 `rel_type`에 `USES_INFERRED_COLUMN` 같은 타입을 추가하여, 일반적인 테이블 사용 관계와 추론된 컬럼 사용 관계를 구분하는 것을 고려해볼 수 있습니다. 이는 데이터 모델의 표현력을 높여줄 것입니다.
- **`처리플로우_*.md`**: 3차 계획서에서 제안한 `FROM`절 우선 분석 후 `JOIN`절을 순차 분석하는 방식은 기존 처리 플로우와 충돌하지 않으며, 오히려 3단계(XML 분석)를 더욱 구체화하고 발전시키는 좋은 방향입니다.

---

## 4. 최종 결론 및 권장 사항

3차 개발계획서는 매우 훌륭한 진전을 보여주었으며, 제안된 **문맥적 분석 아키텍처**는 프로젝트의 기술적 방향을 올바르게 이끌고 있습니다. 이제 마지막 단계를 통해 계획을 완성해야 합니다.

**최종 권장 사항**:

1.  **Inferred Column 분석 로직을 계획서에 공식적으로 추가하십시오.** (가장 중요)
2.  별칭 없는 `WHERE` 절 JOIN 조건에 대한 분석 방식과 그 한계점을 명확히 정의하십시오.
3.  위 시나리오들을 검증할 수 있는 **신규 테스트 케이스용 XML 파일**을 생성하고, 이를 테스트 단계에 포함시키십시오.
4.  (선택) `relationships.rel_type`에 `USES_INFERRED_COLUMN` 타입을 추가하여 데이터 모델을 더욱 정교하게 만드는 방안을 검토하십시오.

위 사항들을 반영하여 3차 개발계획서를 수정 및 보완한다면, `정답지`의 90%를 넘어서는 **최고 수준의 분석 정확도**를 달성할 수 있을 뿐만 아니라, 향후 유지보수와 확장성까지 확보하는 매우 견고한 시스템을 구축하게 될 것입니다.
