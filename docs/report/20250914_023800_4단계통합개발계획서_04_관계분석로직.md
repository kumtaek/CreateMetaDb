# 4~5단계 통합 개발계획서 - 관계 분석 로직

## 문서 정보
- **작성일**: 2025-09-14 02:38:00
- **작성자**: AI Assistant
- **문서 유형**: 통합 개발계획서
- **대상 단계**: 4~5단계 통합 - 관계 분석 로직

## 1. 개요

### 1.1 관계 분석 대상
- **상속 관계**: `INHERITANCE` - 클래스 간 상속 관계
- **CALL_QUERY 관계**: 메서드 → SQL 쿼리 호출 관계
- **CALL_METHOD 관계**: 메서드 → 메서드 호출 관계
- **USE_TABLE 관계**: 메서드 → 테이블 사용 관계

### 1.2 관계 분석 특징
- **통합 처리**: 클래스/메서드 추출과 동시에 관계 분석 수행
- **실시간 분석**: 파싱 중에 관계 정보를 즉시 추출
- **메모리 최적화**: 한 번의 파일 읽기로 모든 관계 정보 추출

## 2. 상속 관계 분석

### 2.1 상속 관계 분석 메서드

```python
def _analyze_inheritance_relationships(self, java_content: str) -> List[Dict[str, Any]]:
    """
    Java 파일에서 상속 관계 분석
    
    Args:
        java_content: Java 파일 내용
        
    Returns:
        상속 관계 리스트
    """
    try:
        relationships = []
        
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        inheritance_patterns = self.config.get('inheritance_patterns', [])
        
        for pattern in inheritance_patterns:
            matches = re.finditer(pattern, java_content, re.MULTILINE)
            for match in matches:
                child_class = match.group(1)
                parent_class = match.group(2)
                
                # 라인 번호 추출
                line_number = java_content[:match.start()].count('\n') + 1
                
                relationships.append({
                    'rel_type': 'INHERITANCE',
                    'src_name': child_class,
                    'dst_name': parent_class,
                    'line_number': line_number,
                    'relationship_detail': match.group(0)
                })
        
        return relationships
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"상속 관계 분석 실패: {str(e)}")
        return []
```

### 2.2 상속 패턴 설정

```yaml
# java_keyword.yaml에 추가할 상속 패턴
inheritance_patterns:
  - 'class\s+(\w+)\s+extends\s+(\w+)'
  - 'public\s+class\s+(\w+)\s+extends\s+(\w+)'
  - 'interface\s+(\w+)\s+extends\s+(\w+)'
  - 'public\s+interface\s+(\w+)\s+extends\s+(\w+)'
```

## 3. CALL_QUERY 관계 분석

### 3.1 CALL_QUERY 관계 분석 메서드

```python
def _analyze_call_query_relationships(self, java_content: str, methods: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Java 파일에서 CALL_QUERY 관계 분석 (통합)
    
    Args:
        java_content: Java 파일 내용
        methods: 메서드 정보 리스트
        
    Returns:
        CALL_QUERY 관계 리스트
    """
    try:
        relationships = []
        
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        call_query_patterns = self.config.get('relationship_patterns', {}).get('call_query_patterns', [])
        
        for method in methods:
            method_name = method['method_name']
            class_name = method['class_name']
            line_start = method['line_start']
            line_end = method['line_end']
            
            # 메서드 내용 추출
            method_content = self._extract_method_body(java_content, line_start, line_end)
            if not method_content:
                continue
            
            # SQL 호출 패턴 분석
            for pattern in call_query_patterns:
                matches = re.finditer(pattern, method_content, re.MULTILINE)
                for match in matches:
                    # 쿼리 ID 추출
                    query_id = self._extract_query_id(match.group(0))
                    if query_id:
                        relationships.append({
                            'rel_type': 'CALL_QUERY',
                            'src_name': f"{class_name}.{method_name}",
                            'dst_name': query_id,
                            'line_number': line_start + java_content[:match.start()].count('\n'),
                            'relationship_detail': match.group(0)
                        })
        
        return relationships
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"CALL_QUERY 관계 분석 실패: {str(e)}")
        return []
```

### 3.2 쿼리 ID 추출

```python
def _extract_query_id(self, sql_call: str) -> str:
    """
    SQL 호출에서 쿼리 ID 추출
    
    Args:
        sql_call: SQL 호출 코드
        
    Returns:
        쿼리 ID
    """
    try:
        # MyBatis 매퍼 호출 패턴
        mapper_patterns = [
            r'mapper\.(\w+)\s*\(',
            r'sqlSession\.selectOne\s*\(\s*["\']([^"\']+)["\']',
            r'sqlSession\.selectList\s*\(\s*["\']([^"\']+)["\']',
            r'sqlSession\.insert\s*\(\s*["\']([^"\']+)["\']',
            r'sqlSession\.update\s*\(\s*["\']([^"\']+)["\']',
            r'sqlSession\.delete\s*\(\s*["\']([^"\']+)["\']'
        ]
        
        for pattern in mapper_patterns:
            match = re.search(pattern, sql_call)
            if match:
                return match.group(1)
        
        return None
        
    except Exception as e:
        warning(f"쿼리 ID 추출 실패: {str(e)}")
        return None
```

### 3.3 메서드 본문 추출

```python
def _extract_method_body(self, java_content: str, line_start: int, line_end: int) -> str:
    """
    메서드 본문 추출
    
    Args:
        java_content: Java 파일 내용
        line_start: 메서드 시작 라인
        line_end: 메서드 끝 라인
        
    Returns:
        메서드 본문
    """
    try:
        lines = java_content.split('\n')
        if line_start <= len(lines) and line_end <= len(lines):
            method_lines = lines[line_start-1:line_end]
            return '\n'.join(method_lines)
        else:
            return ""
            
    except Exception as e:
        warning(f"메서드 본문 추출 실패: {str(e)}")
        return ""
```

## 4. CALL_METHOD 관계 분석

### 4.1 CALL_METHOD 관계 분석 메서드

```python
def _analyze_call_method_relationships(self, java_content: str, methods: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Java 파일에서 CALL_METHOD 관계 분석 (통합)
    
    Args:
        java_content: Java 파일 내용
        methods: 메서드 정보 리스트
        
    Returns:
        CALL_METHOD 관계 리스트
    """
    try:
        relationships = []
        
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        call_method_patterns = self.config.get('relationship_patterns', {}).get('call_method_patterns', [])
        exclude_methods = self.config.get('relationship_patterns', {}).get('exclude_methods', [])
        
        for method in methods:
            method_name = method['method_name']
            class_name = method['class_name']
            line_start = method['line_start']
            line_end = method['line_end']
            
            # 메서드 내용 추출
            method_content = self._extract_method_body(java_content, line_start, line_end)
            if not method_content:
                continue
            
            # 메서드 호출 패턴 분석
            for pattern in call_method_patterns:
                matches = re.finditer(pattern, method_content, re.MULTILINE)
                for match in matches:
                    called_method = match.group(1)
                    
                    # 제외 메서드 확인
                    if self._should_exclude_method(called_method, exclude_methods):
                        continue
                    
                    relationships.append({
                        'rel_type': 'CALL_METHOD',
                        'src_name': f"{class_name}.{method_name}",
                        'dst_name': called_method,
                        'line_number': line_start + java_content[:match.start()].count('\n'),
                        'relationship_detail': match.group(0)
                    })
        
        return relationships
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"CALL_METHOD 관계 분석 실패: {str(e)}")
        return []
```

### 4.2 제외 메서드 확인

```python
def _should_exclude_method(self, method_name: str, exclude_methods: List[str]) -> bool:
    """
    제외할 메서드인지 확인
    
    Args:
        method_name: 메서드명
        exclude_methods: 제외 메서드 리스트
        
    Returns:
        제외 여부
    """
    try:
        for exclude_pattern in exclude_methods:
            if re.match(exclude_pattern, method_name):
                return True
        return False
        
    except Exception as e:
        warning(f"제외 메서드 확인 실패: {method_name} - {str(e)}")
        return False
```

## 5. USE_TABLE 관계 분석

### 5.1 USE_TABLE 관계 분석 메서드

```python
def _analyze_use_table_relationships(self, java_content: str, methods: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Java 파일에서 USE_TABLE 관계 분석 (통합)
    
    Args:
        java_content: Java 파일 내용
        methods: 메서드 정보 리스트
        
    Returns:
        USE_TABLE 관계 리스트
    """
    try:
        relationships = []
        
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        use_table_patterns = self.config.get('relationship_patterns', {}).get('use_table_patterns', [])
        
        for method in methods:
            method_name = method['method_name']
            class_name = method['class_name']
            line_start = method['line_start']
            line_end = method['line_end']
            
            # 메서드 내용 추출
            method_content = self._extract_method_body(java_content, line_start, line_end)
            if not method_content:
                continue
            
            # 테이블 사용 패턴 분석
            for pattern in use_table_patterns:
                matches = re.finditer(pattern, method_content, re.MULTILINE | re.IGNORECASE)
                for match in matches:
                    table_name = match.group(1)
                    
                    # 테이블명 정제
                    clean_table_name = self._clean_table_name(table_name)
                    if clean_table_name:
                        relationships.append({
                            'rel_type': 'USE_TABLE',
                            'src_name': f"{class_name}.{method_name}",
                            'dst_name': clean_table_name,
                            'line_number': line_start + java_content[:match.start()].count('\n'),
                            'relationship_detail': match.group(0)
                        })
        
        return relationships
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"USE_TABLE 관계 분석 실패: {str(e)}")
        return []
```

### 5.2 테이블명 정제

```python
def _clean_table_name(self, table_name: str) -> str:
    """
    테이블명 정제
    
    Args:
        table_name: 원본 테이블명
        
    Returns:
        정제된 테이블명
    """
    try:
        # 공백 제거
        clean_name = table_name.strip()
        
        # 따옴표 제거
        clean_name = re.sub(r'["\']', '', clean_name)
        
        # 테이블 별칭 제거 (AS 키워드 이후)
        clean_name = re.sub(r'\s+as\s+\w+$', '', clean_name, flags=re.IGNORECASE)
        
        # 공백을 언더스코어로 변환
        clean_name = re.sub(r'\s+', '_', clean_name)
        
        return clean_name if clean_name else None
        
    except Exception as e:
        warning(f"테이블명 정제 실패: {table_name} - {str(e)}")
        return None
```

## 6. 관계 분석 통합 처리

### 6.1 모든 관계 분석 통합

```python
def _analyze_all_relationships(self, java_content: str, methods: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    모든 관계 분석 통합 처리
    
    Args:
        java_content: Java 파일 내용
        methods: 메서드 정보 리스트
        
    Returns:
        모든 관계 리스트
    """
    try:
        all_relationships = []
        
        # 1. 상속 관계 분석
        inheritance_rels = self._analyze_inheritance_relationships(java_content)
        all_relationships.extend(inheritance_rels)
        
        # 2. CALL_QUERY 관계 분석
        call_query_rels = self._analyze_call_query_relationships(java_content, methods)
        all_relationships.extend(call_query_rels)
        
        # 3. CALL_METHOD 관계 분석
        call_method_rels = self._analyze_call_method_relationships(java_content, methods)
        all_relationships.extend(call_method_rels)
        
        # 4. USE_TABLE 관계 분석
        use_table_rels = self._analyze_use_table_relationships(java_content, methods)
        all_relationships.extend(use_table_rels)
        
        return all_relationships
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"관계 분석 통합 처리 실패: {str(e)}")
        return []
```

## 7. 설정 파일 구조

### 7.1 관계 분석 패턴 설정

```yaml
# java_keyword.yaml에 추가할 관계 분석 패턴
inheritance_patterns:
  - 'class\s+(\w+)\s+extends\s+(\w+)'
  - 'public\s+class\s+(\w+)\s+extends\s+(\w+)'
  - 'interface\s+(\w+)\s+extends\s+(\w+)'
  - 'public\s+interface\s+(\w+)\s+extends\s+(\w+)'

relationship_patterns:
  call_query_patterns:
    - 'sqlSession\.selectOne\s*\('
    - 'sqlSession\.selectList\s*\('
    - 'sqlSession\.insert\s*\('
    - 'sqlSession\.update\s*\('
    - 'sqlSession\.delete\s*\('
    - 'mapper\.(\w+)\s*\('
  
  call_method_patterns:
    - 'this\.(\w+)\s*\('
    - '(\w+)\.(\w+)\s*\('
    - '(\w+)\s*\('
  
  use_table_patterns:
    - 'FROM\s+(\w+)'
    - 'JOIN\s+(\w+)'
    - 'UPDATE\s+(\w+)'
    - 'INSERT\s+INTO\s+(\w+)'
    - 'DELETE\s+FROM\s+(\w+)'
  
  exclude_methods:
    - '^System\.'
    - '^String\.'
    - '^Integer\.'
    - '^Long\.'
    - '^Boolean\.'
    - '^Object\.'
    - '^toString$'
    - '^equals$'
    - '^hashCode$'
```

## 8. 관계 분석 최적화

### 8.1 성능 최적화

```python
def _optimize_relationship_analysis(self, java_content: str, methods: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    관계 분석 성능 최적화
    
    Args:
        java_content: Java 파일 내용
        methods: 메서드 정보 리스트
        
    Returns:
        최적화된 관계 리스트
    """
    try:
        # 메서드별로 관계 분석을 병렬 처리할 수 있도록 최적화
        all_relationships = []
        
        # 메서드가 많은 경우 배치 처리
        batch_size = 100
        for i in range(0, len(methods), batch_size):
            batch_methods = methods[i:i+batch_size]
            
            # 배치별 관계 분석
            batch_relationships = self._analyze_all_relationships(java_content, batch_methods)
            all_relationships.extend(batch_relationships)
            
            # 메모리 최적화
            del batch_relationships
        
        return all_relationships
        
    except Exception as e:
        warning(f"관계 분석 최적화 실패: {str(e)}")
        return []
```

## 9. 다음 단계

다음 문서에서는 메모리 최적화 전략을 제시합니다:
- [5. 메모리 최적화 전략](./20250914_023800_4~5단계통합개발계획서_05_메모리최적화전략.md)
