# DOM -> SAX Fallback 구조 개선 개발 계획서

- **문서 버전**: 1.0
- **작성일**: 2025-09-14
- **작성자**: Gemini
- **목표**: MyBatis XML 파싱 시 발생하는 `RecursionError`를 해결하기 위해, 기존 DOM 파서 실패 시 SAX 파서로 자동 전환(Fallback)하는 안정적인 파싱 시스템을 구축한다.

---

## 1. 개요

### 1.1. 현상
- 현재 시스템은 `xml.etree.ElementTree` (DOM 파서)를 사용하여 MyBatis 매퍼 XML 파일을 파싱한다.
- `<if>`, `<where>` 등이 깊게 중첩된 특정 XML 파일(`UserMapper.xml` 등)에서 `RecursionError: maximum recursion depth exceeded` 오류가 발생하여 파싱에 실패한다.
- 이로 인해 해당 파일의 SQL 컴포넌트 및 관계 메타데이터가 누락되는 심각한 문제가 발생한다.

### 1.2. 해결 전략
- **기본 파서는 기존 DOM 방식을 유지**하여, 대부분의 정상적인 XML 파일에 대한 호환성과 기존 코드의 안정성을 보장한다.
- DOM 파싱 중 `RecursionError`가 발생하는 **예외적인 경우에만 SAX 파서로 Fallback**하여 파싱을 재시도한다.
- 두 파서는 **동일한 포맷의 결과물을 반환**하여, 파싱 이후의 데이터 처리 로직에 영향을 주지 않도록 한다.

---

## 2. 상세 개발 계획

### 2.1. [수정] 메인 파싱 진입 함수 변경

기존에 XML 파싱을 총괄하던 함수(예: `MyBatisParser.parse_file`)의 내부 로직을 다음과 같이 수정한다.

**파일 위치**: `src/parsers/xml_parser.py` (가정)
**클래스/함수**: `MyBatisParser.parse_file(self, xml_file_path)` (가정)

```python
# src/parsers/xml_parser.py (가정)
import logging
from .sax_fallback_parser import MyBatisSaxParser # 2.2 단계에서 새로 생성할 클래스

class MyBatisParser:
    # ... 기존 코드 ...

    def parse_file(self, xml_file_path: str) -> dict:
        """
        XML 파일을 파싱한다. DOM 파싱 실패 시 SAX 파서로 Fallback한다.
        """
        try:
            # 1. 기존 DOM 파서를 우선적으로 시도한다.
            logging.info(f"[DOM] Starting DOM parsing for {xml_file_path}")
            # _parse_with_dom은 기존의 파싱 로직을 담은 private 메소드
            dom_results = self._parse_with_dom(xml_file_path) 
            logging.info(f"[DOM] Successfully parsed {xml_file_path} with DOM parser.")
            return dom_results

        except RecursionError as e:
            # 2. RecursionError 발생 시, 경고 로그를 남기고 SAX 파서로 재시도한다.
            logging.warning(f"[DOM-FAIL] RecursionError in {xml_file_path}. Falling back to SAX parser. Error: {e}")
            
            try:
                sax_parser = MyBatisSaxParser()
                sax_results = sax_parser.parse_file(xml_file_path)
                logging.info(f"[SAX-SUCCESS] Successfully parsed {xml_file_path} with SAX parser.")
                return sax_results
            except Exception as sax_e:
                # 3. SAX 파서마저 실패하는 경우, 최종 에러를 기록하고 반환한다.
                error_message = f"SAX fallback also failed for {xml_file_path}: {sax_e}"
                logging.error(error_message)
                return {'has_error': 'Y', 'error_message': error_message, 'components': []}

        except Exception as e:
            # 4. 그 외 다른 예외 발생 시, 에러를 기록하고 반환한다.
            error_message = f"An unexpected error occurred during parsing {xml_file_path}: {e}"
            logging.error(error_message)
            return {'has_error': 'Y', 'error_message': error_message, 'components': []}

    def _parse_with_dom(self, xml_file_path: str) -> dict:
        """
        기존의 DOM 파싱 로직 전체를 이 메소드로 옮긴다.
        성공 시, 2.3 단계에서 정의한 '통합 데이터 구조'로 결과를 포맷하여 반환한다.
        """
        # ... 여기에 기존 ElementTree 파싱 로직을 전부 이동 ...
        
        # 예시:
        # root = ET.parse(xml_file_path).getroot()
        # components = []
        # for node in root.findall('.//select'):
        #     components.append({
        #         'id': node.get('id'),
        #         'type': 'select',
        #         'content': ET.tostring(node, method='text', encoding='unicode').strip()
        #     })
        
        # return {'has_error': 'N', 'error_message': '', 'components': components}
        pass # 실제 구현 필요

```

### 2.2. [신규] SAX Fallback 파서 구현

`RecursionError` 발생 시 호출될 SAX 파서를 새 파일에 구현한다.

**신규 파일 위치**: `src/parsers/sax_fallback_parser.py`
**신규 클래스**: `MyBatisSaxParser`, `MyBatisSaxHandler`

```python
# src/parsers/sax_fallback_parser.py
import xml.sax
import logging

class MyBatisSaxHandler(xml.sax.ContentHandler):
    """
    MyBatis 매퍼 XML을 파싱하기 위한 SAX 이벤트 핸들러
    """
    def __init__(self):
        super().__init__()
        # --- 상태 관리 변수 ---
        self.is_in_sql_tag = False      # select, insert, update, delete 태그 내부에 있는지 여부
        self.current_tag = ""           # 현재 처리 중인 태그 이름
        self.current_sql_id = ""        # 현재 SQL 태그의 ID
        self.current_sql_type = ""      # 현재 SQL 태그의 타입 (select, insert 등)
        self.sql_buffer = []            # SQL 구문 조각을 모으는 버퍼
        
        # --- 최종 결과물 ---
        self.parsed_components = []

    def startElement(self, tag, attributes):
        """여는 태그를 만났을 때 호출"""
        self.current_tag = tag
        sql_tags = ["select", "insert", "update", "delete"]
        
        if tag in sql_tags:
            self.is_in_sql_tag = True
            self.current_sql_type = tag
            self.current_sql_id = attributes.get("id", "")
            self.sql_buffer = [] # 새 SQL 태그 시작 시 버퍼 초기화

    def characters(self, content):
        """태그 내의 텍스트 데이터를 만났을 때 호출"""
        # characters는 여러 번 호출될 수 있으므로 버퍼에 계속 추가한다.
        if self.is_in_sql_tag and content.strip():
            self.sql_buffer.append(content)

    def endElement(self, tag):
        """닫는 태그를 만났을 때 호출"""
        sql_tags = ["select", "insert", "update", "delete"]

        if tag in sql_tags:
            # SQL 태그가 끝나면, 버퍼에 모인 텍스트를 합쳐서 결과물에 추가
            full_sql = "".join(self.sql_buffer).strip()
            
            self.parsed_components.append({
                "id": self.current_sql_id,
                "type": self.current_sql_type,
                "content": full_sql
            })
            
            # 상태 변수 초기화
            self.is_in_sql_tag = False
            self.current_tag = ""
            self.current_sql_id = ""
            self.current_sql_type = ""
            self.sql_buffer = []

class MyBatisSaxParser:
    """
    SAX 파서를 감싸는 래퍼 클래스
    """
    def parse_file(self, xml_file_path: str) -> dict:
        """
        주어진 XML 파일을 SAX 방식으로 파싱한다.
        """
        try:
            # 1. 파서와 핸들러 인스턴스 생성
            parser = xml.sax.make_parser()
            handler = MyBatisSaxHandler()
            parser.setContentHandler(handler)
            
            # 2. 파싱 실행
            with open(xml_file_path, 'r', encoding='utf-8') as f:
                parser.parse(f)
            
            # 3. 성공 결과 반환 (통합 데이터 구조에 맞춰)
            return {
                'has_error': 'N',
                'error_message': '',
                'components': handler.parsed_components
            }
        except xml.sax.SAXParseException as e:
            # XML 문법 오류 등 파싱 실패 시
            error_message = f"SAX parsing failed due to malformed XML in {xml_file_path}: {e}"
            logging.error(error_message)
            return {'has_error': 'Y', 'error_message': error_message, 'components': []}
        except Exception as e:
            # 파일 IO 오류 등 기타 예외
            error_message = f"An unexpected error occurred during SAX parsing of {xml_file_path}: {e}"
            logging.error(error_message)
            return {'has_error': 'Y', 'error_message': error_message, 'components': []}

```

### 2.3. [정의] 통합 데이터 구조

DOM 파서와 SAX 파서는 아래와 같이 **완전히 동일한 형식의 딕셔너리**를 반환해야 한다.

#### 성공 시 반환 구조
```json
{
    "has_error": "N",
    "error_message": "",
    "components": [
        {
            "id": "findUserById",
            "type": "select",
            "content": "SELECT user_id, user_name FROM users WHERE user_id = #{userId}"
        },
        {
            "id": "insertUser",
            "type": "insert",
            "content": "INSERT INTO users (user_id, user_name) VALUES (#{userId}, #{userName})"
        }
    ]
}
```

#### 실패 시 반환 구조
```json
{
    "has_error": "Y",
    "error_message": "파싱 실패 원인에 대한 상세 메시지",
    "components": []
}
```

---

## 3. 테스트 계획

1.  **정상 케이스**:
    - **대상**: 단순한 구조의 XML 파일
    - **검증**: 기존 DOM 파서로 성공적으로 파싱되며, SAX Fallback이 발생하지 않는지 로그로 확인.

2.  **Fallback 케이스**:
    - **대상**: `UserMapper.xml` (재귀 깊이 초과를 유발하는 파일)
    - **검증**:
        - `RecursionError`가 발생하고 Fallback이 일어나는지 경고 로그로 확인.
        - SAX 파서가 성공적으로 동작하여 SQL 컴포넌트들을 정상적으로 추출하는지 결과물 확인.

3.  **실패 케이스**:
    - **대상**: 문법이 깨진(Malformed) XML 파일
    - **검증**: DOM 파서에서 `xml.etree.ElementTree.ParseError`가 발생하고, 정의된 에러 구조를 반환하는지 확인. (이 경우는 SAX로 넘어가지 않아야 함)

4.  **SAX 실패 케이스**:
    - **대상**: 인코딩이 맞지 않거나, SAX 파서가 처리할 수 없는 오류를 포함한 파일 (테스트용으로 생성)
    - **검증**: DOM 실패 후 SAX Fallback이 시도되었으나, SAX마저 실패하여 최종 에러 구조를 반환하는지 확인.

---

## 4. 기대 효과

- `RecursionError`로 인해 파싱이 중단되던 문제가 해결되어 시스템 안정성이 향상된다.
- 복잡한 MyBatis 매퍼 파일도 누락 없이 파싱하여 메타데이터 추출의 정확성과 완전성이 크게 향상된다.
- 기존 코드를 최대한 유지하면서 문제점을 해결하여, 코드 변경으로 인한 사이드 이펙트를 최소화한다.
