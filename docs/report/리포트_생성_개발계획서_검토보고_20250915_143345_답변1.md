# 리포트 생성 개발계획서 검토보고 답변

## 1. CallChainReport 검토보고에 대한 의견

### 1.1 문제점 검토 의견

#### 1.1.1 누락된 연계 경로 (JSP -> Class)
**검토의견: 완전 동의 - 쿼리 수정 필요**

- **현재 상황**: 개발계획서의 쿼리가 Class부터 시작하여 JSP로부터 시작되는 전체 연계 경로를 누락했습니다.
- **정확한 연계 구조**: JSP → Method → Class (Method의 parent_id로 Class 연결) → Method → XML → Query → Table
- **수정된 쿼리**:
  ```sql
  SELECT 
      ROW_NUMBER() OVER (ORDER BY jsp_file.file_name, m.component_name) as chain_id,
      jsp_file.file_name as jsp_file,
      m.component_name as method_name,
      cls.component_name as class_name,
      xml_file.file_name as xml_file,
      q.component_name as query_id,
      q.component_type as query_type,
      GROUP_CONCAT(DISTINCT t.table_name, ', ') as related_tables
  FROM files jsp_file
  JOIN relationships r1 ON jsp_file.file_id = r1.src_id AND r1.rel_type = 'CALL_METHOD'
  JOIN components m ON r1.dst_id = m.component_id AND m.component_type = 'METHOD'
  JOIN components cls ON m.parent_id = cls.component_id AND cls.component_type = 'CLASS'
  JOIN relationships r2 ON m.component_id = r2.src_id AND r2.rel_type = 'CALL_QUERY'
  JOIN components q ON r2.dst_id = q.component_id AND q.component_type IN ('QUERY', 'SQL_SELECT', 'SQL_INSERT', 'SQL_UPDATE', 'SQL_DELETE', 'SQL_MERGE')
  JOIN files xml_file ON q.file_id = xml_file.file_id
  LEFT JOIN relationships r3 ON q.component_id = r3.src_id AND r3.rel_type = 'QUERY_TABLE'
  LEFT JOIN tables t ON r3.dst_id = t.component_id
  JOIN projects p ON jsp_file.project_id = p.project_id
  WHERE p.project_name = ? 
    AND jsp_file.file_type = 'JSP'
    AND jsp_file.del_yn = 'N'
    AND m.del_yn = 'N'
    AND cls.del_yn = 'N'
    AND q.del_yn = 'N'
  GROUP BY jsp_file.file_name, m.component_name, cls.component_name, xml_file.file_name, q.component_name, q.component_type
  ORDER BY jsp_file.file_name, m.component_name;
  ```
- **핵심 수정사항**:
  1. `files jsp_file` 테이블을 시작점으로 설정
  2. `jsp_file.file_id = r1.src_id AND r1.rel_type = 'CALL_METHOD'`로 JSP에서 Method 호출 관계 추가
  3. `m.parent_id = cls.component_id`로 Method에서 Class 연결
  4. 테이블 컬럼에 `jsp_file` 추가하여 JSP 파일명 표시

#### 1.1.2 비효율적인 데이터 조회 (GROUP_CONCAT)
**검토의견: 완전 동의**

- **현재 문제**: SQLite의 GROUP_CONCAT 기본 제한(1,000,000바이트)과 성능 이슈가 실제로 발생할 수 있습니다.
- **개선안**: 다음과 같이 수정하겠습니다:
  ```sql
  -- 1단계: 기본 연계 체인 조회
  SELECT cls.component_name, m.component_name, xml_file.file_name, q.component_name, q.component_type
  FROM components cls
  JOIN components m ON cls.component_id = m.parent_id
  -- ... 기타 조인
  
  -- 2단계: 각 쿼리별 테이블 정보 별도 조회
  SELECT q.component_id, GROUP_CONCAT(t.table_name) as related_tables
  FROM components q
  LEFT JOIN relationships r2 ON q.component_id = r2.src_id
  LEFT JOIN tables t ON r2.dst_id = t.component_id
  WHERE q.component_id IN (위 쿼리 결과의 component_id들)
  GROUP BY q.component_id
  ```

#### 1.1.3 하드코딩된 필터 옵션
**검토의견: 완전 동의**

- **개선안**: 동적 필터 옵션 생성으로 수정하겠습니다:
  ```python
  def _get_filter_options(self) -> Dict[str, List[str]]:
      # 동적으로 쿼리 타입 조회
      query_types_query = """
          SELECT DISTINCT component_type 
          FROM components 
          WHERE component_type LIKE 'SQL_%' OR component_type = 'QUERY'
          AND project_id = (SELECT project_id FROM projects WHERE project_name = ?)
          AND del_yn = 'N'
      """
      query_types = [row['component_type'] for row in self.db_utils.execute_query(query_types_query, (self.project_name,))]
  ```

#### 1.1.4 클라이언트 사이드 필터링의 한계
**검토의견: 부분적으로 동의**

- **현재 한계**: 대용량 데이터에서는 실제로 성능 문제가 발생할 수 있습니다.
- **제안**: 초기에는 클라이언트 사이드 필터링으로 구현하되, 데이터가 1000건 이상일 경우 서버 사이드 필터링으로 전환하는 하이브리드 접근법을 제안합니다.
- **구현 계획**: 
  - 1단계: 클라이언트 사이드 필터링으로 MVP 구현
  - 2단계: 데이터량에 따른 서버 사이드 필터링 자동 전환 로직 추가

#### 1.1.5 불완전한 통계 정보
**검토의견: 완전 동의**

- **개선안**: 관계 유형별 상세 통계 제공:
  ```sql
  SELECT 
      CASE 
          WHEN rel_type LIKE 'JOIN_%' THEN 'JOIN'
          WHEN rel_type = 'FK' THEN 'FOREIGN_KEY'
          WHEN rel_type = 'CALL_METHOD' THEN 'METHOD_CALL'
          WHEN rel_type = 'CALL_QUERY' THEN 'QUERY_CALL'
          ELSE 'OTHER'
      END as relation_category,
      COUNT(*) as count
  FROM relationships r
  JOIN projects p ON r.project_id = p.project_id
  WHERE p.project_name = ? AND r.del_yn = 'N'
  GROUP BY relation_category
  ```

### 1.2 개선점 검토 의견

#### 1.2.1 전체 연계 경로 추적
**의견: 즉시 구현 가능**

- **구현 계획**: 위에서 제시한 수정된 쿼리를 사용하여 JSP부터 시작하는 완전한 연계 경로를 구현하겠습니다.
- **데이터 흐름**: JSP 파일 → Method 호출 → Class 소속 → Method → XML → Query → Table
- **테이블 구조 변경**: 기존 테이블에 `jsp_file` 컬럼을 추가하여 JSP 파일명을 표시
- **HTML 템플릿 수정**: 테이블 헤더에 "JSP 파일" 컬럼 추가

#### 1.2.2 서버 사이드 필터링
**의견: 단계적 구현**

- 1단계: 클라이언트 사이드 필터링으로 기본 기능 구현
- 2단계: 성능 최적화를 위한 서버 사이드 필터링 추가
- 페이지네이션은 초기 버전에서는 제외하고, 필요시 후속 버전에서 추가

## 2. ERD Report 검토보고에 대한 의견

### 2.1 문제점 검토 의견

#### 2.1.1 N+1 쿼리 문제
**검토의견: 완전 동의**

- **개선안**: 단일 쿼리로 최적화하겠습니다:
  ```sql
  SELECT 
      t.table_name,
      c.column_name,
      c.data_type,
      c.is_primary_key,
      c.is_nullable,
      c.column_order
  FROM tables t
  JOIN columns c ON t.table_id = c.table_id
  JOIN projects p ON t.project_id = p.project_id
  WHERE p.project_name = ? 
    AND t.del_yn = 'N' 
    AND c.del_yn = 'N'
  ORDER BY t.table_name, c.column_order
  ```

#### 2.1.2 오프라인 환경 미지원 (Mermaid.js CDN)
**검토의견: 완전 동의**

- **해결방안**: Mermaid.js 파일을 프로젝트에 포함시키고 로컬 경로로 로드하겠습니다:
  ```html
  <!-- CDN 대신 로컬 파일 사용 -->
  <script src="./libs/mermaid.min.js"></script>
  ```
- **구현 계획**: 
  1. Mermaid.js 파일을 `./libs/` 디렉토리에 포함
  2. HTML 템플릿에서 상대 경로로 로드
  3. 오프라인 환경에서 테스트

#### 2.1.3 부정확한 Mermaid 문법
**검토의견: 완전 동의**

- **PK 표시 개선**: Mermaid ERD에서 PK는 컬럼명 옆에 `PK` 표시가 아닌, 관계 정의에서 표현해야 합니다.
- **관계 유형별 시각화 개선**:
  ```javascript
  // 관계 유형별 다른 선 스타일 적용
  const relationshipStyle = {
      'FK': '||--o{',           // Foreign Key
      'JOIN_EXPLICIT': '||--||', // Explicit Join
      'JOIN_IMPLICIT': '}o--o{', // Implicit Join
      'INHERITANCE': '||--||'    // Inheritance
  };
  ```

#### 2.1.4 과도한 데이터 타입 단순화
**검토의견: 부분적으로 동의**

- **개선안**: 기본 다이어그램에서는 간소화하되, 상세 정보 테이블에서는 원본 데이터 타입을 보존:
  ```python
  def _normalize_data_type(self, data_type: str) -> str:
      # 다이어그램용 간소화
      if data_type.upper().startswith(('VARCHAR', 'CHAR', 'TEXT')):
          return 'string'
      elif data_type.upper().startswith('INT'):
          return 'int'
      # ... 기타 타입들
      return data_type
  ```

#### 2.1.5 사용성 부족한 UI (패닝 기능)
**검토의견: 동의하되 우선순위 조정**

- **구현 계획**: 
  - 1단계: 기본 확대/축소 기능 구현
  - 2단계: 패닝 기능 추가 (마우스 드래그로 이동)
- **기술적 구현**:
  ```javascript
  // 패닝 기능 구현
  let isPanning = false;
  let startX, startY;
  
  diagram.addEventListener('mousedown', (e) => {
      isPanning = true;
      startX = e.clientX;
      startY = e.clientY;
  });
  
  diagram.addEventListener('mousemove', (e) => {
      if (isPanning) {
          // 다이어그램 이동 로직
      }
  });
  ```

## 3. 종합 의견 및 구현 계획

### 3.1 우선순위별 구현 계획

#### 높은 우선순위 (즉시 수정)
1. **JSP 연계 경로 추가** (CallChain Report) - 완전한 연계 체인 구현
2. **N+1 쿼리 문제 해결** (ERD Report)
3. **오프라인 환경 지원** (Mermaid.js 로컬화)
4. **동적 필터 옵션 생성** (CallChain Report)

#### 중간 우선순위 (1차 개선)
1. **GROUP_CONCAT 성능 개선** (CallChain Report)
2. **Mermaid 문법 수정** (ERD Report)
3. **관계 유형별 상세 통계** (CallChain Report)

#### 낮은 우선순위 (2차 개선)
1. **서버 사이드 필터링** (CallChain Report)
2. **패닝 기능 추가** (ERD Report)

### 3.2 기술적 제약사항 고려

- **메타데이터베이스 스키마**: JSP → Method → Class 연계 구조가 확인되어 즉시 구현 가능
- **성능 vs 기능**: 초기에는 기본 기능에 집중하고, 성능 최적화는 단계적으로 진행
- **호환성**: 기존 코드와의 호환성을 유지하면서 점진적 개선
- **테이블 구조 변경**: JSP 파일 컬럼 추가로 인한 HTML 템플릿 수정 필요

### 3.3 검토보고에 대한 감사

제시해주신 문제점들은 모두 타당하며, 실제 운영 환경에서 발생할 수 있는 중요한 이슈들입니다. 특히 **JSP 연계 경로 누락**은 CallChain Report의 핵심 기능이므로 최우선으로 수정하겠습니다.

**핵심 수정 사항 요약:**
1. **JSP → Method → Class → Method → XML → Query → Table** 완전한 연계 경로 구현
2. **테이블 컬럼 추가**: JSP 파일명을 표시하는 컬럼 추가
3. **쿼리 구조 개선**: JSP 파일을 시작점으로 하는 JOIN 구조로 변경

제안해주신 개선점들을 단계적으로 구현하여 더욱 견고하고 사용자 친화적인 리포트 생성 시스템을 만들어가겠습니다.
