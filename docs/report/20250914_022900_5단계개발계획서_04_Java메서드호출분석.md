# 6단계 개발계획서 - Java 메서드 호출 분석

## 문서 정보
- **작성일**: 2025-09-14 02:29:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서
- **대상 단계**: 6단계 - Java 메서드 호출 분석

## 1. Java 메서드 호출 분석 개요

### 1.1 분석 대상
- **스크립틀릿**: `<% ... %>` 태그 내 Java 코드
- **표현식**: `<%= ... %>` 태그 내 Java 표현식
- **EL**: `${...}` 표현식 언어
- **JSTL**: JSP Standard Tag Library 태그

### 1.2 분석 과정
1. **JSP 요소 추출**: 스크립틀릿, 표현식, EL, JSTL 추출
2. **Java 메서드 호출 패턴 분석**: 정규식으로 메서드 호출 패턴 매칭
3. **클래스명 추출**: 메서드 호출에서 클래스명 추출
4. **관계 정보 생성**: JSP → METHOD 관계 정보 생성

## 2. JSP 요소 분석

### 2.1 스크립틀릿 분석

```python
def _analyze_scriptlets(self, jsp_content: str) -> List[Dict[str, Any]]:
    """
    스크립틀릿 분석
    
    Args:
        jsp_content: JSP 파일 내용
        
    Returns:
        스크립틀릿에서 추출된 Java 메서드 호출 정보
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        scriptlet_patterns = self.config.get('jsp_scriptlet_patterns', [])
        
        method_calls = []
        for pattern in scriptlet_patterns:
            matches = re.finditer(pattern, jsp_content, re.MULTILINE | re.DOTALL)
            for match in matches:
                scriptlet_content = match.group(1)
                line_number = jsp_content[:match.start()].count('\n') + 1
                
                # 스크립틀릿 내 Java 메서드 호출 분석
                scriptlet_method_calls = self._extract_method_calls_from_scriptlet(
                    scriptlet_content, line_number
                )
                method_calls.extend(scriptlet_method_calls)
        
        return method_calls
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"스크립틀릿 분석 실패: {str(e)}")
        return []
```

### 2.2 표현식 분석

```python
def _analyze_expressions(self, jsp_content: str) -> List[Dict[str, Any]]:
    """
    표현식 분석
    
    Args:
        jsp_content: JSP 파일 내용
        
    Returns:
        표현식에서 추출된 Java 메서드 호출 정보
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        expression_patterns = self.config.get('jsp_expression_patterns', [])
        
        method_calls = []
        for pattern in expression_patterns:
            matches = re.finditer(pattern, jsp_content, re.MULTILINE | re.DOTALL)
            for match in matches:
                expression_content = match.group(1)
                line_number = jsp_content[:match.start()].count('\n') + 1
                
                # 표현식 내 Java 메서드 호출 분석
                expression_method_calls = self._extract_method_calls_from_expression(
                    expression_content, line_number
                )
                method_calls.extend(expression_method_calls)
        
        return method_calls
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"표현식 분석 실패: {str(e)}")
        return []
```

### 2.3 EL 분석

```python
def _analyze_el_expressions(self, jsp_content: str) -> List[Dict[str, Any]]:
    """
    EL 표현식 분석
    
    Args:
        jsp_content: JSP 파일 내용
        
    Returns:
        EL에서 추출된 Java 메서드 호출 정보
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        el_patterns = self.config.get('jsp_el_patterns', [])
        
        method_calls = []
        for pattern in el_patterns:
            matches = re.finditer(pattern, jsp_content, re.MULTILINE | re.DOTALL)
            for match in matches:
                el_content = match.group(1)
                line_number = jsp_content[:match.start()].count('\n') + 1
                
                # EL 내 Java 메서드 호출 분석
                el_method_calls = self._extract_method_calls_from_el(
                    el_content, line_number
                )
                method_calls.extend(el_method_calls)
        
        return method_calls
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"EL 분석 실패: {str(e)}")
        return []
```

### 2.4 JSTL 분석

```python
def _analyze_jstl_tags(self, jsp_content: str) -> List[Dict[str, Any]]:
    """
    JSTL 태그 분석
    
    Args:
        jsp_content: JSP 파일 내용
        
    Returns:
        JSTL에서 추출된 Java 메서드 호출 정보
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        jstl_patterns = self.config.get('jsp_jstl_patterns', [])
        
        method_calls = []
        for pattern in jstl_patterns:
            matches = re.finditer(pattern, jsp_content, re.MULTILINE | re.DOTALL)
            for match in matches:
                jstl_content = match.group(1)
                line_number = jsp_content[:match.start()].count('\n') + 1
                
                # JSTL 내 Java 메서드 호출 분석
                jstl_method_calls = self._extract_method_calls_from_jstl(
                    jstl_content, line_number
                )
                method_calls.extend(jstl_method_calls)
        
        return method_calls
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"JSTL 분석 실패: {str(e)}")
        return []
```

## 3. Java 메서드 호출 패턴 분석

### 3.1 메서드 호출 패턴 추출

```python
def _extract_method_calls_from_scriptlet(self, scriptlet_content: str, line_number: int) -> List[Dict[str, Any]]:
    """
    스크립틀릿에서 Java 메서드 호출 추출
    
    Args:
        scriptlet_content: 스크립틀릿 내용
        line_number: 라인 번호
        
    Returns:
        메서드 호출 정보 리스트
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        method_call_patterns = self.config.get('java_method_call_patterns', [])
        
        method_calls = []
        for pattern in method_call_patterns:
            matches = re.finditer(pattern, scriptlet_content, re.MULTILINE)
            for match in matches:
                method_call_info = self._parse_method_call(match, line_number)
                if method_call_info:
                    method_calls.append(method_call_info)
        
        return method_calls
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"스크립틀릿 메서드 호출 추출 실패: {str(e)}")
        return []
```

### 3.2 메서드 호출 파싱

```python
def _parse_method_call(self, match: re.Match, line_number: int) -> Optional[Dict[str, Any]]:
    """
    메서드 호출 패턴 파싱
    
    Args:
        match: 정규식 매치 객체
        line_number: 라인 번호
        
    Returns:
        메서드 호출 정보
    """
    try:
        groups = match.groups()
        
        if len(groups) >= 2:
            # object.method() 형태
            class_name = self._extract_class_name_from_object(groups[0])
            method_name = groups[1]
        elif len(groups) >= 1:
            # method() 형태
            class_name = self._infer_class_name_from_context(groups[0])
            method_name = groups[0]
        else:
            return None
        
        # 클래스명과 메서드명 유효성 검증
        if not self._is_valid_class_name(class_name) or not self._is_valid_method_name(method_name):
            return None
        
        return {
            'class_name': class_name,
            'method_name': method_name,
            'line_number': line_number,
            'rel_type': 'CALL_METHOD'
        }
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"메서드 호출 파싱 실패: {str(e)}")
        return None
```

### 3.3 클래스명 추출

```python
def _extract_class_name_from_object(self, object_name: str) -> str:
    """
    객체명에서 클래스명 추출
    
    Args:
        object_name: 객체명
        
    Returns:
        클래스명
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 클래스명 매핑 로드
        class_name_mapping = self.config.get('class_name_mapping', {})
        
        # 설정 파일에서 매핑된 클래스명 확인
        if object_name in class_name_mapping:
            return class_name_mapping[object_name]
        
        # 기본 규칙: 객체명을 클래스명으로 사용
        # 예: userService -> UserService
        return object_name[0].upper() + object_name[1:] if object_name else 'Unknown'
        
    except Exception as e:
        warning(f"클래스명 추출 실패: {object_name}, 오류: {str(e)}")
        return 'Unknown'

def _infer_class_name_from_context(self, method_name: str) -> str:
    """
    컨텍스트에서 클래스명 추론
    
    Args:
        method_name: 메서드명
        
    Returns:
        추론된 클래스명
    """
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 메서드-클래스 매핑 로드
        method_class_mapping = self.config.get('method_class_mapping', {})
        
        # 설정 파일에서 매핑된 클래스명 확인
        if method_name in method_class_mapping:
            return method_class_mapping[method_name]
        
        # 기본 규칙: 메서드명에서 클래스명 추론
        # 예: getUserList -> UserService
        if method_name.startswith('get') or method_name.startswith('find'):
            return 'UserService'
        elif method_name.startswith('save') or method_name.startswith('update'):
            return 'UserService'
        elif method_name.startswith('delete') or method_name.startswith('remove'):
            return 'UserService'
        else:
            return 'Unknown'
        
    except Exception as e:
        warning(f"클래스명 추론 실패: {method_name}, 오류: {str(e)}")
        return 'Unknown'
```

## 4. JSP 요소별 메서드 호출 분석

### 4.1 스크립틀릿 메서드 호출 분석

```python
def _extract_method_calls_from_scriptlet(self, scriptlet_content: str, line_number: int) -> List[Dict[str, Any]]:
    """
    스크립틀릿에서 Java 메서드 호출 추출
    
    Args:
        scriptlet_content: 스크립틀릿 내용
        line_number: 라인 번호
        
    Returns:
        메서드 호출 정보 리스트
    """
    try:
        method_calls = []
        
        # 1. 객체 메서드 호출 패턴: object.method()
        object_method_pattern = r'(\w+)\.(\w+)\s*\('
        matches = re.finditer(object_method_pattern, scriptlet_content)
        for match in matches:
            object_name = match.group(1)
            method_name = match.group(2)
            class_name = self._extract_class_name_from_object(object_name)
            
            method_calls.append({
                'class_name': class_name,
                'method_name': method_name,
                'line_number': line_number,
                'rel_type': 'CALL_METHOD'
            })
        
        # 2. 직접 메서드 호출 패턴: method()
        direct_method_pattern = r'(\w+)\s*\([^)]*\)'
        matches = re.finditer(direct_method_pattern, scriptlet_content)
        for match in matches:
            method_name = match.group(1)
            class_name = self._infer_class_name_from_context(method_name)
            
            method_calls.append({
                'class_name': class_name,
                'method_name': method_name,
                'line_number': line_number,
                'rel_type': 'CALL_METHOD'
            })
        
        return method_calls
        
    except Exception as e:
        warning(f"스크립틀릿 메서드 호출 추출 실패: {str(e)}")
        return []
```

### 4.2 표현식 메서드 호출 분석

```python
def _extract_method_calls_from_expression(self, expression_content: str, line_number: int) -> List[Dict[str, Any]]:
    """
    표현식에서 Java 메서드 호출 추출
    
    Args:
        expression_content: 표현식 내용
        line_number: 라인 번호
        
    Returns:
        메서드 호출 정보 리스트
    """
    try:
        method_calls = []
        
        # 표현식은 주로 메서드 호출 결과를 출력하는 용도
        # object.method() 패턴 분석
        object_method_pattern = r'(\w+)\.(\w+)\s*\('
        matches = re.finditer(object_method_pattern, expression_content)
        for match in matches:
            object_name = match.group(1)
            method_name = match.group(2)
            class_name = self._extract_class_name_from_object(object_name)
            
            method_calls.append({
                'class_name': class_name,
                'method_name': method_name,
                'line_number': line_number,
                'rel_type': 'CALL_METHOD'
            })
        
        return method_calls
        
    except Exception as e:
        warning(f"표현식 메서드 호출 추출 실패: {str(e)}")
        return []
```

### 4.3 EL 메서드 호출 분석

```python
def _extract_method_calls_from_el(self, el_content: str, line_number: int) -> List[Dict[str, Any]]:
    """
    EL에서 Java 메서드 호출 추출
    
    Args:
        el_content: EL 내용
        line_number: 라인 번호
        
    Returns:
        메서드 호출 정보 리스트
    """
    try:
        method_calls = []
        
        # EL에서 메서드 호출 패턴 분석
        # ${object.method()} 형태
        el_method_pattern = r'(\w+)\.(\w+)\s*\('
        matches = re.finditer(el_method_pattern, el_content)
        for match in matches:
            object_name = match.group(1)
            method_name = match.group(2)
            class_name = self._extract_class_name_from_object(object_name)
            
            method_calls.append({
                'class_name': class_name,
                'method_name': method_name,
                'line_number': line_number,
                'rel_type': 'CALL_METHOD'
            })
        
        # EL에서 프로퍼티 접근 패턴 분석
        # ${object.property} 형태 (getter 메서드 호출로 간주)
        el_property_pattern = r'(\w+)\.(\w+)(?!\s*\()'
        matches = re.finditer(el_property_pattern, el_content)
        for match in matches:
            object_name = match.group(1)
            property_name = match.group(2)
            class_name = self._extract_class_name_from_object(object_name)
            
            # 프로퍼티명을 getter 메서드명으로 변환
            method_name = f"get{property_name[0].upper()}{property_name[1:]}"
            
            method_calls.append({
                'class_name': class_name,
                'method_name': method_name,
                'line_number': line_number,
                'rel_type': 'CALL_METHOD'
            })
        
        return method_calls
        
    except Exception as e:
        warning(f"EL 메서드 호출 추출 실패: {str(e)}")
        return []
```

### 4.4 JSTL 메서드 호출 분석

```python
def _extract_method_calls_from_jstl(self, jstl_content: str, line_number: int) -> List[Dict[str, Any]]:
    """
    JSTL에서 Java 메서드 호출 추출
    
    Args:
        jstl_content: JSTL 내용
        line_number: 라인 번호
        
    Returns:
        메서드 호출 정보 리스트
    """
    try:
        method_calls = []
        
        # JSTL 태그 내 EL 표현식에서 메서드 호출 분석
        # <c:forEach items="${userService.getUserList()}" var="user">
        jstl_el_pattern = r'\$\{([^}]+)\}'
        matches = re.finditer(jstl_el_pattern, jstl_content)
        for match in matches:
            el_content = match.group(1)
            
            # EL 내용에서 메서드 호출 추출
            el_method_calls = self._extract_method_calls_from_el(el_content, line_number)
            method_calls.extend(el_method_calls)
        
        return method_calls
        
    except Exception as e:
        warning(f"JSTL 메서드 호출 추출 실패: {str(e)}")
        return []
```

## 5. 통합 Java 메서드 호출 분석

### 5.1 통합 분석 메서드

```python
def _analyze_java_method_calls(self, jsp_content: str) -> List[Dict[str, Any]]:
    """
    JSP 파일에서 Java 메서드 호출 분석
    
    Args:
        jsp_content: JSP 파일 내용
        
    Returns:
        Java 메서드 호출 관계 정보 리스트
    """
    try:
        method_calls = []
        
        # 1. 스크립틀릿 분석
        scriptlet_method_calls = self._analyze_scriptlets(jsp_content)
        method_calls.extend(scriptlet_method_calls)
        
        # 2. 표현식 분석
        expression_method_calls = self._analyze_expressions(jsp_content)
        method_calls.extend(expression_method_calls)
        
        # 3. EL 분석
        el_method_calls = self._analyze_el_expressions(jsp_content)
        method_calls.extend(el_method_calls)
        
        # 4. JSTL 분석
        jstl_method_calls = self._analyze_jstl_tags(jsp_content)
        method_calls.extend(jstl_method_calls)
        
        # 5. 중복 제거
        unique_method_calls = self._remove_duplicate_method_calls(method_calls)
        
        return unique_method_calls
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"Java 메서드 호출 분석 실패: {str(e)}")
        return []
```

### 5.2 중복 제거

```python
def _remove_duplicate_method_calls(self, method_calls: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    중복된 메서드 호출 제거
    
    Args:
        method_calls: 메서드 호출 정보 리스트
        
    Returns:
        중복 제거된 메서드 호출 정보 리스트
    """
    try:
        unique_calls = []
        seen_calls = set()
        
        for method_call in method_calls:
            # 클래스명과 메서드명으로 중복 체크
            call_key = f"{method_call['class_name']}.{method_call['method_name']}"
            
            if call_key not in seen_calls:
                unique_calls.append(method_call)
                seen_calls.add(call_key)
        
        return unique_calls
        
    except Exception as e:
        warning(f"중복 메서드 호출 제거 실패: {str(e)}")
        return method_calls
```

## 6. JSP → METHOD 관계 저장

### 6.1 관계 저장 로직

```python
def _save_jsp_method_relationships_to_database(self, relationships: List[Dict[str, Any]]) -> bool:
    """
    JSP → METHOD 관계를 relationships 테이블에 저장
    
    Args:
        relationships: JSP → METHOD 관계 정보 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not relationships:
            warning("저장할 JSP → METHOD 관계가 없습니다")
            return True
        
        # 프로젝트 ID 조회 (USER RULES: 공통함수 사용)
        project_id = self._get_project_id()
        if not project_id:
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "JSP → METHOD 관계 저장 실패")
            return False
        
        # 관계 데이터 변환
        relationship_data_list = []
        for rel_info in relationships:
            # JSP 컴포넌트 ID 조회
            jsp_component_id = self._get_jsp_component_id(project_id, rel_info['jsp_name'])
            if not jsp_component_id:
                warning(f"JSP 컴포넌트 ID를 찾을 수 없습니다: {rel_info['jsp_name']}")
                continue
            
            # METHOD 컴포넌트 ID 조회
            method_component_id = self._get_method_component_id(
                project_id, rel_info['class_name'], rel_info['method_name']
            )
            if not method_component_id:
                warning(f"METHOD 컴포넌트 ID를 찾을 수 없습니다: {rel_info['class_name']}.{rel_info['method_name']}")
                continue
            
            relationship_data = {
                'src_id': jsp_component_id,
                'dst_id': method_component_id,
                'rel_type': 'CALL_METHOD',
                'confidence': 1.0,
                'has_error': 'N',
                'error_message': None,
                'hash_value': '-',  # USER RULES: 하드코딩된 '-'
                'del_yn': 'N'
            }
            relationship_data_list.append(relationship_data)
        
        # 배치 저장 (USER RULES: 공통함수 사용)
        if relationship_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('relationships', relationship_data_list)
            if processed_count > 0:
                info(f"JSP → METHOD 관계 저장 완료: {processed_count}개")
                return True
            else:
                handle_error(Exception("JSP → METHOD 관계 저장 실패"), "JSP → METHOD 관계 저장 실패")
                return False
        else:
            warning("저장할 유효한 JSP → METHOD 관계가 없습니다")
            return True
            
    except Exception as e:
        handle_error(e, "JSP → METHOD 관계 저장 실패")
        return False
```

## 7. 다음 단계

다음 문서에서는 메모리 최적화 전략을 제시합니다:
- [5. 메모리 최적화 전략](./20250914_023000_6단계개발계획서_05_메모리최적화.md)
