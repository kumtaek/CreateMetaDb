# 4~5단계 통합 개발계획서 - 클래스/메서드 추출 로직

## 문서 정보
- **작성일**: 2025-09-14 02:38:00
- **작성자**: AI Assistant
- **문서 유형**: 통합 개발계획서
- **대상 단계**: 4~5단계 통합 - 클래스/메서드 추출 로직

## 1. 개요

### 1.1 추출 대상
- **클래스 정보**: 클래스명, 클래스 타입, 패키지명, 라인 범위, 상속 관계
- **메서드 정보**: 메서드명, 클래스명, 라인 범위, 매개변수, 반환 타입
- **관계 정보**: 상속 관계, 인터페이스 구현 관계

### 1.2 참조 메뉴얼
- **메뉴얼 기반**: `parser/manual/01_java/README.md` 참고
- **Java SE 언어 업데이트**: `java-se-language-updates.pdf` 활용
- **설정 파일**: `config/parser/java_keyword.yaml` 활용

## 2. 클래스 정보 추출 로직

### 2.1 클래스 추출 메서드

```python
def _extract_class_info(self, java_content: str, file_path: str) -> List[Dict[str, Any]]:
    """
    Java 파일에서 클래스 정보 추출
    
    Args:
        java_content: Java 파일 내용
        file_path: 파일 경로
        
    Returns:
        클래스 정보 리스트
    """
    try:
        classes = []
        
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        class_patterns = self.config.get('java_class_extraction_patterns', [])
        
        for pattern in class_patterns:
            matches = re.finditer(pattern, java_content, re.MULTILINE)
            for match in matches:
                class_name = match.group(1)
                class_type = self._determine_class_type(match.group(0))
                
                # 패키지명 추출 (파일 경로에서)
                package_name = self._extract_package_name(file_path)
                
                # 라인 번호 추출
                line_start = java_content[:match.start()].count('\n') + 1
                line_end = self._find_class_end_line(java_content, match.start())
                
                # 해시 값 생성
                class_content = self._extract_class_content(java_content, match.start(), line_end)
                hash_value = self._generate_hash(class_content)
                
                classes.append({
                    'class_name': class_name,
                    'class_type': class_type,
                    'package_name': package_name,
                    'line_start': line_start,
                    'line_end': line_end,
                    'parent_class_name': None,  # 나중에 상속 관계 분석에서 설정
                    'interfaces': [],  # 나중에 상속 관계 분석에서 설정
                    'hash_value': hash_value,
                    'file_path': file_path
                })
        
        return classes
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"클래스 정보 추출 실패: {str(e)}")
        return []
```

### 2.2 클래스 타입 결정

```python
def _determine_class_type(self, class_declaration: str) -> str:
    """
    클래스 선언문에서 클래스 타입 결정
    
    Args:
        class_declaration: 클래스 선언문
        
    Returns:
        클래스 타입 (CLASS, INTERFACE, ENUM)
    """
    class_declaration_lower = class_declaration.lower()
    
    if 'interface' in class_declaration_lower:
        return 'INTERFACE'
    elif 'enum' in class_declaration_lower:
        return 'ENUM'
    else:
        return 'CLASS'
```

### 2.3 패키지명 추출

```python
def _extract_package_name(self, file_path: str) -> str:
    """
    파일 경로에서 패키지명 추출
    
    Args:
        file_path: Java 파일 경로
        
    Returns:
        패키지명
    """
    try:
        # USER RULES: 공통함수 사용 - PathUtils 활용
        from util.path_utils import PathUtils
        path_utils = PathUtils()
        
        # 프로젝트 소스 경로에서 상대 경로 추출
        relative_path = path_utils.get_relative_path(file_path, self.project_source_path)
        
        # 디렉토리 구조를 패키지명으로 변환
        package_parts = relative_path.split(os.sep)[:-1]  # 파일명 제외
        package_name = '.'.join(package_parts) if package_parts else 'default'
        
        return package_name
        
    except Exception as e:
        warning(f"패키지명 추출 실패: {file_path} - {str(e)}")
        return 'default'
```

### 2.4 클래스 끝 라인 찾기

```python
def _find_class_end_line(self, java_content: str, class_start_pos: int) -> int:
    """
    클래스의 끝 라인 번호 찾기
    
    Args:
        java_content: Java 파일 내용
        class_start_pos: 클래스 시작 위치
        
    Returns:
        클래스 끝 라인 번호
    """
    try:
        # 클래스 시작 위치부터 중괄호 카운팅
        brace_count = 0
        pos = class_start_pos
        in_class = False
        
        while pos < len(java_content):
            char = java_content[pos]
            
            if char == '{':
                brace_count += 1
                in_class = True
            elif char == '}':
                brace_count -= 1
                if in_class and brace_count == 0:
                    # 클래스 끝 위치 찾음
                    return java_content[:pos].count('\n') + 1
            
            pos += 1
        
        # 클래스 끝을 찾지 못한 경우 파일 끝
        return java_content.count('\n') + 1
        
    except Exception as e:
        warning(f"클래스 끝 라인 찾기 실패: {str(e)}")
        return java_content.count('\n') + 1
```

### 2.5 클래스 내용 추출

```python
def _extract_class_content(self, java_content: str, start_pos: int, end_line: int) -> str:
    """
    클래스 내용 추출 (해시 생성용)
    
    Args:
        java_content: Java 파일 내용
        start_pos: 클래스 시작 위치
        end_line: 클래스 끝 라인
        
    Returns:
        클래스 내용
    """
    try:
        # 끝 라인까지의 내용 추출
        lines = java_content.split('\n')
        if end_line <= len(lines):
            class_lines = lines[:end_line]
            return '\n'.join(class_lines)
        else:
            return java_content[start_pos:]
            
    except Exception as e:
        warning(f"클래스 내용 추출 실패: {str(e)}")
        return ""
```

## 3. 메서드 정보 추출 로직

### 3.1 메서드 추출 메서드

```python
def _extract_method_info(self, java_content: str, file_path: str) -> List[Dict[str, Any]]:
    """
    Java 파일에서 메서드 정보 추출
    
    Args:
        java_content: Java 파일 내용
        file_path: 파일 경로
        
    Returns:
        메서드 정보 리스트
    """
    try:
        methods = []
        
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        method_patterns = self.config.get('java_method_extraction_patterns', [])
        filter_patterns = self.config.get('method_filter_patterns', {})
        
        for pattern in method_patterns:
            matches = re.finditer(pattern, java_content, re.MULTILINE | re.DOTALL)
            for match in matches:
                method_name = match.group(1)
                
                # 메서드 필터링
                if not self._should_include_method(method_name, filter_patterns):
                    continue
                
                # 클래스명 추출 (메서드가 속한 클래스)
                class_name = self._extract_class_name_for_method(java_content, match.start())
                if not class_name:
                    continue
                
                # 라인 번호 추출
                line_start = java_content[:match.start()].count('\n') + 1
                line_end = self._find_method_end_line(java_content, match.start())
                
                # 매개변수 추출
                parameters = self._extract_method_parameters(match.group(0))
                
                # 반환 타입 추출
                return_type = self._extract_return_type(match.group(0))
                
                # 해시 값 생성
                method_content = self._extract_method_content(java_content, match.start(), line_end)
                hash_value = self._generate_hash(method_content)
                
                methods.append({
                    'method_name': method_name,
                    'class_name': class_name,
                    'line_start': line_start,
                    'line_end': line_end,
                    'parameters': parameters,
                    'return_type': return_type,
                    'hash_value': hash_value,
                    'file_path': file_path
                })
        
        return methods
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"메서드 정보 추출 실패: {str(e)}")
        return []
```

### 3.2 메서드 필터링

```python
def _should_include_method(self, method_name: str, filter_patterns: Dict[str, Any]) -> bool:
    """
    메서드 포함 여부 결정
    
    Args:
        method_name: 메서드명
        filter_patterns: 필터 패턴
        
    Returns:
        포함 여부
    """
    try:
        exclude_patterns = filter_patterns.get('exclude_patterns', [])
        include_patterns = filter_patterns.get('include_patterns', [])
        
        # 제외 패턴 확인
        for pattern in exclude_patterns:
            if re.match(pattern, method_name):
                return False
        
        # 포함 패턴 확인 (포함 패턴이 있는 경우)
        if include_patterns:
            for pattern in include_patterns:
                if re.match(pattern, method_name):
                    return True
            return False
        
        # 포함 패턴이 없으면 제외 패턴만 적용
        return True
        
    except Exception as e:
        warning(f"메서드 필터링 실패: {method_name} - {str(e)}")
        return True
```

### 3.3 메서드가 속한 클래스명 추출

```python
def _extract_class_name_for_method(self, java_content: str, method_pos: int) -> str:
    """
    메서드가 속한 클래스명 추출
    
    Args:
        java_content: Java 파일 내용
        method_pos: 메서드 위치
        
    Returns:
        클래스명
    """
    try:
        # 메서드 위치 이전의 내용에서 클래스 찾기
        before_method = java_content[:method_pos]
        
        # 가장 가까운 클래스 선언 찾기
        class_patterns = self.config.get('java_class_extraction_patterns', [])
        last_class = None
        
        for pattern in class_patterns:
            matches = re.finditer(pattern, before_method, re.MULTILINE)
            for match in matches:
                last_class = match.group(1)
        
        return last_class or 'Unknown'
        
    except Exception as e:
        warning(f"클래스명 추출 실패: {str(e)}")
        return 'Unknown'
```

### 3.4 메서드 끝 라인 찾기

```python
def _find_method_end_line(self, java_content: str, method_start_pos: int) -> int:
    """
    메서드의 끝 라인 번호 찾기
    
    Args:
        java_content: Java 파일 내용
        method_start_pos: 메서드 시작 위치
        
    Returns:
        메서드 끝 라인 번호
    """
    try:
        # 메서드 시작 위치부터 중괄호 카운팅
        brace_count = 0
        pos = method_start_pos
        in_method = False
        
        while pos < len(java_content):
            char = java_content[pos]
            
            if char == '{':
                brace_count += 1
                in_method = True
            elif char == '}':
                brace_count -= 1
                if in_method and brace_count == 0:
                    # 메서드 끝 위치 찾음
                    return java_content[:pos].count('\n') + 1
            
            pos += 1
        
        # 메서드 끝을 찾지 못한 경우 파일 끝
        return java_content.count('\n') + 1
        
    except Exception as e:
        warning(f"메서드 끝 라인 찾기 실패: {str(e)}")
        return java_content.count('\n') + 1
```

### 3.5 메서드 매개변수 추출

```python
def _extract_method_parameters(self, method_declaration: str) -> List[str]:
    """
    메서드 선언에서 매개변수 추출
    
    Args:
        method_declaration: 메서드 선언문
        
    Returns:
        매개변수 리스트
    """
    try:
        # 매개변수 부분 추출
        param_pattern = r'\(([^)]*)\)'
        param_match = re.search(param_pattern, method_declaration)
        
        if not param_match:
            return []
        
        params_str = param_match.group(1).strip()
        if not params_str:
            return []
        
        # 매개변수 분리
        parameters = []
        param_parts = params_str.split(',')
        
        for param in param_parts:
            param = param.strip()
            if param:
                # 타입과 변수명 분리
                parts = param.split()
                if len(parts) >= 2:
                    param_type = ' '.join(parts[:-1])
                    param_name = parts[-1]
                    parameters.append(f"{param_type} {param_name}")
                else:
                    parameters.append(param)
        
        return parameters
        
    except Exception as e:
        warning(f"매개변수 추출 실패: {str(e)}")
        return []
```

### 3.6 반환 타입 추출

```python
def _extract_return_type(self, method_declaration: str) -> str:
    """
    메서드 선언에서 반환 타입 추출
    
    Args:
        method_declaration: 메서드 선언문
        
    Returns:
        반환 타입
    """
    try:
        # 메서드명 이전의 부분에서 반환 타입 추출
        method_name_pattern = r'(\w+)\s*\('
        method_match = re.search(method_name_pattern, method_declaration)
        
        if method_match:
            before_method = method_declaration[:method_match.start()]
            # 공백으로 분리하여 마지막 부분이 반환 타입
            parts = before_method.split()
            if parts:
                return parts[-1]
        
        return 'void'
        
    except Exception as e:
        warning(f"반환 타입 추출 실패: {str(e)}")
        return 'void'
```

### 3.7 메서드 내용 추출

```python
def _extract_method_content(self, java_content: str, start_pos: int, end_line: int) -> str:
    """
    메서드 내용 추출 (해시 생성용)
    
    Args:
        java_content: Java 파일 내용
        start_pos: 메서드 시작 위치
        end_line: 메서드 끝 라인
        
    Returns:
        메서드 내용
    """
    try:
        # 끝 라인까지의 내용 추출
        lines = java_content.split('\n')
        if end_line <= len(lines):
            method_lines = lines[:end_line]
            return '\n'.join(method_lines)
        else:
            return java_content[start_pos:]
            
    except Exception as e:
        warning(f"메서드 내용 추출 실패: {str(e)}")
        return ""
```

## 4. 해시 생성

### 4.1 해시 생성 메서드

```python
def _generate_hash(self, content: str) -> str:
    """
    내용에서 해시 값 생성
    
    Args:
        content: 해시 생성할 내용
        
    Returns:
        해시 값
    """
    try:
        # USER RULES: 공통함수 사용
        from util.hash_utils import HashUtils
        hash_utils = HashUtils()
        return hash_utils.generate_md5(content)
        
    except Exception as e:
        warning(f"해시 생성 실패: {str(e)}")
        return "-"
```

## 5. 설정 파일 구조

### 5.1 java_keyword.yaml 예시

```yaml
# Java 클래스 추출 패턴
java_class_extraction_patterns:
  - 'public\s+class\s+(\w+)'
  - 'class\s+(\w+)'
  - 'public\s+interface\s+(\w+)'
  - 'interface\s+(\w+)'
  - 'public\s+enum\s+(\w+)'
  - 'enum\s+(\w+)'

# Java 메서드 추출 패턴
java_method_extraction_patterns:
  - 'public\s+\w+\s+(\w+)\s*\('
  - 'private\s+\w+\s+(\w+)\s*\('
  - 'protected\s+\w+\s+(\w+)\s*\('
  - '\w+\s+(\w+)\s*\('

# 메서드 필터링 패턴
method_filter_patterns:
  exclude_patterns:
    - '^<init>$'
    - '^<clinit>$'
    - '^toString$'
    - '^equals$'
    - '^hashCode$'
    - '^getClass$'
  include_patterns:
    - '^(create|insert|add|register).*'
    - '^(read|get|find|search|select|list).*'
    - '^(update|modify|edit|change).*'
    - '^(delete|remove|cancel).*'
```

## 6. 다음 단계

다음 문서에서는 관계 분석 로직을 제시합니다:
- [4. 관계 분석 로직](./20250914_023800_4~5단계통합개발계획서_04_관계분석로직.md)
