# 4단계 개발계획서 - Java 파서 설계 및 구현 방안

## 문서 정보
- **작성일**: 2025-01-13 23:51:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서
- **대상 단계**: 4단계 - Java 파서 설계

## 1. Java 파서 아키텍처 설계

### 1.1 전체 아키텍처

```
JavaLoadingEngine (java_loading.py)
├── JavaParser (parser/java_parser.py)
│   ├── 클래스 정보 추출
│   ├── 메서드 정보 추출
│   └── 상속 관계 분석
├── DatabaseUtils (util/database_utils.py)
├── FileUtils (util/file_utils.py)
└── ConfigUtils (util/config_utils.py)
```

### 1.2 파일 구조

```
CreateMetaDb/
├── java_loading.py              # 4단계 메인 엔진
├── parser/
│   ├── java_parser.py           # Java 파싱 로직
│   └── xml_parser.py            # 3단계 (기존 유지)
├── config/parser/
│   └── java_keyword.yaml        # Java 파싱 설정
└── util/                        # 공통 유틸리티 (기존)
```

## 2. JavaLoadingEngine 설계

### 2.1 클래스 구조

```python
class JavaLoadingEngine:
    """Java 로딩 엔진 - 4단계 처리"""
    
    def __init__(self, project_name: str):
        """Java 로딩 엔진 초기화"""
        
    def execute_java_loading(self) -> bool:
        """4단계 처리 실행"""
        
    def _save_classes_to_database(self, classes: List[Dict[str, Any]]) -> bool:
        """클래스 정보를 classes 테이블에 저장"""
        
    def _save_method_components_to_database(self, methods: List[Dict[str, Any]]) -> bool:
        """메서드 정보를 components 테이블에 저장"""
        
    def _save_inheritance_relationships_to_database(self, relationships: List[Dict[str, Any]]) -> bool:
        """상속 관계를 classes 테이블의 parent_class_id로 저장"""
```

### 2.2 초기화 과정

```python
def __init__(self, project_name: str):
    """
    Java 로딩 엔진 초기화
    
    Args:
        project_name: 프로젝트명
    """
    self.project_name = project_name
    self.project_source_path = get_project_source_path(project_name)
    self.metadata_db_path = get_project_metadata_db_path(project_name)
    self.db_utils = None
    
    # Java 파서 초기화 (USER RULES: 공통함수 사용, 전역 프로젝트 정보 활용)
    self.java_parser = JavaParser()
    
    # 통계 정보
    self.stats = {
        'java_files_processed': 0,
        'classes_extracted': 0,
        'methods_extracted': 0,
        'method_components_created': 0,
        'inheritance_relationships_created': 0,
        'errors': 0
    }
```

### 2.3 메인 실행 로직

```python
def execute_java_loading(self) -> bool:
    """
    Java 로딩 실행: 4단계 처리
    
    Returns:
        실행 성공 여부
    """
    try:
        info("=== Java 로딩 시작: 4단계 처리 ===")
        
        # 데이터베이스 연결 (USER RULES: 공통함수 사용)
        self.db_utils = DatabaseUtils(self.metadata_db_path)
        if not self.db_utils.connect():
            error("메타데이터베이스 연결 실패")
            return False
        
        # 1. Java 파일 수집
        java_files = self.java_parser.get_filtered_java_files(self.project_source_path)
        if not java_files:
            warning("Java 파일이 없습니다")
            return True
        
        # 2. Java 파일별 통합 처리 (메모리 최적화)
        for java_file in java_files:
            try:
                # 4단계 통합 처리: 클래스/메서드 추출 + 상속 관계 분석
                analysis_result = self.java_parser.parse_java_file(java_file)
                
                # 파싱 에러 체크 (USER RULES: 파싱 에러는 계속 진행)
                if analysis_result.get('has_error') == 'Y':
                    warning(f"Java 파싱 에러로 건너뜀: {java_file} - {analysis_result.get('error_message', '')}")
                    self.stats['errors'] += 1
                    continue
                
                if analysis_result['classes']:
                    # 클래스 정보 저장
                    try:
                        if self._save_classes_to_database(analysis_result['classes']):
                            self.stats['classes_extracted'] += len(analysis_result['classes'])
                    except Exception as e:
                        handle_error(e, f"클래스 정보 저장 실패: {java_file}")
                        return False
                
                if analysis_result['methods']:
                    # 메서드 컴포넌트 저장
                    try:
                        if self._save_method_components_to_database(analysis_result['methods']):
                            self.stats['method_components_created'] += len(analysis_result['methods'])
                    except Exception as e:
                        handle_error(e, f"메서드 컴포넌트 저장 실패: {java_file}")
                        return False
                
                if analysis_result['inheritance_relationships']:
                    # 상속 관계 저장
                    try:
                        if self._save_inheritance_relationships_to_database(analysis_result['inheritance_relationships']):
                            self.stats['inheritance_relationships_created'] += len(analysis_result['inheritance_relationships'])
                    except Exception as e:
                        handle_error(e, f"상속 관계 저장 실패: {java_file}")
                        return False
                
                self.stats['java_files_processed'] += 1
                self.stats['methods_extracted'] += len(analysis_result['methods'])
                
                # 메모리 최적화: 처리 후 즉시 해제
                del analysis_result
                
            except Exception as e:
                # 시스템 에러 (데이터베이스, 메모리 등) - 프로그램 종료
                handle_error(e, f"Java 파일 처리 실패: {java_file}")
                return False
        
        # 3. 통계 정보 출력
        self._print_java_loading_statistics()
        
        info("=== Java 로딩 완료 ===")
        return True
        
    except Exception as e:
        handle_error(e, "Java 로딩 실행 실패")
        return False
    finally:
        # 데이터베이스 연결 해제
        if self.db_utils:
            self.db_utils.disconnect()
```

## 3. JavaParser 설계

### 3.1 클래스 구조

```python
class JavaParser:
    """Java 파서 - 4단계 통합 처리"""
    
    def __init__(self, config_path: str = None, project_name: str = None):
        """Java 파서 초기화"""
        
    def get_filtered_java_files(self, project_path: str = None) -> List[str]:
        """Java 파일 수집 및 필터링"""
        
    def parse_java_file(self, java_file: str) -> Dict[str, Any]:
        """Java 파일에서 클래스/메서드 정보 추출 및 상속 관계 분석"""
        
    def _extract_class_info(self, java_content: str, file_path: str) -> List[Dict[str, Any]]:
        """Java 파일에서 클래스 정보 추출"""
        
    def _extract_method_info(self, java_content: str, file_path: str) -> List[Dict[str, Any]]:
        """Java 파일에서 메서드 정보 추출"""
        
    def _analyze_inheritance_relationships(self, java_content: str) -> List[Dict[str, Any]]:
        """Java 파일에서 상속 관계 분석"""
```

### 3.2 초기화 과정

```python
def __init__(self, config_path: str = None, project_name: str = None):
    """
    Java 파서 초기화
    
    Args:
        config_path: 설정 파일 경로
        project_name: 프로젝트명 (선택적, 전역에서 가져옴)
    """
    # USER RULES: 하드코딩 지양 - 프로젝트 정보 전역 관리
    from util.global_project import get_global_project_name, get_global_project_id, is_global_project_info_set
    
    # 전역 프로젝트 정보 활용 (실행 중 변경되지 않는 값)
    if is_global_project_info_set():
        self.project_name = get_global_project_name()
        self.project_id = get_global_project_id()
    else:
        # 개별 설정이 있는 경우 (테스트 등)
        self.project_name = project_name
        self.project_id = None
    
    if config_path is None:
        # USER RULES: 하드코딩 지양 - 설정 파일 경로
        java_config_path = "config/parser/java_keyword.yaml"
        self.config = self._load_config(java_config_path)
    else:
        self.config_path = config_path
        self.config = self._load_config()
    
    self.stats = {
        'files_processed': 0,
        'files_skipped': 0,
        'classes_extracted': 0,
        'methods_extracted': 0,
        'inheritance_relationships_created': 0,
        'errors': 0
    }
```

### 3.3 Java 파일 수집

```python
def get_filtered_java_files(self, project_path: str = None) -> List[str]:
    """
    Java 파일 수집 및 필터링
    
    Args:
        project_path: 프로젝트 경로
        
    Returns:
        Java 파일 경로 리스트
    """
    try:
        # USER RULES: 공통함수 사용 지향
        file_utils = FileUtils()
        
        # USER RULES: 하드코딩 지양 - PathUtils 공통함수 사용
        if project_path is None and self.project_name:
            from util import PathUtils
            path_utils = PathUtils()
            project_path = path_utils.get_project_source_path(self.project_name)
        
        if not project_path:
            # USER RULES: Exception 발생시 handle_error()로 exit()
            handle_error(Exception("프로젝트 경로가 지정되지 않았습니다"), "Java 파일 수집 실패")
        
        java_files = []
        for root, dirs, files in os.walk(project_path):
            for file in files:
                if file.endswith('.java'):
                    file_path = os.path.join(root, file)
                    if self._is_valid_java_file(file_path):
                        java_files.append(file_path)
        
        info(f"Java 파일 수집 완료: {len(java_files)}개")
        return java_files
        
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        handle_error(e, "Java 파일 수집 실패")
        return []

def _is_valid_java_file(self, file_path: str) -> bool:
    """
    유효한 Java 파일인지 확인
    
    Args:
        file_path: 파일 경로
        
    Returns:
        유효성 여부
    """
    try:
        file_utils = FileUtils()
        content = file_utils.read_file(file_path)
        if not content:
            return False
        
        # 기본적인 Java 파일 검증
        java_indicators = ['class', 'interface', 'enum', 'package', 'import']
        content_lower = content.lower()
        return any(indicator in content_lower for indicator in java_indicators)
        
    except Exception as e:
        warning(f"Java 파일 확인 실패: {file_path}, 오류: {str(e)}")
        return False
```

### 3.4 통합 분석 메서드

```python
def parse_java_file(self, java_file: str) -> Dict[str, Any]:
    """
    Java 파일에서 클래스/메서드 정보 추출 및 상속 관계 분석
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        분석 결과 딕셔너리
    """
    try:
        # 1. Java 파일 읽기
        file_utils = FileUtils()
        java_content = file_utils.read_file(java_file)
        if not java_content:
            return {
                'classes': [],
                'methods': [],
                'inheritance_relationships': [],
                'file_path': java_file,
                'has_error': 'Y',
                'error_message': 'Java 파일 읽기 실패'
            }
        
        # 2. 클래스 정보 추출
        classes = self._extract_class_info(java_content, java_file)
        
        # 3. 메서드 정보 추출
        methods = self._extract_method_info(java_content, java_file)
        
        # 4. 상속 관계 분석
        inheritance_relationships = self._analyze_inheritance_relationships(java_content)
        
        # 5. 통계 업데이트
        self.stats['files_processed'] += 1
        self.stats['classes_extracted'] += len(classes)
        self.stats['methods_extracted'] += len(methods)
        self.stats['inheritance_relationships_created'] += len(inheritance_relationships)
        
        return {
            'classes': classes,
            'methods': methods,
            'inheritance_relationships': inheritance_relationships,
            'file_path': java_file
        }
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        error_message = f"Java 파싱 중 예외 발생: {str(e)}"
        warning(f"{error_message} - {java_file}")
        self.stats['errors'] += 1
        return {
            'classes': [],
            'methods': [],
            'inheritance_relationships': [],
            'file_path': java_file,
            'has_error': 'Y',
            'error_message': error_message
        }
```

## 4. 설정 파일 활용

### 4.1 java_keyword.yaml 활용

```python
def _load_config(self, config_path: str = None) -> Dict[str, Any]:
    """
    설정 파일 로드
    
    Args:
        config_path: 설정 파일 경로
        
    Returns:
        설정 딕셔너리
    """
    try:
        # USER RULES: 공통함수 사용 지향
        config_utils = ConfigUtils()
        path = config_path or self.config_path
        config = config_utils.load_yaml_config(path)
        if not config:
            # USER RULES: Exception 발생시 handle_error()로 exit()
            handle_error(Exception(f"설정 파일을 로드할 수 없습니다: {path}"), "설정 파일 로드 실패")
            return self._get_default_config()
        return config
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        handle_error(e, f"설정 파일 로드 실패: {config_path or self.config_path}")
        return self._get_default_config()

def _get_default_config(self) -> Dict[str, Any]:
    """기본 설정 반환"""
    return {
        'java_class_extraction_patterns': [
            r'public\s+class\s+(\w+)',
            r'class\s+(\w+)',
            r'public\s+interface\s+(\w+)',
            r'interface\s+(\w+)',
            r'public\s+enum\s+(\w+)',
            r'enum\s+(\w+)'
        ],
        'method_filter_patterns': {
            'exclude_patterns': [
                r'^<init>$',
                r'^<clinit>$',
                r'^toString$',
                r'^equals$',
                r'^hashCode$',
                r'^getClass$'
            ],
            'include_patterns': [
                r'^(create|insert|add|register).*',
                r'^(read|get|find|search|select|list).*',
                r'^(update|modify|edit|change).*',
                r'^(delete|remove|cancel).*'
            ]
        }
    }
```

### 4.2 설정 파일 기반 패턴 매칭

```python
def _extract_class_info(self, java_content: str, file_path: str) -> List[Dict[str, Any]]:
    """
    Java 파일에서 클래스 정보 추출
    
    Args:
        java_content: Java 파일 내용
        file_path: 파일 경로
        
    Returns:
        클래스 정보 리스트
    """
    try:
        classes = []
        
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        class_patterns = self.config.get('java_class_extraction_patterns', [])
        
        for pattern in class_patterns:
            matches = re.finditer(pattern, java_content, re.MULTILINE)
            for match in matches:
                class_name = match.group(1)
                class_type = self._determine_class_type(match.group(0))
                
                # 패키지명 추출 (파일 경로에서)
                package_name = self._extract_package_name(file_path)
                
                # 라인 번호 추출
                line_start = java_content[:match.start()].count('\n') + 1
                line_end = self._find_class_end_line(java_content, match.start())
                
                # 해시 값 생성
                class_content = self._extract_class_content(java_content, match.start(), line_end)
                hash_value = HashUtils().generate_md5(class_content)
                
                classes.append({
                    'class_name': class_name,
                    'class_type': class_type,
                    'package_name': package_name,
                    'line_start': line_start,
                    'line_end': line_end,
                    'parent_class_name': None,  # 나중에 상속 관계 분석에서 설정
                    'interfaces': [],  # 나중에 상속 관계 분석에서 설정
                    'hash_value': hash_value
                })
        
        return classes
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"클래스 정보 추출 실패: {str(e)}")
        return []
```

## 5. 데이터베이스 저장 로직

### 5.1 클래스 정보 저장

```python
def _save_classes_to_database(self, classes: List[Dict[str, Any]]) -> bool:
    """
    클래스 정보를 classes 테이블에 저장
    
    Args:
        classes: 클래스 정보 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not classes:
            warning("저장할 클래스가 없습니다")
            return True
        
        # 프로젝트 ID 조회 (USER RULES: 공통함수 사용)
        project_id = self._get_project_id()
        if not project_id:
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "클래스 정보 저장 실패")
            return False
        
        # 클래스 데이터 변환
        class_data_list = []
        for class_info in classes:
            # 파일 ID 조회
            file_id = self._get_file_id(class_info['file_path'])
            if not file_id:
                warning(f"파일 ID를 찾을 수 없습니다: {class_info['file_path']}")
                continue
            
            class_data = {
                'project_id': project_id,
                'file_id': file_id,
                'class_name': class_info['class_name'],
                'parent_class_id': None,  # 나중에 상속 관계 분석에서 업데이트
                'line_start': class_info['line_start'],
                'line_end': class_info['line_end'],
                'hash_value': class_info['hash_value'],
                'has_error': 'N',
                'error_message': None,
                'del_yn': 'N'
            }
            class_data_list.append(class_data)
        
        # 배치 저장 (USER RULES: 공통함수 사용)
        if class_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('classes', class_data_list)
            if processed_count > 0:
                info(f"클래스 정보 저장 완료: {processed_count}개")
                return True
            else:
                handle_error(Exception("클래스 정보 저장 실패"), "클래스 정보 저장 실패")
                return False
        else:
            warning("저장할 유효한 클래스가 없습니다")
            return True
            
    except Exception as e:
        handle_error(e, "클래스 정보 저장 실패")
        return False
```

### 5.2 메서드 컴포넌트 저장

```python
def _save_method_components_to_database(self, methods: List[Dict[str, Any]]) -> bool:
    """
    메서드 정보를 components 테이블에 저장
    
    Args:
        methods: 메서드 정보 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not methods:
            warning("저장할 메서드가 없습니다")
            return True
        
        # 프로젝트 ID 조회 (USER RULES: 공통함수 사용)
        project_id = self._get_project_id()
        if not project_id:
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "메서드 컴포넌트 저장 실패")
            return False
        
        # 메서드 데이터 변환
        method_data_list = []
        for method_info in methods:
            # 클래스 ID 조회 (classes 테이블에서)
            class_id = self._get_class_id(project_id, method_info['class_name'])
            if not class_id:
                warning(f"클래스 ID를 찾을 수 없습니다: {method_info['class_name']}")
                continue
            
            # 파일 ID 조회
            file_id = self._get_file_id(method_info['file_path'])
            if not file_id:
                warning(f"파일 ID를 찾을 수 없습니다: {method_info['file_path']}")
                continue
            
            method_data = {
                'project_id': project_id,
                'component_type': 'METHOD',
                'component_name': method_info['method_name'],  # 메서드명만
                'parent_id': class_id,  # 클래스의 class_id를 FK로 연결
                'file_id': file_id,
                'line_start': method_info['line_start'],
                'line_end': method_info['line_end'],
                'hash_value': method_info['hash_value'],
                'has_error': 'N',
                'error_message': None,
                'del_yn': 'N'
            }
            method_data_list.append(method_data)
        
        # 배치 저장 (USER RULES: 공통함수 사용)
        if method_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('components', method_data_list)
            if processed_count > 0:
                info(f"메서드 컴포넌트 저장 완료: {processed_count}개")
                return True
            else:
                handle_error(Exception("메서드 컴포넌트 저장 실패"), "메서드 컴포넌트 저장 실패")
                return False
        else:
            warning("저장할 유효한 메서드가 없습니다")
            return True
            
    except Exception as e:
        handle_error(e, "메서드 컴포넌트 저장 실패")
        return False
```

## 6. 다음 단계

다음 문서에서는 구체적인 클래스/메서드 추출 로직을 제시합니다:
- [3. 클래스/메서드 추출 로직](./20250113_235200_4단계개발계획서_클래스메서드추출.md)
