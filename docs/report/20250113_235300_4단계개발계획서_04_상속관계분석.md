# 4단계 개발계획서 - 상속 관계 분석 로직

## 문서 정보
- **작성일**: 2025-01-13 23:53:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서
- **대상 단계**: 4단계 - 상속 관계 분석 로직

## 1. 상속 관계 분석 개요

### 1.1 분석 대상 상속 관계

#### 1.1.1 클래스 상속 (포함 대상)
```java
// 클래스 상속 - 메타DB에 표현
public class UserService extends BaseService {
    // UserService는 BaseService를 상속
}

public class AdminService extends UserService {
    // AdminService는 UserService를 상속 (다단계 상속)
}

// 추상 클래스 상속
public class ConcreteService extends AbstractService {
    // ConcreteService는 AbstractService를 상속
}
```

#### 1.1.2 인터페이스 구현 (제외 대상)
```java
// 인터페이스 구현 - 메타DB에 표현하지 않음
public class UserServiceImpl implements UserServiceInterface {
    // implements 관계는 메타DB에 저장하지 않음
}

public class AdminServiceImpl implements UserServiceInterface, AdminServiceInterface {
    // 다중 인터페이스 구현도 메타DB에 저장하지 않음
}
```

#### 1.1.3 인터페이스 상속 (제외 대상)
```java
// 인터페이스 상속 - 메타DB에 표현하지 않음
public interface ExtendedUserService extends UserServiceInterface {
    // 인터페이스 간 상속도 메타DB에 저장하지 않음
}
```

### 1.2 메타DB 표현 방식

#### 1.2.1 classes 테이블 셀프조인
```sql
-- 상속 관계는 classes 테이블의 parent_class_id로 표현
CREATE TABLE classes (
    class_id INTEGER PRIMARY KEY,
    project_id INTEGER,
    file_id INTEGER,
    class_name VARCHAR(255),
    parent_class_id INTEGER,  -- 상속하는 부모 클래스 ID (FK)
    line_start INTEGER,
    line_end INTEGER,
    hash_value VARCHAR(255),
    has_error CHAR(1),
    error_message TEXT,
    del_yn CHAR(1)
);

-- 상속 관계 예시
-- UserService.class_id = 1001, UserService.parent_class_id = 1000 (BaseService)
-- AdminService.class_id = 1002, AdminService.parent_class_id = 1001 (UserService)
```

#### 1.2.2 relationships 테이블 미사용
- 상속 관계는 relationships 테이블에 저장하지 않음
- classes 테이블의 parent_class_id 컬럼으로만 표현
- implements 관계는 메타DB에 표현하지 않음

## 2. 상속 관계 분석 구현

### 2.1 상속 관계 추출

```python
def _analyze_inheritance_relationships(self, java_content: str) -> List[Dict[str, Any]]:
    """
    Java 파일에서 상속 관계 분석 (클래스 상속만, implements 제외)
    
    Args:
        java_content: Java 파일 내용
        
    Returns:
        상속 관계 정보 리스트
    """
    try:
        inheritance_relationships = []
        
        # 클래스 상속 패턴 (extends 키워드)
        extends_patterns = [
            r'public\s+class\s+(\w+)\s+extends\s+(\w+)',
            r'class\s+(\w+)\s+extends\s+(\w+)',
            r'public\s+abstract\s+class\s+(\w+)\s+extends\s+(\w+)',
            r'abstract\s+class\s+(\w+)\s+extends\s+(\w+)',
            r'public\s+final\s+class\s+(\w+)\s+extends\s+(\w+)',
            r'final\s+class\s+(\w+)\s+extends\s+(\w+)'
        ]
        
        for pattern in extends_patterns:
            matches = re.finditer(pattern, java_content, re.MULTILINE)
            for match in matches:
                child_class = match.group(1)
                parent_class = match.group(2)
                
                # 상속 관계 정보 생성
                relationship = {
                    'child_class': child_class,
                    'parent_class': parent_class,
                    'rel_type': 'EXTENDS'
                }
                inheritance_relationships.append(relationship)
        
        return inheritance_relationships
        
    except Exception as e:
        # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"상속 관계 분석 실패: {str(e)}")
        return []
```

### 2.2 상속 관계 저장

```python
def _save_inheritance_relationships_to_database(self, inheritance_relationships: List[Dict[str, Any]]) -> bool:
    """
    상속 관계를 classes 테이블의 parent_class_id로 저장 (relationships 테이블 사용 안함)
    
    Args:
        inheritance_relationships: 상속 관계 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not inheritance_relationships:
            warning("저장할 상속 관계가 없습니다")
            return True
        
        # 프로젝트 ID 조회 (USER RULES: 공통함수 사용)
        project_id = self._get_project_id()
        if not project_id:
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "상속 관계 저장 실패")
            return False
        
        # 상속 관계별로 parent_class_id 업데이트
        updated_count = 0
        
        for rel_info in inheritance_relationships:
            try:
                # 자식 클래스 ID 조회
                child_class_id = self._get_class_id(project_id, rel_info['child_class'])
                if not child_class_id:
                    warning(f"자식 클래스 ID를 찾을 수 없습니다: {rel_info['child_class']}")
                    continue
                
                # 부모 클래스 ID 조회
                parent_class_id = self._get_class_id(project_id, rel_info['parent_class'])
                if not parent_class_id:
                    warning(f"부모 클래스 ID를 찾을 수 없습니다: {rel_info['parent_class']}")
                    continue
                
                # classes 테이블의 parent_class_id 업데이트
                update_data = {'parent_class_id': parent_class_id}
                where_conditions = {'class_id': child_class_id}
                
                success = self.db_utils.update_record('classes', update_data, where_conditions)
                if success:
                    updated_count += 1
                    info(f"상속 관계 저장 완료: {rel_info['child_class']} extends {rel_info['parent_class']}")
                else:
                    warning(f"상속 관계 저장 실패: {rel_info['child_class']} extends {rel_info['parent_class']}")
                
            except Exception as e:
                warning(f"상속 관계 저장 중 오류: {rel_info} - {str(e)}")
                continue
        
        if updated_count > 0:
            info(f"상속 관계 저장 완료: {updated_count}개")
            return True
        else:
            warning("저장된 상속 관계가 없습니다")
            return True
            
    except Exception as e:
        handle_error(e, "상속 관계 저장 실패")
        return False
```

### 2.3 클래스 ID 조회

```python
def _get_class_id(self, project_id: int, class_name: str) -> Optional[int]:
    """
    클래스명으로 클래스 ID 조회 (classes 테이블에서)
    
    Args:
        project_id: 프로젝트 ID
        class_name: 클래스명
        
    Returns:
        클래스 ID
    """
    try:
        # USER RULES: 공통함수 사용 - DatabaseUtils의 execute_query 사용
        query = """
            SELECT class_id 
            FROM classes 
            WHERE project_id = ? AND class_name = ? AND del_yn = 'N'
        """
        result = self.db_utils.execute_query(query, (project_id, class_name))
        
        if result and len(result) > 0:
            return result[0]['class_id']
        return None
        
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        handle_error(e, f"클래스 ID 조회 실패: {class_name}")
        return None
```

## 3. 고급 상속 관계 분석

### 3.1 다단계 상속 분석

```java
// 다단계 상속 예시
public class BaseService {
    // 기본 서비스
}

public class UserService extends BaseService {
    // 사용자 서비스
}

public class AdminService extends UserService {
    // 관리자 서비스
}

// 분석 결과:
// UserService.parent_class_id = BaseService.class_id
// AdminService.parent_class_id = UserService.class_id
```

### 3.2 제네릭 상속 분석

```java
// 제네릭 상속 예시
public class BaseRepository<T> {
    // 기본 리포지토리
}

public class UserRepository extends BaseRepository<User> {
    // 사용자 리포지토리
}

// 분석 결과:
// UserRepository.parent_class_id = BaseRepository.class_id
// 제네릭 타입 정보는 별도 저장하지 않음
```

### 3.3 제네릭 상속 패턴 처리

```python
def _analyze_generic_inheritance(self, java_content: str) -> List[Dict[str, Any]]:
    """
    제네릭 상속 관계 분석
    
    Args:
        java_content: Java 파일 내용
        
    Returns:
        제네릭 상속 관계 리스트
    """
    try:
        inheritance_relationships = []
        
        # 제네릭 상속 패턴
        generic_extends_patterns = [
            r'public\s+class\s+(\w+)\s+extends\s+(\w+)<[^>]*>',
            r'class\s+(\w+)\s+extends\s+(\w+)<[^>]*>',
            r'public\s+abstract\s+class\s+(\w+)\s+extends\s+(\w+)<[^>]*>',
            r'abstract\s+class\s+(\w+)\s+extends\s+(\w+)<[^>]*>'
        ]
        
        for pattern in generic_extends_patterns:
            matches = re.finditer(pattern, java_content, re.MULTILINE)
            for match in matches:
                child_class = match.group(1)
                parent_class = match.group(2)  # 제네릭 타입 제거
                
                # 상속 관계 정보 생성
                relationship = {
                    'child_class': child_class,
                    'parent_class': parent_class,
                    'rel_type': 'EXTENDS'
                }
                inheritance_relationships.append(relationship)
        
        return inheritance_relationships
        
    except Exception as e:
        warning(f"제네릭 상속 관계 분석 실패: {str(e)}")
        return []
```

### 3.4 인터페이스 구현 제외 로직

```python
def _is_interface_implementation(self, java_content: str, class_name: str) -> bool:
    """
    인터페이스 구현 여부 확인 (제외 대상)
    
    Args:
        java_content: Java 파일 내용
        class_name: 클래스명
        
    Returns:
        인터페이스 구현 여부
    """
    try:
        # implements 패턴 확인
        implements_patterns = [
            rf'public\s+class\s+{re.escape(class_name)}\s+implements\s+',
            rf'class\s+{re.escape(class_name)}\s+implements\s+',
            rf'public\s+interface\s+{re.escape(class_name)}\s+extends\s+',
            rf'interface\s+{re.escape(class_name)}\s+extends\s+'
        ]
        
        for pattern in implements_patterns:
            if re.search(pattern, java_content, re.MULTILINE):
                return True
        
        return False
        
    except Exception as e:
        warning(f"인터페이스 구현 확인 실패: {str(e)}")
        return False
```

## 4. 상속 관계 검증 및 오류 처리

### 4.1 순환 상속 검증

```python
def _validate_inheritance_cycle(self, inheritance_relationships: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    순환 상속 검증
    
    Args:
        inheritance_relationships: 상속 관계 리스트
        
    Returns:
        검증된 상속 관계 리스트
    """
    try:
        # 상속 그래프 구성
        inheritance_graph = {}
        for rel in inheritance_relationships:
            child = rel['child_class']
            parent = rel['parent_class']
            
            if child not in inheritance_graph:
                inheritance_graph[child] = []
            inheritance_graph[child].append(parent)
        
        # 순환 참조 검사
        validated_relationships = []
        for rel in inheritance_relationships:
            if not self._has_cycle(inheritance_graph, rel['child_class'], rel['parent_class']):
                validated_relationships.append(rel)
            else:
                warning(f"순환 상속 감지: {rel['child_class']} -> {rel['parent_class']}")
        
        return validated_relationships
        
    except Exception as e:
        warning(f"상속 관계 검증 실패: {str(e)}")
        return inheritance_relationships

def _has_cycle(self, graph: Dict[str, List[str]], start: str, target: str) -> bool:
    """
    상속 그래프에서 순환 참조 검사
    
    Args:
        graph: 상속 그래프
        start: 시작 클래스
        target: 대상 클래스
        
    Returns:
        순환 참조 여부
    """
    try:
        visited = set()
        stack = [start]
        
        while stack:
            current = stack.pop()
            if current == target:
                return True
            
            if current in visited:
                continue
            
            visited.add(current)
            
            if current in graph:
                for parent in graph[current]:
                    if parent not in visited:
                        stack.append(parent)
        
        return False
        
    except Exception as e:
        warning(f"순환 참조 검사 실패: {str(e)}")
        return False
```

### 4.2 존재하지 않는 클래스 참조 검증

```python
def _validate_class_existence(self, inheritance_relationships: List[Dict[str, Any]], project_id: int) -> List[Dict[str, Any]]:
    """
    상속 관계에서 참조하는 클래스의 존재 여부 검증
    
    Args:
        inheritance_relationships: 상속 관계 리스트
        project_id: 프로젝트 ID
        
    Returns:
        검증된 상속 관계 리스트
    """
    try:
        validated_relationships = []
        
        for rel in inheritance_relationships:
            child_class_id = self._get_class_id(project_id, rel['child_class'])
            parent_class_id = self._get_class_id(project_id, rel['parent_class'])
            
            if child_class_id and parent_class_id:
                validated_relationships.append(rel)
            else:
                if not child_class_id:
                    warning(f"자식 클래스가 존재하지 않습니다: {rel['child_class']}")
                if not parent_class_id:
                    warning(f"부모 클래스가 존재하지 않습니다: {rel['parent_class']}")
        
        return validated_relationships
        
    except Exception as e:
        warning(f"클래스 존재 여부 검증 실패: {str(e)}")
        return inheritance_relationships
```

## 5. 상속 관계 통계 및 보고

### 5.1 상속 관계 통계

```python
def _generate_inheritance_statistics(self, inheritance_relationships: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    상속 관계 통계 생성
    
    Args:
        inheritance_relationships: 상속 관계 리스트
        
    Returns:
        통계 정보 딕셔너리
    """
    try:
        stats = {
            'total_inheritance_relationships': len(inheritance_relationships),
            'unique_parent_classes': set(),
            'unique_child_classes': set(),
            'inheritance_depth': {},
            'most_inherited_class': None,
            'most_inheriting_class': None
        }
        
        # 기본 통계 수집
        parent_count = {}
        child_count = {}
        
        for rel in inheritance_relationships:
            parent = rel['parent_class']
            child = rel['child_class']
            
            stats['unique_parent_classes'].add(parent)
            stats['unique_child_classes'].add(child)
            
            parent_count[parent] = parent_count.get(parent, 0) + 1
            child_count[child] = child_count.get(child, 0) + 1
        
        # 가장 많이 상속받는 클래스
        if parent_count:
            stats['most_inherited_class'] = max(parent_count, key=parent_count.get)
        
        # 가장 많이 상속하는 클래스
        if child_count:
            stats['most_inheriting_class'] = max(child_count, key=child_count.get)
        
        # 집합을 리스트로 변환
        stats['unique_parent_classes'] = list(stats['unique_parent_classes'])
        stats['unique_child_classes'] = list(stats['unique_child_classes'])
        
        return stats
        
    except Exception as e:
        warning(f"상속 관계 통계 생성 실패: {str(e)}")
        return {}
```

### 5.2 상속 관계 보고서

```python
def _print_inheritance_report(self, inheritance_relationships: List[Dict[str, Any]]):
    """
    상속 관계 보고서 출력
    
    Args:
        inheritance_relationships: 상속 관계 리스트
    """
    try:
        if not inheritance_relationships:
            info("상속 관계가 없습니다")
            return
        
        info("=== 상속 관계 분석 결과 ===")
        info(f"총 상속 관계 수: {len(inheritance_relationships)}개")
        
        # 상속 관계별 출력
        for i, rel in enumerate(inheritance_relationships, 1):
            info(f"{i:3d}. {rel['child_class']} extends {rel['parent_class']}")
        
        # 통계 정보 출력
        stats = self._generate_inheritance_statistics(inheritance_relationships)
        if stats:
            info("=== 상속 관계 통계 ===")
            info(f"고유 부모 클래스 수: {len(stats['unique_parent_classes'])}개")
            info(f"고유 자식 클래스 수: {len(stats['unique_child_classes'])}개")
            
            if stats['most_inherited_class']:
                info(f"가장 많이 상속받는 클래스: {stats['most_inherited_class']}")
            
            if stats['most_inheriting_class']:
                info(f"가장 많이 상속하는 클래스: {stats['most_inheriting_class']}")
        
    except Exception as e:
        warning(f"상속 관계 보고서 출력 실패: {str(e)}")
```

## 6. 성능 최적화

### 6.1 배치 업데이트 최적화

```python
def _save_inheritance_relationships_batch(self, inheritance_relationships: List[Dict[str, Any]]) -> bool:
    """
    상속 관계 배치 업데이트 (성능 최적화)
    
    Args:
        inheritance_relationships: 상속 관계 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not inheritance_relationships:
            return True
        
        # 프로젝트 ID 조회
        project_id = self._get_project_id()
        if not project_id:
            return False
        
        # 배치 업데이트 데이터 준비
        update_queries = []
        for rel in inheritance_relationships:
            child_class_id = self._get_class_id(project_id, rel['child_class'])
            parent_class_id = self._get_class_id(project_id, rel['parent_class'])
            
            if child_class_id and parent_class_id:
                update_queries.append({
                    'query': 'UPDATE classes SET parent_class_id = ? WHERE class_id = ?',
                    'params': (parent_class_id, child_class_id)
                })
        
        # 배치 실행
        if update_queries:
            success_count = self.db_utils.execute_batch_queries(update_queries)
            info(f"상속 관계 배치 업데이트 완료: {success_count}개")
            return success_count > 0
        
        return True
        
    except Exception as e:
        handle_error(e, "상속 관계 배치 업데이트 실패")
        return False
```

## 7. 다음 단계

다음 문서에서는 메모리 최적화 전략을 제시합니다:
- [5. 메모리 최적화 전략](./20250113_235400_4단계개발계획서_메모리최적화.md)
