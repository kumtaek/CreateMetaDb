# 5단계 개발계획서 - JSP 파서 설계 및 구현 제안1 답변

## 문서 정보
- **작성일**: 2025-01-14 15:30:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서 답변
- **대상**: 5단계 JSP 파서 설계 및 구현 제안1

## 1. 답변 개요

5단계 JSP 파서 설계 및 구현 제안1에 대한 질문들을 검토하고, User Rules를 준수하여 답변드립니다.

## 2. 문제점 및 질문에 대한 답변

### 2.1. 5단계 JSP 파서 파일 미구현

**답변**: 네, 맞습니다. 5단계 개발 요청은 다음 두 파일을 새로 생성하고 설계된 로직을 구현하는 것입니다:

- `jsp_loading.py`: 5단계 메인 엔진
- `parser/jsp_parser.py`: JSP 파싱 로직

**구현 방향**:
- 3-4단계와 완전히 독립적인 파일 구조로 개발
- User Rules 준수: 공통함수 활용, 하드코딩 지양, 예외 처리 규칙 준수
- 메모리 최적화: 스트리밍 처리로 한 파일씩만 메모리에 로드

### 2.2. `jsp_keyword.yaml` 파일 부재

**답변**: `jsp_keyword.yaml` 파일을 새로 생성해야 합니다. 기본 설정을 제안드립니다:

**파일 위치**: `config/parser/jsp_keyword.yaml`

**기본 설정 내용**:
```yaml
# JSP 파싱 패턴
jsp_scriptlet_patterns:
  - r'<%([^%]+)%>'  # 스크립틀릿

jsp_expression_patterns:
  - r'<%=([^%]+)%>'  # 표현식

jsp_el_patterns:
  - r'\$\{([^}]+)\}'  # EL 표현식

jsp_jstl_patterns:
  - r'<c:([^>]+)>'  # JSTL Core
  - r'<fmt:([^>]+)>'  # JSTL Formatting
  - r'<sql:([^>]+)>'  # JSTL SQL

# Java 메서드 호출 패턴
java_method_call_patterns:
  - r'(\w+)\.(\w+)\s*\('  # object.method()
  - r'(\w+)\s*\([^)]*\)'  # method()

# 클래스명 매핑
class_name_mapping:
  userService: UserService
  userController: UserController
  orderService: OrderService

# 메서드-클래스 매핑
method_class_mapping:
  getUserList: UserService
  saveUser: UserService
  getOrderList: OrderService
```

### 2.3. 공통 유틸리티 함수 호출 방식 확인

**답변**: 해당 함수들은 `util/path_utils.py`에 추가하여 구현해야 합니다.

**구현할 함수들**:
```python
def _get_project_id(self) -> Optional[int]:
    """프로젝트 ID 조회"""
    # util/path_utils.py의 get_project_id() 활용

def _get_file_id(self, file_path: str) -> Optional[int]:
    """파일 ID 조회"""
    # files 테이블에서 file_path로 조회

def _get_jsp_component_id(self, project_id: int, jsp_name: str) -> Optional[int]:
    """JSP 컴포넌트 ID 조회"""
    # components 테이블에서 component_type='JSP'로 조회

def _get_method_component_id(self, project_id: int, class_name: str, method_name: str) -> Optional[int]:
    """METHOD 컴포넌트 ID 조회"""
    # components 테이블에서 component_type='METHOD'로 조회
```

**User Rules 준수**:
- 공통함수 사용 지향
- 하드코딩 지양
- Windows/RHEL 크로스플랫폼 대응

### 2.4. `inferred` 메서드 자동 생성 로직 부재

**답변**: 네, JSP에서 호출하는 Java 메서드가 메타DB에 없을 경우 `inferred` 메서드를 자동으로 생성해야 합니다.

**구현 로직**:
```python
def _create_inferred_method(self, project_id: int, class_name: str, method_name: str) -> Optional[int]:
    """inferred 메서드 자동 생성"""
    try:
        # inferred 메서드 데이터 구성
        inferred_method_data = {
            'project_id': project_id,
            'component_type': 'METHOD',
            'component_name': f"{class_name}.{method_name}",
            'parent_id': None,  # inferred 메서드는 독립적
            'file_id': None,  # inferred는 파일과 연결되지 않음
            'line_start': 0,
            'line_end': 0,
            'hash_value': '-',  # User Rules: 하드코딩된 '-'
            'has_error': 'N',
            'error_message': None,
            'del_yn': 'N'
        }
        
        # components 테이블에 저장
        component_id = self.db_utils.insert_component(inferred_method_data)
        return component_id
        
    except Exception as e:
        # 시스템 에러 - 프로그램 종료
        handle_error(e, f"inferred 메서드 생성 실패: {class_name}.{method_name}")
        return None
```

## 3. 추가 개선안에 대한 답변

### 3.1. JSP 파일 유효성 검증 로직 보강

**답변**: 제안하신 개선안을 수용합니다.

**구현 방향**:
```python
def _is_valid_jsp_file(self, file_path: str) -> bool:
    """JSP 파일 유효성 검증 (보강된 로직)"""
    try:
        # 1. target_source_config.yaml 설정 확인
        if not self._is_included_file(file_path):
            return False
            
        # 2. 파일 내용 확인
        file_utils = FileUtils()
        content = file_utils.read_file(file_path)
        if not content:
            return False
        
        # 3. JSP 페이지 지시어 확인 (더 엄격한 검증)
        jsp_page_directive = r'<%@\s+page\s+[^%]+%>'
        if not re.search(jsp_page_directive, content, re.IGNORECASE):
            return False
            
        # 4. JSP 지시어/태그 확인
        jsp_indicators = ['<%@', '<%', '<%=', '<jsp:', '<c:', '<fmt:', '<sql:']
        content_lower = content.lower()
        return any(indicator in content_lower for indicator in jsp_indicators)
        
    except Exception as e:
        # 파싱 에러 - 계속 진행
        warning(f"JSP 파일 확인 실패: {file_path}, 오류: {str(e)}")
        return False
```

### 3.2. JSP 경로 추출 로직 검증 및 보강

**답변**: 제안하신 개선안을 수용합니다.

**구현 방향**:
```python
def _extract_jsp_path(self, file_path: str) -> str:
    """JSP 경로 추출 (보강된 로직)"""
    try:
        # 프로젝트 소스 경로에서 상대 경로 추출
        if self.project_name:
            from util import PathUtils
            path_utils = PathUtils()
            project_source_path = path_utils.get_project_source_path(self.project_name)
            
            if file_path.startswith(project_source_path):
                relative_path = os.path.relpath(file_path, project_source_path)
                # Windows 경로를 Unix 경로로 변환
                web_path = '/' + relative_path.replace('\\', '/')
                
                # WEB-INF 폴더 특성 고려
                if '/WEB-INF/' in web_path:
                    # WEB-INF 내부는 직접 접근 불가하므로 특별 처리
                    web_path = web_path.replace('/WEB-INF/', '/WEB-INF/')
                
                return web_path
        
        # 기본값: 파일명만 반환
        return '/' + os.path.basename(file_path)
        
    except Exception as e:
        # 파싱 에러 - 계속 진행
        warning(f"JSP 경로 추출 실패: {str(e)}")
        return '/' + os.path.basename(file_path)
```

### 3.3. `handle_error()` 함수 `sys.exit()` 호출 확인

**답변**: User Rules에 따라 확인 및 수정이 필요합니다.

**현재 상태 확인**:
- `util/logger.py`의 `handle_error()` 함수가 `sys.exit(1)`을 호출하는지 확인 필요

**User Rules 준수**:
- 파싱 에러 제외한 모든 exception 발생 시 `handle_error()`로 exit()
- 파싱 에러는 `has_error='Y'`, `error_message` 저장 후 계속 실행
- 그 밖에 warning 후 계속 실행하는 경우는 없음

## 4. User Rules 준수사항 재확인

### 4.1. 예외 처리 규칙
- **파싱 에러**: `has_error='Y'`, `error_message` 저장 후 계속 진행
- **시스템 에러**: `handle_error()` 공통함수로 exit()
- **경고**: warning 후 계속 실행하는 경우는 없음

### 4.2. 공통함수 사용
- **경로 관련**: `PathUtils` 공통함수 사용
- **파일 처리**: `FileUtils` 공통함수 사용
- **데이터베이스**: `DatabaseUtils` 공통함수 사용
- **설정**: `ConfigUtils` 공통함수 사용

### 4.3. 하드코딩 지양
- **프로젝트 해시값**: 하드코딩된 '-' 사용
- **설정 파일**: `config/parser/jsp_keyword.yaml` 활용
- **경로**: 공통함수 사용으로 하드코딩 방지

### 4.4. 메뉴얼 참고
- **JSP 파싱**: `D:\Analyzer\CreateMetaDb\parser\manual\02_jsp` 참고
- **공통 가이드**: `D:\Analyzer\CreateMetaDb\parser\manual\99_common` 참고

## 5. 구현 순서

### 5.1. 1단계: 기본 파일 생성
1. `config/parser/jsp_keyword.yaml` 생성
2. `parser/jsp_parser.py` 기본 구조 생성
3. `jsp_loading.py` 기본 구조 생성

### 5.2. 2단계: 공통함수 구현
1. `util/path_utils.py`에 필요한 함수들 추가
2. `util/logger.py`의 `handle_error()` 함수 확인/수정

### 5.3. 3단계: JSP 파싱 로직 구현
1. JSP 파일 수집 및 필터링
2. JSP 컴포넌트 정보 추출
3. Java 메서드 호출 분석

### 5.4. 4단계: 데이터베이스 저장 로직 구현
1. JSP 컴포넌트 저장
2. JSP → METHOD 관계 저장
3. inferred 메서드 자동 생성

### 5.5. 5단계: 통합 테스트
1. 전체 시스템 통합 테스트
2. User Rules 준수 확인
3. 성능 및 메모리 최적화 확인

## 6. 결론

제안하신 모든 문제점과 개선안을 수용하며, User Rules를 완전히 준수하여 5단계 JSP 파서를 구현하겠습니다. 특히 예외 처리 규칙과 공통함수 사용을 철저히 준수하여 견고하고 유지보수가 용이한 코드를 작성하겠습니다.

---

**문서 작성 완료**: 2025-01-14 15:30:00  
**답변 완료**: 모든 질문 및 개선안에 대한 답변 제공  
**다음 단계**: 5단계 JSP 파서 구현 시작
