# 4단계 개발계획서 - 메모리 최적화 전략

## 문서 정보
- **작성일**: 2025-01-13 23:54:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서
- **대상 단계**: 4단계 - 메모리 최적화 전략

## 1. 메모리 최적화 개요

### 1.1 최적화 목표
- **대용량 Java 프로젝트 처리**: 수천 개의 Java 파일을 메모리 효율적으로 처리
- **스트리밍 처리**: 한 파일씩만 메모리에 로드하여 처리
- **즉시 해제**: 파일 처리 완료 후 즉시 메모리에서 해제
- **배치 저장**: 대량 데이터를 효율적으로 데이터베이스에 저장

### 1.2 메모리 사용량 예상
```
프로젝트 규모별 메모리 사용량:
- 소규모 (100개 파일): ~50MB
- 중규모 (1,000개 파일): ~100MB
- 대규모 (10,000개 파일): ~200MB
- 초대규모 (100,000개 파일): ~500MB
```

## 2. 스트리밍 처리 전략

### 2.1 파일별 순차 처리

```python
def execute_java_loading(self) -> bool:
    """
    스트리밍 처리 기반 Java 로딩 실행
    """
    try:
        # 1. Java 파일 수집 (메모리 효율적)
        java_files = self.java_parser.get_filtered_java_files(self.project_source_path)
        if not java_files:
            return True
        
        info(f"Java 파일 수집 완료: {len(java_files)}개")
        
        # 2. 파일별 순차 처리 (스트리밍)
        for i, java_file in enumerate(java_files, 1):
            try:
                info(f"처리 중 ({i}/{len(java_files)}): {java_file}")
                
                # 3. 단일 파일 분석 (메모리 최적화)
                analysis_result = self._process_single_java_file(java_file)
                
                # 4. 즉시 데이터베이스 저장
                if analysis_result:
                    self._save_analysis_result(analysis_result)
                
                # 5. 메모리 즉시 해제
                del analysis_result
                
                # 6. 진행률 표시
                if i % 100 == 0:
                    info(f"진행률: {i}/{len(java_files)} ({i/len(java_files)*100:.1f}%)")
                
            except Exception as e:
                # 개별 파일 오류는 계속 진행
                warning(f"파일 처리 실패: {java_file} - {str(e)}")
                self.stats['errors'] += 1
                continue
        
        return True
        
    except Exception as e:
        handle_error(e, "Java 로딩 실행 실패")
        return False

def _process_single_java_file(self, java_file: str) -> Optional[Dict[str, Any]]:
    """
    단일 Java 파일 처리 (메모리 최적화)
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        분석 결과 또는 None
    """
    try:
        # 1. 파일 읽기 (스트리밍)
        java_content = self._read_java_file_streaming(java_file)
        if not java_content:
            return None
        
        # 2. 통합 분석 (한 번의 읽기로 모든 분석 수행)
        analysis_result = self.java_parser.parse_java_file(java_file)
        
        # 3. 메모리 즉시 해제
        del java_content
        
        return analysis_result
        
    except Exception as e:
        warning(f"단일 파일 처리 실패: {java_file} - {str(e)}")
        return None
```

### 2.2 스트리밍 파일 읽기

```python
def _read_java_file_streaming(self, java_file: str) -> Optional[str]:
    """
    스트리밍 방식으로 Java 파일 읽기
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        파일 내용 또는 None
    """
    try:
        # USER RULES: 공통함수 사용
        file_utils = FileUtils()
        
        # 파일 크기 확인
        file_size = os.path.getsize(java_file)
        if file_size > 10 * 1024 * 1024:  # 10MB 이상
            warning(f"대용량 파일 감지: {java_file} ({file_size/1024/1024:.1f}MB)")
        
        # 스트리밍 읽기
        content = file_utils.read_file(java_file)
        return content
        
    except Exception as e:
        warning(f"파일 읽기 실패: {java_file} - {str(e)}")
        return None
```

## 3. 메모리 사용량 최적화

### 3.1 정규식 기반 파싱

```python
class JavaParser:
    def __init__(self, config_path: str = None, project_name: str = None):
        # ... 기존 초기화 코드 ...
        
        # 정규식 패턴 미리 컴파일 (메모리 효율성)
        self._compile_patterns()
        
        # 메모리 사용량 모니터링
        self.memory_monitor = MemoryMonitor()
    
    def _compile_patterns(self):
        """정규식 패턴 미리 컴파일 (메모리 효율성)"""
        try:
            # 클래스 추출 패턴 컴파일
            class_patterns = self.config.get('java_class_extraction_patterns', [])
            self.compiled_class_patterns = [
                re.compile(pattern, re.MULTILINE) for pattern in class_patterns
            ]
            
            # 메서드 필터링 패턴 컴파일
            method_patterns = self.config.get('method_filter_patterns', {})
            exclude_patterns = method_patterns.get('exclude_patterns', [])
            include_patterns = method_patterns.get('include_patterns', [])
            
            self.compiled_exclude_patterns = [
                re.compile(pattern, re.IGNORECASE) for pattern in exclude_patterns
            ]
            self.compiled_include_patterns = [
                re.compile(pattern, re.IGNORECASE) for pattern in include_patterns
            ]
            
        except Exception as e:
            warning(f"정규식 패턴 컴파일 실패: {str(e)}")
            self.compiled_class_patterns = []
            self.compiled_exclude_patterns = []
            self.compiled_include_patterns = []
```

### 3.2 메모리 모니터링

```python
class MemoryMonitor:
    """메모리 사용량 모니터링"""
    
    def __init__(self):
        self.peak_memory = 0
        self.current_memory = 0
        self.memory_threshold = 500 * 1024 * 1024  # 500MB 임계값
    
    def check_memory_usage(self) -> bool:
        """
        메모리 사용량 확인
        
        Returns:
            메모리 사용량이 임계값 이하인지 여부
        """
        try:
            import psutil
            process = psutil.Process()
            memory_info = process.memory_info()
            self.current_memory = memory_info.rss
            
            if self.current_memory > self.peak_memory:
                self.peak_memory = self.current_memory
            
            if self.current_memory > self.memory_threshold:
                warning(f"메모리 사용량 임계값 초과: {self.current_memory/1024/1024:.1f}MB")
                return False
            
            return True
            
        except ImportError:
            # psutil이 없는 경우 모니터링 건너뛰기
            return True
        except Exception as e:
            warning(f"메모리 모니터링 실패: {str(e)}")
            return True
    
    def get_memory_stats(self) -> Dict[str, Any]:
        """메모리 통계 반환"""
        return {
            'current_memory_mb': self.current_memory / 1024 / 1024,
            'peak_memory_mb': self.peak_memory / 1024 / 1024,
            'threshold_mb': self.memory_threshold / 1024 / 1024
        }
```

### 3.3 가비지 컬렉션 최적화

```python
def _optimize_memory_usage(self):
    """메모리 사용량 최적화"""
    try:
        import gc
        
        # 가비지 컬렉션 강제 실행
        collected = gc.collect()
        if collected > 0:
            debug(f"가비지 컬렉션 완료: {collected}개 객체 해제")
        
        # 메모리 모니터링
        if hasattr(self, 'memory_monitor'):
            if not self.memory_monitor.check_memory_usage():
                warning("메모리 사용량이 높습니다. 추가 최적화가 필요할 수 있습니다.")
        
    except Exception as e:
        warning(f"메모리 최적화 실패: {str(e)}")
```

## 4. 배치 처리 최적화

### 4.1 배치 크기 동적 조정

```python
class BatchProcessor:
    """배치 처리 최적화"""
    
    def __init__(self, initial_batch_size: int = 100):
        self.initial_batch_size = initial_batch_size
        self.current_batch_size = initial_batch_size
        self.min_batch_size = 10
        self.max_batch_size = 1000
        self.memory_monitor = MemoryMonitor()
    
    def get_optimal_batch_size(self) -> int:
        """
        메모리 사용량에 따른 최적 배치 크기 계산
        
        Returns:
            최적 배치 크기
        """
        try:
            if not self.memory_monitor.check_memory_usage():
                # 메모리 사용량이 높으면 배치 크기 감소
                self.current_batch_size = max(
                    self.min_batch_size,
                    self.current_batch_size // 2
                )
                warning(f"메모리 사용량 높음. 배치 크기 감소: {self.current_batch_size}")
            else:
                # 메모리 사용량이 낮으면 배치 크기 증가
                self.current_batch_size = min(
                    self.max_batch_size,
                    self.current_batch_size + 10
                )
            
            return self.current_batch_size
            
        except Exception as e:
            warning(f"배치 크기 계산 실패: {str(e)}")
            return self.initial_batch_size
```

### 4.2 배치 저장 최적화

```python
def _save_analysis_result_batch(self, analysis_results: List[Dict[str, Any]]) -> bool:
    """
    분석 결과 배치 저장 (메모리 최적화)
    
    Args:
        analysis_results: 분석 결과 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not analysis_results:
            return True
        
        # 배치 크기 동적 조정
        batch_processor = BatchProcessor()
        optimal_batch_size = batch_processor.get_optimal_batch_size()
        
        # 배치별 처리
        total_saved = 0
        for i in range(0, len(analysis_results), optimal_batch_size):
            batch = analysis_results[i:i + optimal_batch_size]
            
            # 배치 저장
            saved_count = self._save_single_batch(batch)
            total_saved += saved_count
            
            # 메모리 최적화
            del batch
            self._optimize_memory_usage()
            
            # 진행률 표시
            progress = (i + len(batch)) / len(analysis_results) * 100
            info(f"배치 저장 진행률: {progress:.1f}% ({total_saved}개 저장)")
        
        info(f"배치 저장 완료: {total_saved}개")
        return total_saved > 0
        
    except Exception as e:
        handle_error(e, "배치 저장 실패")
        return False

def _save_single_batch(self, batch: List[Dict[str, Any]]) -> int:
    """
    단일 배치 저장
    
    Args:
        batch: 저장할 배치 데이터
        
    Returns:
        저장된 항목 수
    """
    try:
        saved_count = 0
        
        # 클래스 정보 저장
        classes = [result.get('classes', []) for result in batch]
        all_classes = [cls for class_list in classes for cls in class_list]
        if all_classes:
            if self._save_classes_to_database(all_classes):
                saved_count += len(all_classes)
        
        # 메서드 정보 저장
        methods = [result.get('methods', []) for result in batch]
        all_methods = [method for method_list in methods for method in method_list]
        if all_methods:
            if self._save_method_components_to_database(all_methods):
                saved_count += len(all_methods)
        
        # 상속 관계 저장
        relationships = [result.get('inheritance_relationships', []) for result in batch]
        all_relationships = [rel for rel_list in relationships for rel in rel_list]
        if all_relationships:
            if self._save_inheritance_relationships_to_database(all_relationships):
                saved_count += len(all_relationships)
        
        return saved_count
        
    except Exception as e:
        warning(f"단일 배치 저장 실패: {str(e)}")
        return 0
```

## 5. 대용량 파일 처리 전략

### 5.1 파일 크기별 처리 전략

```python
def _get_file_processing_strategy(self, file_path: str) -> str:
    """
    파일 크기에 따른 처리 전략 결정
    
    Args:
        file_path: 파일 경로
        
    Returns:
        처리 전략 ('normal', 'chunked', 'streaming')
    """
    try:
        file_size = os.path.getsize(file_path)
        
        if file_size < 1024 * 1024:  # 1MB 미만
            return 'normal'
        elif file_size < 10 * 1024 * 1024:  # 10MB 미만
            return 'chunked'
        else:  # 10MB 이상
            return 'streaming'
            
    except Exception as e:
        warning(f"파일 크기 확인 실패: {str(e)}")
        return 'normal'

def _process_large_file(self, java_file: str) -> Optional[Dict[str, Any]]:
    """
    대용량 파일 처리 (청크 단위)
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        분석 결과 또는 None
    """
    try:
        strategy = self._get_file_processing_strategy(java_file)
        
        if strategy == 'normal':
            return self._process_normal_file(java_file)
        elif strategy == 'chunked':
            return self._process_chunked_file(java_file)
        else:  # streaming
            return self._process_streaming_file(java_file)
            
    except Exception as e:
        warning(f"대용량 파일 처리 실패: {java_file} - {str(e)}")
        return None

def _process_chunked_file(self, java_file: str) -> Optional[Dict[str, Any]]:
    """
    청크 단위 파일 처리
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        분석 결과 또는 None
    """
    try:
        chunk_size = 1024 * 1024  # 1MB 청크
        all_classes = []
        all_methods = []
        all_relationships = []
        
        with open(java_file, 'r', encoding='utf-8') as file:
            chunk = file.read(chunk_size)
            while chunk:
                # 청크별 분석
                chunk_result = self._analyze_java_chunk(chunk)
                
                if chunk_result:
                    all_classes.extend(chunk_result.get('classes', []))
                    all_methods.extend(chunk_result.get('methods', []))
                    all_relationships.extend(chunk_result.get('inheritance_relationships', []))
                
                # 메모리 해제
                del chunk_result
                del chunk
                
                # 다음 청크 읽기
                chunk = file.read(chunk_size)
        
        return {
            'classes': all_classes,
            'methods': all_methods,
            'inheritance_relationships': all_relationships,
            'file_path': java_file
        }
        
    except Exception as e:
        warning(f"청크 파일 처리 실패: {java_file} - {str(e)}")
        return None
```

### 5.2 스트리밍 파일 처리

```python
def _process_streaming_file(self, java_file: str) -> Optional[Dict[str, Any]]:
    """
    스트리밍 파일 처리 (라인 단위)
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        분석 결과 또는 None
    """
    try:
        all_classes = []
        all_methods = []
        all_relationships = []
        
        current_class = None
        current_method = None
        brace_count = 0
        
        with open(java_file, 'r', encoding='utf-8') as file:
            for line_num, line in enumerate(file, 1):
                # 라인별 분석
                line_result = self._analyze_java_line(line, line_num, current_class, current_method)
                
                if line_result:
                    if 'class' in line_result:
                        current_class = line_result['class']
                        all_classes.append(current_class)
                    elif 'method' in line_result:
                        current_method = line_result['method']
                        all_methods.append(current_method)
                    elif 'relationship' in line_result:
                        all_relationships.append(line_result['relationship'])
                
                # 중괄호 카운팅으로 컨텍스트 추적
                brace_count += line.count('{') - line.count('}')
                
                # 메모리 최적화 (1000라인마다)
                if line_num % 1000 == 0:
                    self._optimize_memory_usage()
        
        return {
            'classes': all_classes,
            'methods': all_methods,
            'inheritance_relationships': all_relationships,
            'file_path': java_file
        }
        
    except Exception as e:
        warning(f"스트리밍 파일 처리 실패: {java_file} - {str(e)}")
        return None
```

## 6. 메모리 누수 방지

### 6.1 리소스 관리

```python
class ResourceManager:
    """리소스 관리 (메모리 누수 방지)"""
    
    def __init__(self):
        self.resources = []
    
    def register_resource(self, resource):
        """리소스 등록"""
        self.resources.append(resource)
    
    def cleanup_all(self):
        """모든 리소스 정리"""
        for resource in self.resources:
            try:
                if hasattr(resource, 'close'):
                    resource.close()
                elif hasattr(resource, 'disconnect'):
                    resource.disconnect()
                del resource
            except Exception as e:
                warning(f"리소스 정리 실패: {str(e)}")
        
        self.resources.clear()
        
        # 가비지 컬렉션 강제 실행
        import gc
        gc.collect()

def _cleanup_resources(self):
    """리소스 정리 (메모리 누수 방지)"""
    try:
        # 분석 결과 정리
        if hasattr(self, 'analysis_results'):
            del self.analysis_results
        
        # 임시 변수 정리
        if hasattr(self, 'temp_data'):
            del self.temp_data
        
        # 가비지 컬렉션
        self._optimize_memory_usage()
        
    except Exception as e:
        warning(f"리소스 정리 실패: {str(e)}")
```

### 6.2 메모리 프로파일링

```python
def _profile_memory_usage(self, operation_name: str):
    """
    메모리 사용량 프로파일링
    
    Args:
        operation_name: 작업명
    """
    try:
        import psutil
        import tracemalloc
        
        # 메모리 스냅샷 생성
        tracemalloc.start()
        snapshot = tracemalloc.take_snapshot()
        
        # 메모리 사용량 정보
        process = psutil.Process()
        memory_info = process.memory_info()
        
        info(f"=== 메모리 프로파일링: {operation_name} ===")
        info(f"RSS 메모리: {memory_info.rss / 1024 / 1024:.1f}MB")
        info(f"VMS 메모리: {memory_info.vms / 1024 / 1024:.1f}MB")
        
        # 상위 메모리 사용자
        top_stats = snapshot.statistics('lineno')
        info("상위 메모리 사용자:")
        for stat in top_stats[:5]:
            info(f"  {stat}")
        
        tracemalloc.stop()
        
    except ImportError:
        # psutil이나 tracemalloc이 없는 경우
        pass
    except Exception as e:
        warning(f"메모리 프로파일링 실패: {str(e)}")
```

## 7. 성능 모니터링

### 7.1 처리 시간 모니터링

```python
import time
from contextlib import contextmanager

@contextmanager
def time_operation(operation_name: str):
    """작업 시간 측정 컨텍스트 매니저"""
    start_time = time.time()
    try:
        yield
    finally:
        end_time = time.time()
        duration = end_time - start_time
        info(f"{operation_name} 완료: {duration:.2f}초")

def execute_java_loading(self) -> bool:
    """성능 모니터링이 포함된 Java 로딩 실행"""
    try:
        with time_operation("Java 로딩 전체"):
            # ... 기존 로직 ...
            
            for java_file in java_files:
                with time_operation(f"파일 처리: {os.path.basename(java_file)}"):
                    # ... 파일 처리 로직 ...
                    pass
        
        return True
        
    except Exception as e:
        handle_error(e, "Java 로딩 실행 실패")
        return False
```

### 7.2 통계 및 보고

```python
def _print_memory_statistics(self):
    """메모리 통계 출력"""
    try:
        if hasattr(self, 'memory_monitor'):
            stats = self.memory_monitor.get_memory_stats()
            info("=== 메모리 사용량 통계 ===")
            info(f"현재 메모리 사용량: {stats['current_memory_mb']:.1f}MB")
            info(f"최대 메모리 사용량: {stats['peak_memory_mb']:.1f}MB")
            info(f"메모리 임계값: {stats['threshold_mb']:.1f}MB")
        
        # 처리 통계
        info("=== 처리 통계 ===")
        info(f"처리된 Java 파일: {self.stats['java_files_processed']}개")
        info(f"추출된 클래스: {self.stats['classes_extracted']}개")
        info(f"추출된 메서드: {self.stats['methods_extracted']}개")
        info(f"생성된 메서드 컴포넌트: {self.stats['method_components_created']}개")
        info(f"생성된 상속 관계: {self.stats['inheritance_relationships_created']}개")
        info(f"오류 발생: {self.stats['errors']}개")
        
    except Exception as e:
        warning(f"통계 출력 실패: {str(e)}")
```

## 8. 다음 단계

다음 문서에서는 오류 처리 및 예외 상황 대응 방안을 제시합니다:
- [6. 오류 처리 및 예외 상황](./20250113_235500_4단계개발계획서_오류처리.md)
