# 5단계 개발계획서 - JSP 파서 설계 및 구현 제안2

## 1. 개요

`20250914_022700_5단계개발계획서_제안1_답변.md` 파일을 검토한 결과, 5단계 JSP 파서 구현을 위한 추가 검토 의견을 다음과 같이 제안합니다.

## 2. 추가 검토 의견

### 2.1. `jsp_keyword.yaml`의 `class_name_mapping` 및 `method_class_mapping` 활용 방안

*   **의견**: 제안된 `jsp_keyword.yaml`에 포함된 `class_name_mapping`과 `method_class_mapping`은 JSP에서 호출되는 Java 메서드의 클래스명을 추론하는 데 매우 유용할 것으로 보입니다. `_analyze_java_method_calls` 함수 내에서 이 매핑 정보를 어떻게 활용하여 `rel_info['class_name']`을 정확하게 설정할 것인지 구체적인 로직이 필요합니다.
    *   **질문**: 예를 들어, JSP에서 `userService.getUserList()`를 호출할 때, `getUserList` 메서드가 `UserService` 클래스에 속한다는 것을 이 매핑을 통해 추론하는 로직을 어떻게 구현할 것입니까? 또한, 매핑에 없는 메서드나 클래스가 호출될 경우, 어떻게 처리할 것인지(예: `inferred` 클래스/메서드 생성 또는 경고 처리)에 대한 정책도 필요합니다.

### 2.2. `inferred` 메서드 생성 시 `component_name` 형식 및 `parent_id` 설정

*   **의견**: 제안된 `_create_inferred_method` 함수에서 `component_name`을 `f"{class_name}.{method_name}"` 형식으로 설정하고 `parent_id`를 `None`으로 설정하는 것은 기존 설계와 일관성을 유지하기 위해 재고가 필요합니다.
    *   **기존 설계**: `메타데이터베이스스키마정의서.md` 및 `처리플로우_상세_4단계.md`에 따르면, `components` 테이블에 `METHOD` 타입으로 저장될 때 `component_name`은 "메서드명만" 저장하고, `parent_id`를 통해 `CLASS` 컴포넌트와 관계를 맺습니다.
    *   **질문**: `inferred` 메서드 생성 시에도 `component_name`은 "메서드명만" 저장하고, `inferred` 클래스를 먼저 생성한 후 그 `component_id`를 `parent_id`로 사용하는 것이 기존 설계와 일관성을 유지하는 방법이라고 생각합니다. 이에 대한 의견을 주십시오.

### 2.3. `_get_project_id()` 함수 구현 위치 및 방식

*   **의견**: `util/path_utils.py`에 `_get_project_id()`를 구현한다고 하셨는데, `util/global_project.py`에 이미 `get_global_project_id()` 함수가 존재합니다. `JspLoadingEngine` 초기화 시 `global_project` 모듈을 통해 `project_id`를 가져오고 있으므로, `_get_project_id()` 함수는 `global_project.py`의 `get_global_project_id()`를 활용하거나, `JspLoadingEngine` 내부에서 `self.project_id`를 직접 사용하는 것이 더 효율적입니다.
    *   **질문**: `util/path_utils.py`에 별도로 `_get_project_id()`를 구현하는 대신, `global_project.py`의 `get_global_project_id()`를 활용하는 방안에 대해 어떻게 생각하십니까?

### 2.4. `_get_file_id()` 함수 구현 방식

*   **의견**: `files` 테이블에서 `file_path`로 `file_id`를 조회한다고 하셨는데, 이 함수를 `util/path_utils.py`에 구현하고, `DatabaseUtils`를 사용하여 `files` 테이블을 조회하도록 하는 것이 적절합니다.
    *   **질문**: `util/path_utils.py`에 `get_file_id(project_id: int, file_path: str) -> Optional[int]` 형태로 구현하고, `DatabaseUtils`를 활용하여 `files` 테이블을 조회하도록 해도 되겠습니까?

### 2.5. `_get_jsp_component_id()` 및 `_get_method_component_id()` 함수 구현 방식

*   **의견**: 이 함수들을 `util/path_utils.py`에 구현하고, `components` 테이블을 조회하여 `component_id`를 반환하도록 하는 것이 적절합니다.
    *   **질문 1**: `util/path_utils.py`에 `get_jsp_component_id(project_id: int, jsp_name: str) -> Optional[int]` 형태로 구현하고, `components` 테이블에서 `component_type='JSP'`로 조회하도록 해도 되겠습니까?
    *   **질문 2**: `util/path_utils.py`에 `get_method_component_id(project_id: int, class_name: str, method_name: str) -> Optional[int]` 형태로 구현하고, `components` 테이블에서 `component_type='METHOD'`로 조회하도록 해도 되겠습니까? 특히, `class_name`과 `method_name`을 모두 사용하여 정확한 메서드를 찾아야 합니다. (기존 4단계 `_get_method_component_id`는 메서드명만으로 조회하고 있었는데, JSP에서 호출하는 메서드는 클래스 컨텍스트가 중요하므로 `class_name`을 함께 고려해야 합니다.)

### 2.6. `_is_valid_jsp_file`의 `_is_included_file` 함수 구현

*   **의견**: `_is_valid_jsp_file` 함수 내에서 `_is_included_file(file_path)`를 호출한다고 하셨는데, 이 함수가 `target_source_config.yaml` 설정을 기반으로 파일 포함/제외 여부를 판단하는 로직을 가지고 있어야 합니다.
    *   **질문**: `_is_included_file` 함수를 `util/file_utils.py`에 구현하고, `ConfigUtils`를 활용하여 `target_source_config.yaml`의 `include_patterns` 및 `exclude_files` 설정을 읽어와 파일 필터링 로직을 수행하도록 해도 되겠습니까?

### 2.7. `_extract_jsp_path`의 `WEB-INF` 처리

*   **의견**: `_extract_jsp_path` 함수에서 `web_path = web_path.replace('/WEB-INF/', '/WEB-INF/')` 부분은 실제로는 아무런 변경을 하지 않습니다. `WEB-INF` 내부의 JSP 파일은 직접 접근할 수 없으므로, 이 경로를 그대로 사용하는 것이 맞는지, 아니면 `WEB-INF`를 포함한 경로를 웹 애플리케이션의 루트 경로로 간주하여 처리할 것인지 명확한 정책이 필요합니다.
    *   **질문**: 일반적으로 `WEB-INF` 내부의 JSP는 `/WEB-INF/views/user/userList.jsp`와 같이 경로를 그대로 사용합니다. 이 정책을 유지하고 `web_path.replace('/WEB-INF/', '/WEB-INF/')`와 같은 불필요한 코드를 제거해도 되겠습니까?

## 3. 다음 단계

위 추가 검토 의견에 대한 답변을 주시면, 이를 바탕으로 5단계 JSP 파서 구현을 진행하겠습니다.
