# 5단계 개발계획서 - JSP 파서 설계 및 구현 제안2 답변

## 문서 정보
- **작성일**: 2025-01-14 16:00:00
- **작성자**: AI Assistant
- **문서 유형**: 개발계획서 답변
- **대상**: 5단계 JSP 파서 설계 및 구현 제안2

## 1. 답변 개요

5단계 JSP 파서 설계 및 구현 제안2에 대한 추가 검토 의견을 검토하고, User Rules를 준수하여 답변드립니다.

## 2. 추가 검토 의견에 대한 답변

### 2.1. `jsp_keyword.yaml`의 `class_name_mapping` 및 `method_class_mapping` 활용 방안

**답변**: 제안하신 매핑 정보 활용 방안을 수용합니다.

**구체적인 구현 로직**:
```python
def _extract_class_name_from_object(self, object_name: str) -> str:
    """객체명에서 클래스명 추출 (매핑 정보 활용)"""
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 클래스명 매핑 로드
        class_name_mapping = self.config.get('class_name_mapping', {})
        
        # 설정 파일에서 매핑된 클래스명 확인
        if object_name in class_name_mapping:
            return class_name_mapping[object_name]
        
        # 매핑에 없는 경우 기본 규칙 적용
        return object_name[0].upper() + object_name[1:] if object_name else 'Unknown'
        
    except Exception as e:
        # 파싱 에러 - 계속 진행
        warning(f"클래스명 추출 실패: {object_name}, 오류: {str(e)}")
        return 'Unknown'

def _infer_class_name_from_context(self, method_name: str) -> str:
    """컨텍스트에서 클래스명 추론 (매핑 정보 활용)"""
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 메서드-클래스 매핑 로드
        method_class_mapping = self.config.get('method_class_mapping', {})
        
        # 설정 파일에서 매핑된 클래스명 확인
        if method_name in method_class_mapping:
            return method_class_mapping[method_name]
        
        # 매핑에 없는 경우 inferred 클래스 생성
        return 'InferredClass'
        
    except Exception as e:
        # 파싱 에러 - 계속 진행
        warning(f"클래스명 추론 실패: {method_name}, 오류: {str(e)}")
        return 'InferredClass'
```

**매핑에 없는 경우 처리 정책**:
- **클래스명**: `InferredClass`로 생성
- **메서드**: `inferred` 메서드로 자동 생성
- **경고 처리**: warning 로그 출력 후 계속 진행

### 2.2. `inferred` 메서드 생성 시 `component_name` 형식 및 `parent_id` 설정

**답변**: 기존 설계와의 일관성을 위해 제안하신 방안을 수용합니다.

**수정된 구현 로직**:
```python
def _create_inferred_method(self, project_id: int, class_name: str, method_name: str) -> Optional[int]:
    """inferred 메서드 자동 생성 (기존 설계 일관성 유지)"""
    try:
        # 1. inferred 클래스 먼저 생성
        inferred_class_id = self._create_inferred_class(project_id, class_name)
        if not inferred_class_id:
            return None
        
        # 2. inferred 메서드 생성 (기존 설계 일관성 유지)
        inferred_method_data = {
            'project_id': project_id,
            'component_type': 'METHOD',
            'component_name': method_name,  # 메서드명만 저장
            'parent_id': inferred_class_id,  # inferred 클래스 ID를 parent_id로 사용
            'file_id': None,  # inferred는 파일과 연결되지 않음
            'line_start': 0,
            'line_end': 0,
            'hash_value': '-',  # User Rules: 하드코딩된 '-'
            'has_error': 'N',
            'error_message': None,
            'del_yn': 'N'
        }
        
        # components 테이블에 저장
        component_id = self.db_utils.insert_component(inferred_method_data)
        return component_id
        
    except Exception as e:
        # 시스템 에러 - 프로그램 종료
        handle_error(e, f"inferred 메서드 생성 실패: {class_name}.{method_name}")
        return None

def _create_inferred_class(self, project_id: int, class_name: str) -> Optional[int]:
    """inferred 클래스 자동 생성"""
    try:
        # inferred 클래스 데이터 구성
        inferred_class_data = {
            'project_id': project_id,
            'component_type': 'CLASS',
            'component_name': class_name,
            'parent_id': None,  # inferred 클래스는 독립적
            'file_id': None,  # inferred는 파일과 연결되지 않음
            'line_start': 0,
            'line_end': 0,
            'hash_value': '-',  # User Rules: 하드코딩된 '-'
            'has_error': 'N',
            'error_message': None,
            'del_yn': 'N'
        }
        
        # components 테이블에 저장
        component_id = self.db_utils.insert_component(inferred_class_data)
        return component_id
        
    except Exception as e:
        # 시스템 에러 - 프로그램 종료
        handle_error(e, f"inferred 클래스 생성 실패: {class_name}")
        return None
```

### 2.3. `_get_project_id()` 함수 구현 위치 및 방식

**답변**: `util/global_project.py`의 `get_global_project_id()`를 활용하는 방안을 수용합니다.

**수정된 구현 방식**:
```python
def _get_project_id(self) -> Optional[int]:
    """프로젝트 ID 조회 (global_project 모듈 활용)"""
    try:
        # USER RULES: 공통함수 사용 지향
        from util.global_project import get_global_project_id
        return get_global_project_id()
        
    except Exception as e:
        # 시스템 에러 - 프로그램 종료
        handle_error(e, "프로젝트 ID 조회 실패")
        return None
```

**장점**:
- 중복 공통함수 생성 지양
- 기존 전역 프로젝트 관리 시스템 활용
- User Rules 준수

### 2.4. `_get_file_id()` 함수 구현 방식

**답변**: 제안하신 구현 방식을 수용합니다.

**구현 위치**: `util/path_utils.py`

**구현 내용**:
```python
def get_file_id(project_id: int, file_path: str) -> Optional[int]:
    """
    파일 ID 조회
    
    Args:
        project_id: 프로젝트 ID
        file_path: 파일 경로
        
    Returns:
        파일 ID
    """
    try:
        # USER RULES: 공통함수 사용 지향
        from util import DatabaseUtils
        
        # DatabaseUtils를 사용하여 files 테이블 조회
        db_utils = DatabaseUtils()
        if not db_utils.connect():
            handle_error(Exception("데이터베이스 연결 실패"), "파일 ID 조회 실패")
            return None
        
        # files 테이블에서 file_path로 조회
        query = "SELECT file_id FROM files WHERE project_id = ? AND file_path = ? AND del_yn = 'N'"
        result = db_utils.execute_query(query, (project_id, file_path))
        
        if result and len(result) > 0:
            return result[0][0]
        else:
            return None
            
    except Exception as e:
        # 시스템 에러 - 프로그램 종료
        handle_error(e, f"파일 ID 조회 실패: {file_path}")
        return None
    finally:
        if db_utils:
            db_utils.disconnect()
```

### 2.5. `_get_jsp_component_id()` 및 `_get_method_component_id()` 함수 구현 방식

**답변**: 제안하신 구현 방식을 수용합니다.

**구현 위치**: `util/path_utils.py`

**구현 내용**:
```python
def get_jsp_component_id(project_id: int, jsp_name: str) -> Optional[int]:
    """
    JSP 컴포넌트 ID 조회
    
    Args:
        project_id: 프로젝트 ID
        jsp_name: JSP 파일명
        
    Returns:
        JSP 컴포넌트 ID
    """
    try:
        # USER RULES: 공통함수 사용 지향
        from util import DatabaseUtils
        
        db_utils = DatabaseUtils()
        if not db_utils.connect():
            handle_error(Exception("데이터베이스 연결 실패"), "JSP 컴포넌트 ID 조회 실패")
            return None
        
        # components 테이블에서 component_type='JSP'로 조회
        query = """
            SELECT component_id FROM components 
            WHERE project_id = ? AND component_type = 'JSP' AND component_name = ? AND del_yn = 'N'
        """
        result = db_utils.execute_query(query, (project_id, jsp_name))
        
        if result and len(result) > 0:
            return result[0][0]
        else:
            return None
            
    except Exception as e:
        # 시스템 에러 - 프로그램 종료
        handle_error(e, f"JSP 컴포넌트 ID 조회 실패: {jsp_name}")
        return None
    finally:
        if db_utils:
            db_utils.disconnect()

def get_method_component_id(project_id: int, class_name: str, method_name: str) -> Optional[int]:
    """
    METHOD 컴포넌트 ID 조회 (클래스명과 메서드명 모두 고려)
    
    Args:
        project_id: 프로젝트 ID
        class_name: 클래스명
        method_name: 메서드명
        
    Returns:
        METHOD 컴포넌트 ID
    """
    try:
        # USER RULES: 공통함수 사용 지향
        from util import DatabaseUtils
        
        db_utils = DatabaseUtils()
        if not db_utils.connect():
            handle_error(Exception("데이터베이스 연결 실패"), "METHOD 컴포넌트 ID 조회 실패")
            return None
        
        # components 테이블에서 component_type='METHOD'로 조회
        # parent_id를 통해 CLASS와의 관계 확인
        query = """
            SELECT c.component_id FROM components c
            JOIN components p ON c.parent_id = p.component_id
            WHERE c.project_id = ? AND c.component_type = 'METHOD' AND c.component_name = ?
            AND p.component_type = 'CLASS' AND p.component_name = ?
            AND c.del_yn = 'N' AND p.del_yn = 'N'
        """
        result = db_utils.execute_query(query, (project_id, method_name, class_name))
        
        if result and len(result) > 0:
            return result[0][0]
        else:
            return None
            
    except Exception as e:
        # 시스템 에러 - 프로그램 종료
        handle_error(e, f"METHOD 컴포넌트 ID 조회 실패: {class_name}.{method_name}")
        return None
    finally:
        if db_utils:
            db_utils.disconnect()
```

### 2.6. `_is_valid_jsp_file`의 `_is_included_file` 함수 구현

**답변**: 제안하신 구현 방식을 수용합니다.

**구현 위치**: `util/file_utils.py`

**구현 내용**:
```python
def is_included_file(file_path: str, project_name: str = None) -> bool:
    """
    target_source_config.yaml 설정을 기반으로 파일 포함/제외 여부 판단
    
    Args:
        file_path: 파일 경로
        project_name: 프로젝트명 (선택적)
        
    Returns:
        포함 여부
    """
    try:
        # USER RULES: 공통함수 사용 지향
        from util import ConfigUtils, PathUtils
        
        # target_source_config.yaml 로드
        config_utils = ConfigUtils()
        config_path = PathUtils().get_config_path("target_source_config.yaml")
        config = config_utils.load_yaml_config(config_path)
        
        if not config:
            # 설정 파일 로드 실패 시 기본적으로 포함
            return True
        
        # include_patterns 확인
        include_patterns = config.get('include_patterns', [])
        if include_patterns:
            from fnmatch import fnmatch
            for pattern in include_patterns:
                if fnmatch(file_path, pattern):
                    # exclude_files 확인
                    exclude_files = config.get('exclude_files', [])
                    for exclude_pattern in exclude_files:
                        if fnmatch(file_path, exclude_pattern):
                            return False
                    return True
        
        # exclude_directories 확인
        exclude_directories = config.get('exclude_directories', [])
        if exclude_directories:
            from fnmatch import fnmatch
            for pattern in exclude_directories:
                if fnmatch(file_path, pattern):
                    return False
        
        return True
        
    except Exception as e:
        # 파싱 에러 - 계속 진행
        warning(f"파일 포함 여부 확인 실패: {file_path}, 오류: {str(e)}")
        return True
```

### 2.7. `_extract_jsp_path`의 `WEB-INF` 처리

**답변**: 제안하신 정책을 수용합니다.

**수정된 구현**:
```python
def _extract_jsp_path(self, file_path: str) -> str:
    """JSP 경로 추출 (WEB-INF 처리 정책 수정)"""
    try:
        # 프로젝트 소스 경로에서 상대 경로 추출
        if self.project_name:
            from util import PathUtils
            path_utils = PathUtils()
            project_source_path = path_utils.get_project_source_path(self.project_name)
            
            if file_path.startswith(project_source_path):
                relative_path = os.path.relpath(file_path, project_source_path)
                # Windows 경로를 Unix 경로로 변환
                web_path = '/' + relative_path.replace('\\', '/')
                
                # WEB-INF 폴더는 그대로 사용 (불필요한 코드 제거)
                return web_path
        
        # 기본값: 파일명만 반환
        return '/' + os.path.basename(file_path)
        
    except Exception as e:
        # 파싱 에러 - 계속 진행
        warning(f"JSP 경로 추출 실패: {str(e)}")
        return '/' + os.path.basename(file_path)
```

## 3. User Rules 준수사항 재확인

### 3.1. 예외 처리 규칙
- **파싱 에러**: `has_error='Y'`, `error_message` 저장 후 계속 진행
- **시스템 에러**: `handle_error()` 공통함수로 exit()
- **경고**: warning 후 계속 실행하는 경우는 없음

### 3.2. 공통함수 사용
- **중복 공통함수 생성 지양**: 기존 `util/` 모듈 확인 후 신규 개발
- **경로 관련**: `PathUtils` 공통함수 사용
- **파일 처리**: `FileUtils` 공통함수 사용
- **데이터베이스**: `DatabaseUtils` 공통함수 사용
- **설정**: `ConfigUtils` 공통함수 사용
- **전역 프로젝트**: `global_project.py` 활용

### 3.3. 하드코딩 지양
- **프로젝트 해시값**: 하드코딩된 '-' 사용
- **설정 파일**: `config/parser/jsp_keyword.yaml` 활용
- **분석 대상**: `target_source_config.yaml` 활용 (하드코딩 금지)
- **경로**: 공통함수 사용으로 하드코딩 방지

### 3.4. 메뉴얼 참고
- **JSP 파싱**: `D:\Analyzer\CreateMetaDb\parser\manual\02_jsp` 참고
- **공통 가이드**: `D:\Analyzer\CreateMetaDb\parser\manual\99_common` 참고

## 4. 수정된 구현 계획

### 4.1. 공통함수 구현 (util/ 모듈)
1. `util/path_utils.py`에 추가:
   - `get_file_id(project_id: int, file_path: str) -> Optional[int]`
   - `get_jsp_component_id(project_id: int, jsp_name: str) -> Optional[int]`
   - `get_method_component_id(project_id: int, class_name: str, method_name: str) -> Optional[int]`

2. `util/file_utils.py`에 추가:
   - `is_included_file(file_path: str, project_name: str = None) -> bool`

### 4.2. JSP 파서 구현
1. `config/parser/jsp_keyword.yaml` 생성
2. `parser/jsp_parser.py` 구현 (매핑 정보 활용)
3. `jsp_loading.py` 구현 (기존 설계 일관성 유지)

### 4.3. inferred 컴포넌트 생성
1. inferred 클래스 자동 생성
2. inferred 메서드 자동 생성 (parent_id로 클래스 연결)
3. 기존 설계와 일관성 유지

## 5. 결론

제안하신 모든 추가 검토 의견을 수용하며, User Rules를 완전히 준수하여 5단계 JSP 파서를 구현하겠습니다. 특히 중복 공통함수 생성 지양과 기존 설계와의 일관성 유지를 철저히 준수하여 견고하고 유지보수가 용이한 코드를 작성하겠습니다.

---

**문서 작성 완료**: 2025-01-14 16:00:00  
**답변 완료**: 모든 추가 검토 의견에 대한 답변 제공  
**다음 단계**: 5단계 JSP 파서 구현 시작
