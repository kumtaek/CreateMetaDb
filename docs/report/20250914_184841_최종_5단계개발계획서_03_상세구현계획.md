# 최종 5단계 개발계획서 - 3장: 상세 구현 계획

## 문서 정보
- **작성일**: 2025-09-14 18:48:41
- **작성자**: AI Assistant
- **문서 유형**: 최종 통합 개발계획서
- **대상 단계**: 5단계 - JSP 파일 분석 및 컴포넌트 등록
- **문서 버전**: v1.0 (최종 통합본)

## 📋 목차

1. [개요 및 요구사항](./20250914_184841_최종_5단계개발계획서_01_개요및요구사항.md)
2. [아키텍처 설계](./20250914_184841_최종_5단계개발계획서_02_아키텍처설계.md)
3. [상세 구현 계획](./20250914_184841_최종_5단계개발계획서_03_상세구현계획.md) ← **현재 문서**
4. [소스코드 구현 가이드](./20250914_184841_최종_5단계개발계획서_04_소스코드구현가이드.md)
5. [테스트 및 검증 계획](./20250914_184841_최종_5단계개발계획서_05_테스트및검증계획.md)

---

## 1. User Rules 준수사항 (반드시 준수)

### 1.1 예외 처리 규칙
- **파싱에러**: `has_error='Y'`, `error_message` 저장 후 계속 실행 (exit 안함)
- **시스템에러**: `handle_error()` 공통함수로 exit (프로그램 종료)
- **그 밖에 warning 후 계속 실행하는 경우는 없음**

### 1.2 공통함수 사용 지향
- **경로관련 함수**: Windows, RHEL 크로스플랫폼 대응
- **중복공통함수 생성 지양**: ./util/ 확인 후 신규 공통함수 개발
- **하드코딩 지양**: 모든 설정은 파일에서 로드

### 1.3 설정 파일 활용
- **target_source_config.yaml**: 분석대상 폴더,파일에 대한 정의 (하드코딩 금지)
- **parser/manual**: 파싱로직 개발시 참고

---

## 2. 5단계 상세 구현 계획

### 2.1 JspLoadingEngine 클래스 구현

#### 2.1.1 초기화 구현
```python
class JspLoadingEngine:
    """5단계 JSP 로딩 엔진"""
    
    def __init__(self, project_name: str):
        """JSP 로딩 엔진 초기화"""
        try:
            self.project_name = project_name
            
            # USER RULES: 공통함수 사용 지향
            from util import PathUtils, ConfigUtils
            self.path_utils = PathUtils()
            self.config_utils = ConfigUtils()
            
            # 프로젝트 경로 설정 (하드코딩 금지)
            self.project_source_path = self.path_utils.get_project_source_path(project_name)
            self.metadata_db_path = self.path_utils.get_project_metadata_db_path(project_name)
            
            # JSP 파서 초기화
            self.jsp_parser = JspParser(project_name=project_name)
            
            # 통계 정보 초기화
            self.stats = {
                'jsp_files_processed': 0,
                'jsp_components_created': 0,
                'jsp_method_relationships_created': 0,
                'errors': 0
            }
            
            info(f"JSP 로딩 엔진 초기화 완료: {project_name}")
            
        except Exception as e:
            # USER RULES: 시스템에러는 handle_error()로 exit
            handle_error(e, "JSP 로딩 엔진 초기화 실패")
```

#### 2.1.2 메인 실행 함수 구현
```python
def execute_jsp_loading(self) -> bool:
    """5단계 처리 실행"""
    try:
        info("=== JSP 로딩 시작: 5단계 처리 ===")
        
        # 데이터베이스 연결
        from util import DatabaseUtils
        self.db_utils = DatabaseUtils(self.metadata_db_path)
        
        # USER RULES: target_source_config.yaml 활용
        target_config = self.config_utils.load_target_source_config(self.project_name)
        
        # JSP 파일 수집
        jsp_files = self.jsp_parser.get_filtered_jsp_files(self.project_source_path, target_config)
        if not jsp_files:
            info("분석할 JSP 파일이 없습니다")
            return True
        
        info(f"JSP 파일 수집 완료: {len(jsp_files)}개")
        
        # JSP 파일별 통합 처리
        for jsp_file in jsp_files:
            try:
                # JSP 파일 파싱
                result = self.jsp_parser.parse_jsp_file(jsp_file)
                
                # JSP 컴포넌트 저장
                if result['jsp_component']:
                    if self._save_jsp_components_to_database([result['jsp_component']]):
                        self.stats['jsp_components_created'] += 1
                
                # JSP → METHOD 관계 저장
                if result['java_method_relationships']:
                    if self._save_jsp_method_relationships_to_database(result['java_method_relationships']):
                        self.stats['jsp_method_relationships_created'] += len(result['java_method_relationships'])
                
                # 오류 통계 업데이트
                if result.get('has_error') == 'Y':
                    self.stats['errors'] += 1
                
                self.stats['jsp_files_processed'] += 1
                
            except Exception as e:
                # USER RULES: 파싱에러는 has_error='Y', error_message 남기고 계속 진행
                # USER RULES: 파싱에러는 has_error='Y', error_message 저장 후 계속 실행(exit안함)
                warning(f"JSP 파일 처리 실패: {jsp_file}, 오류: {str(e)}")
                self.stats['errors'] += 1
                continue
        
        # 통계 정보 출력
        self._print_jsp_loading_statistics()
        
        # 데이터베이스 연결 해제
        self.db_utils.close()
        
        info("=== JSP 로딩 완료 ===")
        return True
        
    except Exception as e:
        # USER RULES: 시스템에러는 handle_error()로 exit
        handle_error(e, "JSP 로딩 실행 실패")
        return False
```

### 2.2 JspParser 클래스 구현

#### 2.2.1 초기화 구현
```python
class JspParser:
    """JSP 파서 - 5단계 통합 처리"""
    
    def __init__(self, project_name: str):
        """JSP 파서 초기화"""
        try:
            self.project_name = project_name
            
            # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
            from util import PathUtils, ConfigUtils
            self.path_utils = PathUtils()
            self.config_utils = ConfigUtils()
            
            # JSP 키워드 설정 로드
            config_path = self.path_utils.get_jsp_keyword_config_path()
            self.config = self.config_utils.load_yaml_config(config_path)
            
            # USER RULES: parser/manual 참고
            manual_path = self.path_utils.get_parser_manual_path("02_jsp")
            
            info(f"JSP 파서 초기화 완료: {config_path}")
            
        except Exception as e:
            # USER RULES: 시스템에러는 handle_error()로 exit
            handle_error(e, "JSP 파서 초기화 실패")
```

#### 2.2.2 JSP 파일 수집 구현
```python
def get_filtered_jsp_files(self, project_path: str, target_config: Dict[str, Any]) -> List[str]:
    """JSP 파일 수집 및 필터링"""
    try:
        # USER RULES: 공통함수 사용 지향
        from util import FileUtils
        file_utils = FileUtils()
        
        # USER RULES: target_source_config.yaml 활용
        include_patterns = target_config.get('include_patterns', [])
        exclude_patterns = target_config.get('exclude_patterns', [])
        
        jsp_files = []
        for root, dirs, files in os.walk(project_path):
            for file in files:
                if file.endswith('.jsp'):
                    file_path = os.path.join(root, file)
                    
                    # 포함/제외 패턴 확인
                    if self._is_file_included(file_path, include_patterns, exclude_patterns):
                        if self._is_valid_jsp_file(file_path):
                            jsp_files.append(file_path)
        
        info(f"JSP 파일 수집 완료: {len(jsp_files)}개")
        return jsp_files
        
    except Exception as e:
        # USER RULES: 시스템에러는 handle_error()로 exit
        handle_error(e, "JSP 파일 수집 실패")
        return []

def _is_file_included(self, file_path: str, include_patterns: List[str], exclude_patterns: List[str]) -> bool:
    """파일 포함/제외 패턴 확인"""
    try:
        # 포함 패턴 확인
        if include_patterns:
            if not any(pattern in file_path for pattern in include_patterns):
                return False
        
        # 제외 패턴 확인
        if exclude_patterns:
            if any(pattern in file_path for pattern in exclude_patterns):
                return False
        
        return True
        
    except Exception as e:
        # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
        handle_error(e, f"파일 포함/제외 패턴 확인 실패: {file_path}")

def _is_valid_jsp_file(self, file_path: str) -> bool:
    """유효한 JSP 파일인지 확인"""
    try:
        from util import FileUtils
        file_utils = FileUtils()
        content = file_utils.read_file(file_path)
        if not content:
            return False
        
        # JSP 지시어나 태그 확인
        jsp_indicators = [
            '<%@',  # JSP 지시어
            '<%',   # 스크립틀릿
            '<%=',  # 표현식
            '<jsp:', # JSP 액션
            '<c:',  # JSTL Core
            '<fmt:', # JSTL Formatting
            '<sql:', # JSTL SQL
            '<x:'   # JSTL XML
        ]
        
        content_lower = content.lower()
        return any(indicator in content_lower for indicator in jsp_indicators)
        
    except Exception as e:
        # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
        handle_error(e, f"JSP 파일 확인 실패: {file_path}")
```

#### 2.2.3 JSP 파일 파싱 구현
```python
def parse_jsp_file(self, jsp_file: str) -> Dict[str, Any]:
    """JSP 파일에서 컴포넌트 정보 추출 및 Java 메서드 관계 분석"""
    try:
        # JSP 파일 읽기
        from util import FileUtils
        file_utils = FileUtils()
        jsp_content = file_utils.read_file(jsp_file)
        
        if not jsp_content:
            return {
                'jsp_component': None,
                'java_method_relationships': [],
                'file_path': jsp_file,
                'has_error': 'Y',
                'error_message': 'JSP 파일 읽기 실패'
            }
        
        # JSP 컴포넌트 정보 추출
        jsp_component = self._extract_jsp_component_info(jsp_content, jsp_file)
        
        # Java 메서드 호출 분석
        java_method_relationships = self._analyze_java_method_calls(jsp_content, jsp_component)
        
        return {
            'jsp_component': jsp_component,
            'java_method_relationships': java_method_relationships,
            'file_path': jsp_file,
            'has_error': 'N',
            'error_message': None
        }
        
    except Exception as e:
        # USER RULES: 파싱에러는 has_error='Y', error_message 남기고 계속 진행
        warning(f"JSP 파일 파싱 실패: {jsp_file}, 오류: {str(e)}")
        return {
            'jsp_component': None,
            'java_method_relationships': [],
            'file_path': jsp_file,
            'has_error': 'Y',
            'error_message': f'JSP 파일 파싱 실패: {str(e)}'
        }
```

### 2.3 JSP 컴포넌트 추출 구현

#### 2.3.1 JSP 컴포넌트 정보 추출
```python
def _extract_jsp_component_info(self, jsp_content: str, file_path: str) -> Dict[str, Any]:
    """JSP 파일에서 JSP 컴포넌트 정보 추출"""
    try:
        # JSP 파일명 추출
        jsp_name = os.path.basename(file_path)
        
        # JSP 경로 추출 (웹 애플리케이션 기준 상대 경로)
        jsp_path = self._extract_jsp_path(file_path)
        
        # 라인 번호 추출
        line_start = 1
        line_end = jsp_content.count('\n') + 1
        
        # 해시 값 생성
        from util import HashUtils
        hash_utils = HashUtils()
        hash_value = hash_utils.generate_md5(jsp_content)
        
        return {
            'jsp_name': jsp_name,
            'jsp_path': jsp_path,
            'line_start': line_start,
            'line_end': line_end,
            'hash_value': hash_value,
            'file_path': file_path
        }
        
    except Exception as e:
        # USER RULES: 파싱에러는 has_error='Y', error_message 남기고 계속 진행
        # USER RULES: 파싱에러는 has_error='Y', error_message 저장 후 계속 실행(exit안함)
        warning(f"JSP 컴포넌트 정보 추출 실패: {str(e)}")
        return None

def _extract_jsp_path(self, file_path: str) -> str:
    """JSP 파일 경로에서 웹 애플리케이션 기준 상대 경로 추출"""
    try:
        # 프로젝트 소스 경로에서 상대 경로 추출
        project_source_path = self.path_utils.get_project_source_path(self.project_name)
        
        if file_path.startswith(project_source_path):
            relative_path = os.path.relpath(file_path, project_source_path)
            # Windows 경로를 Unix 경로로 변환
            return '/' + relative_path.replace('\\', '/')
        
        # 기본값: 파일명만 반환
        return '/' + os.path.basename(file_path)
        
    except Exception as e:
        # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
        handle_error(e, f"JSP 경로 추출 실패: {file_path}")
```

### 2.4 Java 메서드 호출 분석 구현

#### 2.4.1 통합 Java 메서드 호출 분석
```python
def _analyze_java_method_calls(self, jsp_content: str, jsp_component: Dict[str, Any]) -> List[Dict[str, Any]]:
    """JSP 파일에서 Java 메서드 호출 분석"""
    try:
        method_calls = []
        
        # 1. 스크립틀릿 분석
        scriptlet_method_calls = self._analyze_scriptlets(jsp_content)
        method_calls.extend(scriptlet_method_calls)
        
        # 2. 표현식 분석
        expression_method_calls = self._analyze_expressions(jsp_content)
        method_calls.extend(expression_method_calls)
        
        # 3. EL 분석
        el_method_calls = self._analyze_el_expressions(jsp_content)
        method_calls.extend(el_method_calls)
        
        # 4. JSTL 분석
        jstl_method_calls = self._analyze_jstl_tags(jsp_content)
        method_calls.extend(jstl_method_calls)
        
        # 5. 중복 제거
        unique_method_calls = self._remove_duplicate_method_calls(method_calls)
        
        # 6. JSP 컴포넌트 정보 추가
        for method_call in unique_method_calls:
            method_call['jsp_name'] = jsp_component['jsp_name']
            method_call['jsp_path'] = jsp_component['jsp_path']
        
        return unique_method_calls
        
    except Exception as e:
        # USER RULES: 파싱에러는 has_error='Y', error_message 남기고 계속 진행
        # USER RULES: 파싱에러는 has_error='Y', error_message 저장 후 계속 실행(exit안함)
        warning(f"Java 메서드 호출 분석 실패: {str(e)}")
        return []
```

#### 2.4.2 스크립틀릿 분석 구현
```python
def _analyze_scriptlets(self, jsp_content: str) -> List[Dict[str, Any]]:
    """스크립틀릿 분석"""
    try:
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        scriptlet_patterns = self.config.get('jsp_scriptlet_patterns', [])
        
        method_calls = []
        for pattern in scriptlet_patterns:
            matches = re.finditer(pattern, jsp_content, re.MULTILINE | re.DOTALL)
            for match in matches:
                scriptlet_content = match.group(1)
                line_number = jsp_content[:match.start()].count('\n') + 1
                
                # 스크립틀릿 내 Java 메서드 호출 분석
                scriptlet_method_calls = self._extract_method_calls_from_scriptlet(
                    scriptlet_content, line_number
                )
                method_calls.extend(scriptlet_method_calls)
        
        return method_calls
        
    except Exception as e:
        # USER RULES: 파싱에러는 has_error='Y', error_message 남기고 계속 진행
        # USER RULES: 파싱에러는 has_error='Y', error_message 저장 후 계속 실행(exit안함)
        warning(f"스크립틀릿 분석 실패: {str(e)}")
        return []

def _extract_method_calls_from_scriptlet(self, scriptlet_content: str, line_number: int) -> List[Dict[str, Any]]:
    """스크립틀릿에서 Java 메서드 호출 추출"""
    try:
        method_calls = []
        
        # USER RULES: 하드코딩 지양 - 설정 파일에서 패턴 로드
        method_call_patterns = self.config.get('java_method_call_patterns', [])
        
        for pattern in method_call_patterns:
            matches = re.finditer(pattern, scriptlet_content)
            for match in matches:
                method_call_info = self._parse_method_call(match, line_number)
                if method_call_info:
                    method_calls.append(method_call_info)
        
        return method_calls
        
    except Exception as e:
        # USER RULES: 파싱에러는 has_error='Y', error_message 저장 후 계속 실행(exit안함)
        warning(f"스크립틀릿 메서드 호출 추출 실패: {str(e)}")
        return []
```

### 2.5 데이터베이스 저장 구현

#### 2.5.1 JSP 컴포넌트 저장
```python
def _save_jsp_components_to_database(self, jsp_components: List[Dict[str, Any]]) -> bool:
    """JSP 컴포넌트를 components 테이블에 저장"""
    try:
        if not jsp_components:
            return True
        
        # 프로젝트 ID 조회
        project_id = self._get_project_id()
        if not project_id:
            # USER RULES: 파싱에러를 제외한 모든 exception 발생시 handle_error()로 exit()해야 에러인지가 가능함
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "JSP 컴포넌트 저장 실패")
        
        # JSP 데이터 변환
        jsp_data_list = []
        for jsp_info in jsp_components:
            if not jsp_info:
                continue
                
            # 파일 ID 조회
            file_id = self._get_file_id(jsp_info['file_path'])
            if not file_id:
                warning(f"파일 ID를 찾을 수 없습니다: {jsp_info['file_path']}")
                continue
            
            jsp_data = {
                'project_id': project_id,
                'component_type': 'JSP',
                'component_name': jsp_info['jsp_name'],
                'parent_id': None,  # JSP는 독립적인 컴포넌트
                'file_id': file_id,
                'line_start': jsp_info['line_start'],
                'line_end': jsp_info['line_end'],
                'hash_value': jsp_info['hash_value'],
                'has_error': 'N',
                'error_message': None,
                'del_yn': 'N'
            }
            jsp_data_list.append(jsp_data)
        
        # 배치 저장
        if jsp_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('components', jsp_data_list)
            if processed_count > 0:
                info(f"JSP 컴포넌트 저장 완료: {processed_count}개")
                return True
            else:
                handle_error(Exception("JSP 컴포넌트 저장 실패"), "JSP 컴포넌트 저장 실패")
                return False
        else:
            warning("저장할 유효한 JSP 컴포넌트가 없습니다")
            return True
            
    except Exception as e:
        # USER RULES: 시스템에러는 handle_error()로 exit
        handle_error(e, "JSP 컴포넌트 저장 실패")
        return False
```

#### 2.5.2 JSP → METHOD 관계 저장
```python
def _save_jsp_method_relationships_to_database(self, relationships: List[Dict[str, Any]]) -> bool:
    """JSP → METHOD 관계를 relationships 테이블에 저장"""
    try:
        if not relationships:
            return True
        
        # 프로젝트 ID 조회
        project_id = self._get_project_id()
        if not project_id:
            handle_error(Exception("프로젝트 ID를 찾을 수 없습니다"), "JSP → METHOD 관계 저장 실패")
            return False
        
        # 관계 데이터 변환
        relationship_data_list = []
        for rel_info in relationships:
            # JSP 컴포넌트 ID 조회
            jsp_component_id = self._get_jsp_component_id(project_id, rel_info['jsp_name'])
            if not jsp_component_id:
                warning(f"JSP 컴포넌트 ID를 찾을 수 없습니다: {rel_info['jsp_name']}")
                continue
            
            # METHOD 컴포넌트 ID 조회
            method_component_id = self._get_method_component_id(
                project_id, rel_info['class_name'], rel_info['method_name']
            )
            if not method_component_id:
                # inferred 메서드 생성
                method_component_id = self._create_inferred_method_component(
                    project_id, rel_info['class_name'], rel_info['method_name']
                )
            
            if method_component_id:
                relationship_data = {
                    'src_id': jsp_component_id,
                    'dst_id': method_component_id,
                    'rel_type': 'CALL_METHOD',
                    'confidence': 1.0,
                    'has_error': 'N',
                    'error_message': None,
                    'hash_value': '-',  # USER RULES: 하드코딩된 '-'
                    'del_yn': 'N'
                }
                relationship_data_list.append(relationship_data)
        
        # 배치 저장
        if relationship_data_list:
            processed_count = self.db_utils.batch_insert_or_replace('relationships', relationship_data_list)
            if processed_count > 0:
                info(f"JSP → METHOD 관계 저장 완료: {processed_count}개")
                return True
            else:
                handle_error(Exception("JSP → METHOD 관계 저장 실패"), "JSP → METHOD 관계 저장 실패")
                return False
        else:
            warning("저장할 유효한 JSP → METHOD 관계가 없습니다")
            return True
            
    except Exception as e:
        # USER RULES: 시스템에러는 handle_error()로 exit
        handle_error(e, "JSP → METHOD 관계 저장 실패")
        return False
```

---

## 3. 다음 단계

다음 문서에서는 소스코드 구현 가이드를 제시합니다:
- [4. 소스코드 구현 가이드](./20250914_184841_최종_5단계개발계획서_04_소스코드구현가이드.md)

---

**문서 작성 완료**: 2025-09-14 18:48:41  
**문서 버전**: v1.0 (최종 통합본)  
**다음 문서**: [4. 소스코드 구현 가이드](./20250914_184841_최종_5단계개발계획서_04_소스코드구현가이드.md)
