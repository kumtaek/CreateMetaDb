# 4~5단계 통합 개발계획서 - 메모리 최적화 전략

## 문서 정보
- **작성일**: 2025-09-14 02:38:00
- **작성자**: AI Assistant
- **문서 유형**: 통합 개발계획서
- **대상 단계**: 4~5단계 통합 - 메모리 최적화 전략

## 1. 메모리 최적화 개요

### 1.1 최적화 목표
- **대용량 Java 프로젝트 처리**: 수천 개의 Java 파일을 메모리 효율적으로 처리
- **스트리밍 처리**: 한 파일씩만 메모리에 로드하여 처리
- **즉시 해제**: 파일 처리 완료 후 즉시 메모리에서 해제
- **통합 처리**: 한 번의 파일 읽기로 컴포넌트 추출과 관계 분석 동시 수행
- **배치 저장**: 대량 데이터를 효율적으로 데이터베이스에 저장

### 1.2 메모리 사용량 예상
```
프로젝트 규모별 메모리 사용량:
- 소규모 (100개 파일): ~50MB
- 중규모 (1,000개 파일): ~100MB
- 대규모 (10,000개 파일): ~200MB
- 초대규모 (100,000개 파일): ~500MB
```

## 2. 스트리밍 처리 전략

### 2.1 파일별 순차 처리

```python
def execute_java_loading(self) -> bool:
    """
    스트리밍 처리 기반 Java 로딩 실행 (4~5단계 통합)
    """
    try:
        # 1. Java 파일 수집 (메모리 효율적)
        java_files = self.java_parser.get_filtered_java_files(self.project_source_path)
        if not java_files:
            return True
        
        info(f"Java 파일 수집 완료: {len(java_files)}개")
        
        # 2. 파일별 순차 처리 (스트리밍)
        for i, java_file in enumerate(java_files, 1):
            try:
                info(f"처리 중 ({i}/{len(java_files)}): {java_file}")
                
                # 3. 단일 파일 통합 분석 (메모리 최적화)
                analysis_result = self._process_single_java_file(java_file)
                
                # 4. 즉시 데이터베이스 저장
                if analysis_result:
                    self._save_analysis_result(analysis_result)
                
                # 5. 메모리 즉시 해제
                del analysis_result
                
                # 6. 진행률 표시
                if i % 100 == 0:
                    info(f"진행률: {i}/{len(java_files)} ({i/len(java_files)*100:.1f}%)")
                
            except Exception as e:
                # 개별 파일 오류는 계속 진행
                warning(f"파일 처리 실패: {java_file} - {str(e)}")
                self.stats['errors'] += 1
                continue
        
        return True
        
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, "Java 로딩 실행 실패")
        return False

def _process_single_java_file(self, java_file: str) -> Optional[Dict[str, Any]]:
    """
    단일 Java 파일 처리 (메모리 최적화)
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        분석 결과 또는 None
    """
    try:
        # 1. 파일 읽기 (스트리밍)
        java_content = self._read_java_file_streaming(java_file)
        if not java_content:
            return None
        
        # 2. 통합 분석 (한 번의 읽기로 모든 분석 수행)
        analysis_result = self.java_parser.parse_java_file(java_file)
        
        # 3. 메모리 즉시 해제
        del java_content
        
        return analysis_result
        
    except Exception as e:
        warning(f"단일 파일 처리 실패: {java_file} - {str(e)}")
        return None
```

### 2.2 스트리밍 파일 읽기

```python
def _read_java_file_streaming(self, java_file: str) -> Optional[str]:
    """
    스트리밍 방식으로 Java 파일 읽기
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        파일 내용 또는 None
    """
    try:
        # USER RULES: 공통함수 사용
        from util.file_utils import FileUtils
        file_utils = FileUtils()
        
        # 파일 크기 확인
        file_size = os.path.getsize(java_file)
        if file_size > 10 * 1024 * 1024:  # 10MB 이상
            warning(f"대용량 파일 감지: {java_file} ({file_size/1024/1024:.1f}MB)")
        
        # 스트리밍 읽기
        content = file_utils.read_file(java_file)
        return content
        
    except Exception as e:
        warning(f"파일 읽기 실패: {java_file} - {str(e)}")
        return None
```

## 3. 메모리 사용량 최적화

### 3.1 정규식 기반 파싱

```python
class JavaParser:
    def __init__(self, config_path: str = None, project_name: str = None):
        """
        Java 파서 초기화 (메모리 최적화)
        """
        # 설정 파일 로드
        self.config = self._load_config(config_path)
        
        # 메모리 최적화를 위한 설정
        self.max_memory_usage = 200 * 1024 * 1024  # 200MB 제한
        self.current_memory_usage = 0
        self.processed_files = 0
        
        # 통계 정보
        self.stats = {
            'files_processed': 0,
            'files_skipped': 0,
            'memory_peak_usage': 0,
            'memory_average_usage': 0
        }
    
    def parse_java_file(self, java_file: str) -> Dict[str, Any]:
        """
        Java 파일 파싱 (메모리 최적화)
        """
        try:
            # 메모리 사용량 체크
            if self.current_memory_usage > self.max_memory_usage:
                self._optimize_memory_usage()
            
            # 파일 읽기
            java_content = self._read_file_with_memory_check(java_file)
            if not java_content:
                return self._create_error_result(java_file, "파일 읽기 실패")
            
            # 메모리 사용량 업데이트
            self.current_memory_usage += len(java_content.encode('utf-8'))
            
            # 통합 분석 수행
            result = self._perform_integrated_analysis(java_content, java_file)
            
            # 메모리 즉시 해제
            del java_content
            self.current_memory_usage = 0
            
            # 통계 업데이트
            self._update_memory_stats()
            
            return result
            
        except Exception as e:
            # USER RULES: 파싱 에러는 has_error='Y', error_message 남기고 계속 진행
            error_message = f"Java 파싱 중 예외 발생: {str(e)}"
            warning(f"{error_message} - {java_file}")
            return self._create_error_result(java_file, error_message)
```

### 3.2 메모리 체크 및 최적화

```python
def _read_file_with_memory_check(self, java_file: str) -> Optional[str]:
    """
    메모리 체크와 함께 파일 읽기
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        파일 내용 또는 None
    """
    try:
        # 파일 크기 확인
        file_size = os.path.getsize(java_file)
        
        # 메모리 사용량 예상
        estimated_memory = file_size * 3  # 파일 크기의 3배 예상 (UTF-8 변환 + 처리)
        
        if self.current_memory_usage + estimated_memory > self.max_memory_usage:
            warning(f"메모리 부족으로 파일 건너뜀: {java_file}")
            self.stats['files_skipped'] += 1
            return None
        
        # USER RULES: 공통함수 사용
        from util.file_utils import FileUtils
        file_utils = FileUtils()
        
        return file_utils.read_file(java_file)
        
    except Exception as e:
        warning(f"파일 읽기 실패: {java_file} - {str(e)}")
        return None

def _optimize_memory_usage(self):
    """
    메모리 사용량 최적화
    """
    try:
        import gc
        
        # 가비지 컬렉션 실행
        gc.collect()
        
        # 메모리 사용량 리셋
        self.current_memory_usage = 0
        
        info("메모리 최적화 완료")
        
    except Exception as e:
        warning(f"메모리 최적화 실패: {str(e)}")

def _update_memory_stats(self):
    """
    메모리 통계 업데이트
    """
    try:
        import psutil
        import os
        
        process = psutil.Process(os.getpid())
        memory_info = process.memory_info()
        
        current_memory = memory_info.rss / 1024 / 1024  # MB
        
        self.stats['memory_peak_usage'] = max(self.stats['memory_peak_usage'], current_memory)
        self.stats['memory_average_usage'] = (self.stats['memory_average_usage'] * self.stats['files_processed'] + current_memory) / (self.stats['files_processed'] + 1)
        self.stats['files_processed'] += 1
        
    except Exception as e:
        warning(f"메모리 통계 업데이트 실패: {str(e)}")
```

## 4. 대용량 파일 처리

### 4.1 청크 단위 파일 처리

```python
def _process_chunked_file(self, java_file: str) -> Optional[Dict[str, Any]]:
    """
    청크 단위 파일 처리
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        분석 결과 또는 None
    """
    try:
        chunk_size = 1024 * 1024  # 1MB 청크
        all_classes = []
        all_methods = []
        all_relationships = []
        
        with open(java_file, 'r', encoding='utf-8') as file:
            chunk = file.read(chunk_size)
            while chunk:
                # 청크별 분석
                chunk_result = self._analyze_java_chunk(chunk)
                
                if chunk_result:
                    all_classes.extend(chunk_result.get('classes', []))
                    all_methods.extend(chunk_result.get('methods', []))
                    all_relationships.extend(chunk_result.get('relationships', []))
                
                # 메모리 해제
                del chunk_result
                del chunk
                
                # 다음 청크 읽기
                chunk = file.read(chunk_size)
        
        return {
            'classes': all_classes,
            'methods': all_methods,
            'relationships': all_relationships,
            'file_path': java_file
        }
        
    except Exception as e:
        warning(f"청크 파일 처리 실패: {java_file} - {str(e)}")
        return None

def _analyze_java_chunk(self, chunk: str) -> Optional[Dict[str, Any]]:
    """
    Java 청크 분석
    
    Args:
        chunk: Java 코드 청크
        
    Returns:
        분석 결과 또는 None
    """
    try:
        # 청크에서 클래스 정보 추출
        classes = self._extract_class_info_from_chunk(chunk)
        
        # 청크에서 메서드 정보 추출
        methods = self._extract_method_info_from_chunk(chunk)
        
        # 청크에서 관계 정보 추출
        relationships = self._extract_relationships_from_chunk(chunk, methods)
        
        return {
            'classes': classes,
            'methods': methods,
            'relationships': relationships
        }
        
    except Exception as e:
        warning(f"청크 분석 실패: {str(e)}")
        return None
```

### 4.2 스트리밍 파일 처리

```python
def _process_streaming_file(self, java_file: str) -> Optional[Dict[str, Any]]:
    """
    스트리밍 파일 처리 (라인 단위)
    
    Args:
        java_file: Java 파일 경로
        
    Returns:
        분석 결과 또는 None
    """
    try:
        all_classes = []
        all_methods = []
        all_relationships = []
        
        current_class = None
        current_method = None
        brace_count = 0
        
        with open(java_file, 'r', encoding='utf-8') as file:
            for line_num, line in enumerate(file, 1):
                # 라인별 분석
                line_result = self._analyze_java_line(line, line_num, current_class, current_method)
                
                if line_result:
                    if 'class' in line_result:
                        current_class = line_result['class']
                        all_classes.append(current_class)
                    elif 'method' in line_result:
                        current_method = line_result['method']
                        all_methods.append(current_method)
                    elif 'relationship' in line_result:
                        all_relationships.append(line_result['relationship'])
                
                # 중괄호 카운팅으로 컨텍스트 추적
                brace_count += line.count('{') - line.count('}')
                
                # 메모리 최적화 (1000라인마다)
                if line_num % 1000 == 0:
                    self._optimize_memory_usage()
        
        return {
            'classes': all_classes,
            'methods': all_methods,
            'relationships': all_relationships,
            'file_path': java_file
        }
        
    except Exception as e:
        warning(f"스트리밍 파일 처리 실패: {java_file} - {str(e)}")
        return None
```

## 5. 배치 저장 최적화

### 5.1 배치 저장 전략

```python
def _save_analysis_result(self, analysis_result: Dict[str, Any]) -> bool:
    """
    분석 결과 배치 저장 (메모리 최적화)
    
    Args:
        analysis_result: 분석 결과
        
    Returns:
        저장 성공 여부
    """
    try:
        # 1. 클래스 정보 배치 저장
        if analysis_result.get('classes'):
            if not self._batch_save_classes(analysis_result['classes']):
                return False
        
        # 2. 메서드 정보 배치 저장
        if analysis_result.get('methods'):
            if not self._batch_save_methods(analysis_result['methods']):
                return False
        
        # 3. 관계 정보 배치 저장
        if analysis_result.get('relationships'):
            if not self._batch_save_relationships(analysis_result['relationships']):
                return False
        
        return True
        
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, "분석 결과 저장 실패")
        return False

def _batch_save_classes(self, classes: List[Dict[str, Any]]) -> bool:
    """
    클래스 정보 배치 저장
    
    Args:
        classes: 클래스 정보 리스트
        
    Returns:
        저장 성공 여부
    """
    try:
        if not classes:
            return True
        
        # USER RULES: 공통함수 사용
        processed_count = self.db_utils.batch_insert_or_replace('classes', classes)
        if processed_count > 0:
            info(f"클래스 정보 배치 저장 완료: {processed_count}개")
            return True
        else:
            # USER RULES: Exception 발생시 handle_error()로 exit()
            from util.logger import handle_error
            handle_error(Exception("클래스 정보 저장 실패"), "클래스 정보 저장 실패")
            return False
            
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, "클래스 정보 배치 저장 실패")
        return False
```

### 5.2 메모리 효율적인 배치 처리

```python
def _batch_save_with_memory_optimization(self, table_name: str, data_list: List[Dict[str, Any]], batch_size: int = 1000) -> bool:
    """
    메모리 효율적인 배치 저장
    
    Args:
        table_name: 테이블명
        data_list: 데이터 리스트
        batch_size: 배치 크기
        
    Returns:
        저장 성공 여부
    """
    try:
        if not data_list:
            return True
        
        # 배치 단위로 저장
        for i in range(0, len(data_list), batch_size):
            batch_data = data_list[i:i+batch_size]
            
            # USER RULES: 공통함수 사용
            processed_count = self.db_utils.batch_insert_or_replace(table_name, batch_data)
            if processed_count == 0:
                # USER RULES: Exception 발생시 handle_error()로 exit()
                from util.logger import handle_error
                handle_error(Exception(f"{table_name} 저장 실패"), f"{table_name} 저장 실패")
                return False
            
            # 배치 처리 후 메모리 해제
            del batch_data
            
            # 메모리 최적화
            if i % (batch_size * 10) == 0:
                self._optimize_memory_usage()
        
        info(f"{table_name} 배치 저장 완료: {len(data_list)}개")
        return True
        
    except Exception as e:
        # USER RULES: Exception 발생시 handle_error()로 exit()
        from util.logger import handle_error
        handle_error(e, f"{table_name} 배치 저장 실패")
        return False
```

## 6. 메모리 누수 방지

### 6.1 리소스 관리

```python
class ResourceManager:
    """
    리소스 관리자 (메모리 누수 방지)
    """
    
    def __init__(self):
        self.resources = []
    
    def register_resource(self, resource):
        """리소스 등록"""
        self.resources.append(resource)
    
    def cleanup_resources(self):
        """리소스 정리"""
        try:
            for resource in self.resources:
                if hasattr(resource, 'close'):
                    resource.close()
                elif hasattr(resource, 'disconnect'):
                    resource.disconnect()
            
            self.resources.clear()
            
            # 가비지 컬렉션 실행
            import gc
            gc.collect()
            
        except Exception as e:
            warning(f"리소스 정리 실패: {str(e)}")
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.cleanup_resources()
```

### 6.2 메모리 모니터링

```python
def _monitor_memory_usage(self):
    """
    메모리 사용량 모니터링
    """
    try:
        import psutil
        import os
        
        process = psutil.Process(os.getpid())
        memory_info = process.memory_info()
        
        memory_mb = memory_info.rss / 1024 / 1024
        
        if memory_mb > 500:  # 500MB 이상
            warning(f"메모리 사용량 높음: {memory_mb:.1f}MB")
            self._optimize_memory_usage()
        
        return memory_mb
        
    except Exception as e:
        warning(f"메모리 모니터링 실패: {str(e)}")
        return 0
```

## 7. 성능 최적화

### 7.1 정규식 컴파일 최적화

```python
class OptimizedJavaParser:
    """
    최적화된 Java 파서 (정규식 컴파일 최적화)
    """
    
    def __init__(self, config_path: str = None):
        self.config = self._load_config(config_path)
        self.compiled_patterns = {}
        self._compile_patterns()
    
    def _compile_patterns(self):
        """정규식 패턴 컴파일 (성능 최적화)"""
        try:
            # 클래스 패턴 컴파일
            class_patterns = self.config.get('java_class_extraction_patterns', [])
            self.compiled_patterns['class'] = [re.compile(pattern) for pattern in class_patterns]
            
            # 메서드 패턴 컴파일
            method_patterns = self.config.get('java_method_extraction_patterns', [])
            self.compiled_patterns['method'] = [re.compile(pattern) for pattern in method_patterns]
            
            # 관계 패턴 컴파일
            relationship_patterns = self.config.get('relationship_patterns', {})
            self.compiled_patterns['call_query'] = [re.compile(pattern) for pattern in relationship_patterns.get('call_query_patterns', [])]
            self.compiled_patterns['call_method'] = [re.compile(pattern) for pattern in relationship_patterns.get('call_method_patterns', [])]
            self.compiled_patterns['use_table'] = [re.compile(pattern) for pattern in relationship_patterns.get('use_table_patterns', [])]
            
        except Exception as e:
            warning(f"패턴 컴파일 실패: {str(e)}")
    
    def _extract_with_compiled_patterns(self, content: str, pattern_type: str) -> List[Any]:
        """컴파일된 패턴으로 추출"""
        try:
            results = []
            patterns = self.compiled_patterns.get(pattern_type, [])
            
            for pattern in patterns:
                matches = pattern.finditer(content)
                for match in matches:
                    results.append(match)
            
            return results
            
        except Exception as e:
            warning(f"컴파일된 패턴 추출 실패: {str(e)}")
            return []
```

## 8. 다음 단계

다음 문서에서는 데이터베이스 저장 로직을 제시합니다:
- [6. 데이터베이스 저장 로직](./20250914_023800_4~5단계통합개발계획서_06_데이터베이스저장로직.md)
