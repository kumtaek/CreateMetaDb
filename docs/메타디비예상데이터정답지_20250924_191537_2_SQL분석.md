# 메타디비 예상데이터 정답지 - SQL분석

**생성일시**: 2025-09-24 19:15:37  
**분석대상**: projects/SampleSrc 폴더  
**분석방법**: 수작업 직접 분석  

## 1. SQL_SELECT 분석 (35개)

### 1.1 UserMapper.xml - SELECT 쿼리 (15개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| findUsersByCondition | users | 없음 | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date, CASE WHEN u.user_type = 'ADMIN' THEN 1 ELSE 0 END as is_admin, CASE WHEN u.user_type = 'PREMIUM' THEN 1 ELSE 0 END as is_premium, CASE WHEN u.user_type = 'NORMAL' THEN 1 ELSE 0 END as is_normal, CASE WHEN u.user_type = 'GUEST' THEN 1 ELSE 0 END as is_guest, u.email_verified, u.phone_verified FROM users u WHERE u.del_yn = 'N' |
| findUsersByAdvancedCondition | users | 없음 | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date, CASE WHEN u.user_type = 'ADMIN' THEN 1 ELSE 0 END as is_admin, CASE WHEN u.user_type = 'PREMIUM' THEN 1 ELSE 0 END as is_premium, CASE WHEN u.user_type = 'NORMAL' THEN 1 ELSE 0 END as is_normal, CASE WHEN u.user_type = 'GUEST' THEN 1 ELSE 0 END as is_guest, u.email_verified, u.phone_verified FROM users u WHERE u.del_yn = 'N' AND u.age BETWEEN #{minAge} AND #{maxAge} AND u.birth_date <= #{minBirthDate} AND u.birth_date >= #{maxBirthDate} AND u.status IN (statusList) AND u.user_type IN (userTypes) AND u.email_verified = 1 AND u.phone_verified = 1 ORDER BY u.created_date DESC |
| findUsersByType | users | 없음 | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date, CASE WHEN u.user_type = 'ADMIN' THEN 1 ELSE 0 END as is_admin, CASE WHEN u.user_type = 'PREMIUM' THEN 1 ELSE 0 END as is_premium, CASE WHEN u.user_type = 'NORMAL' THEN 1 ELSE 0 END as is_normal, CASE WHEN u.user_type = 'GUEST' THEN 1 ELSE 0 END as is_guest, u.email_verified, u.phone_verified FROM users u WHERE u.user_type = #{userType} |
| findUserById | users | 없음 | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date, CASE WHEN u.user_type = 'ADMIN' THEN 1 ELSE 0 END as is_admin, CASE WHEN u.user_type = 'PREMIUM' THEN 1 ELSE 0 END as is_premium, CASE WHEN u.user_type = 'NORMAL' THEN 1 ELSE 0 END as is_normal, CASE WHEN u.user_type = 'GUEST' THEN 1 ELSE 0 END as is_guest, u.email_verified, u.phone_verified FROM users u WHERE u.user_id = #{userId} |
| existsByUsername | users | 없음 | SELECT COUNT(*) FROM users WHERE username = #{username} |
| existsByEmail | users | 없음 | SELECT COUNT(*) FROM users WHERE email = #{email} |
| isEmailVerified | users | 없음 | SELECT email_verified FROM users WHERE user_id = #{userId} |
| isPhoneVerified | users | 없음 | SELECT phone_verified FROM users WHERE user_id = #{userId} |
| getTotalUserCount | users | 없음 | SELECT COUNT(*) FROM users |
| getActiveUserCount | users | 없음 | SELECT COUNT(*) FROM users WHERE status = 'ACTIVE' |
| getNewUsersTodayCount | users | 없음 | SELECT COUNT(*) FROM users WHERE DATE(created_date) = CURDATE() |
| getPremiumUserCount | users | 없음 | SELECT COUNT(*) FROM users WHERE user_type = 'PREMIUM' |
| getUserStatisticsByStatus | users | 없음 | SELECT status, COUNT(*) as user_count FROM users GROUP BY status |
| getUserStatisticsByType | users | 없음 | SELECT user_type, COUNT(*) as user_count FROM users GROUP BY user_type |
| getMonthlyRegistrationStats | users | 없음 | SELECT DATE_FORMAT(created_date, '%Y-%m') as month, COUNT(*) as user_count FROM users GROUP BY DATE_FORMAT(created_date, '%Y-%m') |

### 1.2 ProductMapper.xml - SELECT 쿼리 (12개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| selectProductById | products | 없음 | SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.category_id, p.brand_id, p.status, p.created_date, p.updated_date, c.category_name, b.brand_name FROM products p LEFT JOIN categories c ON p.category_id = c.category_id LEFT JOIN brands b ON p.brand_id = b.brand_id WHERE product_id = #{productId} |
| selectProductsByCondition | products | 없음 | SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.category_id, p.brand_id, p.status, p.created_date, p.updated_date, c.category_name, b.brand_name FROM products p LEFT JOIN categories c ON p.category_id = c.category_id LEFT JOIN brands b ON p.brand_id = b.brand_id WHERE p.del_yn = 'N' AND p.status = 'ACTIVE' AND p.stock_quantity > 0 |
| selectProductsByAdvancedCondition | products, categories, brands | LEFT JOIN | products.category_id = categories.category_id, products.brand_id = brands.brand_id | SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.category_id, p.brand_id, p.status, p.created_date, p.updated_date, c.category_name, b.brand_name FROM products p LEFT JOIN categories c ON p.category_id = c.category_id LEFT JOIN brands b ON p.brand_id = b.brand_id WHERE p.del_yn = 'N' AND p.status = 'ACTIVE' AND p.stock_quantity > 0 AND p.price BETWEEN #{minPrice} AND #{maxPrice} AND p.category_id IN (categoryIds) AND p.brand_id IN (brandIds) ORDER BY p.created_date DESC |
| selectProductsByCategory | products | 없음 | SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.category_id, p.brand_id, p.status, p.created_date, p.updated_date, c.category_name, b.brand_name FROM products p LEFT JOIN categories c ON p.category_id = c.category_id LEFT JOIN brands b ON p.brand_id = b.brand_id WHERE category_id = #{categoryId} |
| selectProductsByBrand | products, brands | INNER JOIN | products.brand_id = brands.brand_id | SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.category_id, p.brand_id, p.status, p.created_date, p.updated_date, c.category_name, b.brand_name FROM products p LEFT JOIN categories c ON p.category_id = c.category_id LEFT JOIN brands b ON p.brand_id = b.brand_id WHERE p.brand_id = #{brandId} |
| selectLowStockProducts | products, inventory, suppliers | LEFT JOIN | products.product_id = inventory.product_id, products.supplier_id = suppliers.supplier_id | SELECT p.*, i.current_stock, i.reorder_point, s.supplier_name, s.lead_time_days FROM products p LEFT JOIN inventory i ON p.product_id = i.product_id LEFT JOIN suppliers s ON p.supplier_id = s.supplier_id WHERE i.current_stock <= #{threshold} AND p.status = 'ACTIVE' AND p.del_yn = 'N' ORDER BY i.current_stock ASC, s.lead_time_days DESC |
| getProductStatsByCategory | categories, products | LEFT JOIN | categories.category_id = products.category_id | SELECT c.category_id, c.category_name, COUNT(p.product_id) as product_count, AVG(p.price) as avg_price, MIN(p.price) as min_price, MAX(p.price) as max_price, SUM(p.stock_quantity) as total_stock FROM categories c LEFT JOIN products p ON c.category_id = p.category_id GROUP BY c.category_id, c.category_name |
| analyzeProductSalesPerformance | products, order_items, orders, categories, brands | INNER JOIN | products.product_id = order_items.product_id, order_items.order_id = orders.order_id | SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.category_id, p.brand_id, p.status, p.created_date, p.updated_date, c.category_name, b.brand_name, oi.quantity, oi.unit_price, o.order_date, o.order_status FROM products p LEFT JOIN categories c ON p.category_id = c.category_id LEFT JOIN brands b ON p.brand_id = b.brand_id INNER JOIN order_items oi ON p.product_id = oi.product_id INNER JOIN orders o ON oi.order_id = o.order_id WHERE o.order_status = 'COMPLETED' ORDER BY o.order_date DESC |
| countProductsByCondition | products | 없음 | SELECT COUNT(*) FROM products WHERE del_yn = 'N' AND status = 'ACTIVE' |
| getProductCountByCategory | categories, products | LEFT JOIN | categories.category_id = products.category_id | SELECT c.category_id, c.category_name, COUNT(p.product_id) as product_count FROM categories c LEFT JOIN products p ON c.category_id = p.category_id GROUP BY c.category_id, c.category_name |
| getProductCountByBrand | brands, products | LEFT JOIN | brands.brand_id = products.brand_id | SELECT b.brand_id, b.brand_name, COUNT(p.product_id) as product_count FROM brands b LEFT JOIN products p ON b.brand_id = p.brand_id GROUP BY b.brand_id, b.brand_name |
| getProductPriceRange | products | 없음 | SELECT MIN(price) as min_price, MAX(price) as max_price, AVG(price) as avg_price FROM products WHERE del_yn = 'N' AND status = 'ACTIVE' |

### 1.3 UserManagementMapper.xml - SELECT 쿼리 (3개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| findUserManagementData | users, user_management | LEFT JOIN | users.user_id = user_management.user_id | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date, um.management_level, um.assigned_manager, um.management_notes, um.management_status, um.management_date FROM users u LEFT JOIN user_management um ON u.user_id = um.user_id WHERE u.del_yn = 'N' |
| getUserManagementStats | user_management | 없음 | SELECT management_level, COUNT(*) as user_count FROM user_management GROUP BY management_level |
| getActiveUserManagement | users, user_management | LEFT JOIN | users.user_id = user_management.user_id | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date, um.management_level, um.assigned_manager, um.management_notes, um.management_status, um.management_date FROM users u LEFT JOIN user_management um ON u.user_id = um.user_id WHERE u.del_yn = 'N' AND um.management_status = 'ACTIVE' |

### 1.4 ImplicitJoinMapper.xml - SELECT 쿼리 (5개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| findUsersWithOrders | users, orders | LEFT JOIN | users.user_id = orders.user_id | SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type, u.created_date, u.last_login_date, u.updated_date, o.order_id, o.order_date, o.order_status, o.total_amount FROM users u LEFT JOIN orders o ON u.user_id = o.user_id WHERE u.del_yn = 'N' |
| findProductsWithCategories | products, categories | LEFT JOIN | products.category_id = categories.category_id | SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.category_id, p.brand_id, p.status, p.created_date, p.updated_date, c.category_name FROM products p LEFT JOIN categories c ON p.category_id = c.category_id WHERE p.del_yn = 'N' |
| findOrdersWithUsers | orders, users | LEFT JOIN | orders.user_id = users.user_id | SELECT o.order_id, o.order_date, o.order_status, o.total_amount, u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type FROM orders o LEFT JOIN users u ON o.user_id = u.user_id WHERE o.del_yn = 'N' |
| findOrderItemsWithProducts | order_items, products | LEFT JOIN | order_items.product_id = products.product_id | SELECT oi.order_item_id, oi.order_id, oi.product_id, oi.quantity, oi.unit_price, p.product_name, p.description, p.price, p.stock_quantity, p.category_id, p.brand_id, p.status FROM order_items oi LEFT JOIN products p ON oi.product_id = p.product_id WHERE oi.del_yn = 'N' |
| findCategoriesWithProducts | categories, products | LEFT JOIN | categories.category_id = products.category_id | SELECT c.category_id, c.category_name, c.description, c.created_date, c.updated_date, p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.brand_id, p.status FROM categories c LEFT JOIN products p ON c.category_id = p.category_id WHERE c.del_yn = 'N' |

## 2. SQL_INSERT 분석 (8개)

### 2.1 UserMapper.xml - INSERT 쿼리 (3개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| insertUser | users | 없음 | INSERT INTO users (username, full_name, email, phone, password_hash, status, user_type, email_verified, phone_verified, created_date, updated_date) VALUES (#{username}, #{fullName}, #{email}, #{phone}, #{passwordHash}, #{status}, #{userType}, #{emailVerified}, #{phoneVerified}, #{createdDate}, #{updatedDate}) |
| insertUserWithDefaults | users | 없음 | INSERT INTO users (username, full_name, email, phone, password_hash, status, user_type, email_verified, phone_verified, created_date, updated_date) VALUES (#{username}, #{fullName}, #{email}, #{phone}, #{passwordHash}, 'ACTIVE', 'NORMAL', 0, 0, SYSDATE, SYSDATE) |
| insertUserBatch | users | 없음 | INSERT INTO users (username, full_name, email, phone, password_hash, status, user_type, email_verified, phone_verified, created_date, updated_date) VALUES (#{username}, #{fullName}, #{email}, #{phone}, #{passwordHash}, #{status}, #{userType}, #{emailVerified}, #{phoneVerified}, #{createdDate}, #{updatedDate}) |

### 2.2 ProductMapper.xml - INSERT 쿼리 (3개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| insertProduct | products | 없음 | INSERT INTO products (product_name, description, price, stock_quantity, category_id, brand_id, status, created_date, updated_date) VALUES (#{productName}, #{description}, #{price}, #{stockQuantity}, #{categoryId}, #{brandId}, #{status}, #{createdDate}, #{updatedDate}) |
| insertProductWithDefaults | products | 없음 | INSERT INTO products (product_name, description, price, stock_quantity, category_id, brand_id, status, created_date, updated_date) VALUES (#{productName}, #{description}, #{price}, #{stockQuantity}, #{categoryId}, #{brandId}, 'ACTIVE', SYSDATE, SYSDATE) |
| insertProductBatch | products | 없음 | INSERT INTO products (product_name, description, price, stock_quantity, category_id, brand_id, status, created_date, updated_date) VALUES (#{productName}, #{description}, #{price}, #{stockQuantity}, #{categoryId}, #{brandId}, #{status}, #{createdDate}, #{updatedDate}) |

### 2.3 JoinQueryMapper.xml - INSERT 쿼리 (2개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| insertUserWithOrders | users, orders | 없음 | INSERT INTO users (username, full_name, email, phone, password_hash, status, user_type, email_verified, phone_verified, created_date, updated_date) VALUES (#{username}, #{fullName}, #{email}, #{phone}, #{passwordHash}, #{status}, #{userType}, #{emailVerified}, #{phoneVerified}, #{createdDate}, #{updatedDate}); INSERT INTO orders (user_id, order_date, order_status, total_amount, created_date, updated_date) VALUES (#{userId}, #{orderDate}, #{orderStatus}, #{totalAmount}, #{createdDate}, #{updatedDate}) |
| insertProductWithCategory | products, categories | 없음 | INSERT INTO categories (category_name, description, created_date, updated_date) VALUES (#{categoryName}, #{description}, #{createdDate}, #{updatedDate}); INSERT INTO products (product_name, description, price, stock_quantity, category_id, brand_id, status, created_date, updated_date) VALUES (#{productName}, #{description}, #{price}, #{stockQuantity}, #{categoryId}, #{brandId}, #{status}, #{createdDate}, #{updatedDate}) |

## 3. SQL_UPDATE 분석 (8개)

### 3.1 UserMapper.xml - UPDATE 쿼리 (3개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| updateUser | users | 없음 | UPDATE users SET username = #{username}, full_name = #{fullName}, email = #{email}, phone = #{phone}, status = #{status}, user_type = #{userType}, email_verified = #{emailVerified}, phone_verified = #{phoneVerified}, updated_date = #{updatedDate} WHERE user_id = #{userId} |
| updateUserStatus | users | 없음 | UPDATE users SET status = #{status}, updated_date = #{updatedDate} WHERE user_id = #{userId} |
| updateUserLastLogin | users | 없음 | UPDATE users SET last_login_date = #{lastLoginDate}, updated_date = #{updatedDate} WHERE user_id = #{userId} |

### 3.2 ProductMapper.xml - UPDATE 쿼리 (3개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| updateProduct | products | 없음 | UPDATE products SET product_name = #{productName}, description = #{description}, price = #{price}, stock_quantity = #{stockQuantity}, category_id = #{categoryId}, brand_id = #{brandId}, status = #{status}, updated_date = #{updatedDate} WHERE product_id = #{productId} |
| updateProductStock | products | 없음 | UPDATE products SET stock_quantity = stock_quantity + #{quantity}, updated_date = SYSDATE WHERE product_id = #{productId} |
| updateProductDynamic | products | 없음 | UPDATE products SET productName != null and productName != '' product_name = #{productName}, price = #{price}, category_id = #{categoryId}, brand_id = #{brandId}, stock_quantity = #{stockQuantity}, status = #{status}, updated_date = SYSDATE WHERE product_id = #{productId} |

### 3.3 JoinQueryMapper.xml - UPDATE 쿼리 (2개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| updateUserWithOrders | users, orders | 없음 | UPDATE users SET username = #{username}, full_name = #{fullName}, email = #{email}, phone = #{phone}, status = #{status}, user_type = #{userType}, email_verified = #{emailVerified}, phone_verified = #{phoneVerified}, updated_date = #{updatedDate} WHERE user_id = #{userId}; UPDATE orders SET order_status = #{orderStatus}, total_amount = #{totalAmount}, updated_date = #{updatedDate} WHERE user_id = #{userId} |
| updateProductWithCategory | products, categories | 없음 | UPDATE categories SET category_name = #{categoryName}, description = #{description}, updated_date = #{updatedDate} WHERE category_id = #{categoryId}; UPDATE products SET product_name = #{productName}, description = #{description}, price = #{price}, stock_quantity = #{stockQuantity}, brand_id = #{brandId}, status = #{status}, updated_date = #{updatedDate} WHERE category_id = #{categoryId} |

## 4. SQL_DELETE 분석 (8개)

### 4.1 UserMapper.xml - DELETE 쿼리 (3개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| deleteUser | users | 없음 | DELETE FROM users WHERE user_id = #{userId} |
| deleteUserByUsername | users | 없음 | DELETE FROM users WHERE username = #{username} |
| deleteUserByEmail | users | 없음 | DELETE FROM users WHERE email = #{email} |

### 4.2 ProductMapper.xml - DELETE 쿼리 (3개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| deleteProduct | products | 없음 | DELETE FROM products WHERE product_id = #{productId} |
| deleteProductByCategory | products | 없음 | DELETE FROM products WHERE category_id = #{categoryId} |
| deleteProductByBrand | products | 없음 | DELETE FROM products WHERE brand_id = #{brandId} |

### 4.3 JoinQueryMapper.xml - DELETE 쿼리 (2개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| deleteUserWithOrders | users, orders | 없음 | DELETE FROM orders WHERE user_id = #{userId}; DELETE FROM users WHERE user_id = #{userId} |
| deleteProductWithCategory | products, categories | 없음 | DELETE FROM products WHERE category_id = #{categoryId}; DELETE FROM categories WHERE category_id = #{categoryId} |

## 5. SQL_MERGE 분석 (10개)

### 5.1 MergeQueryMapper.xml - MERGE 쿼리 (5개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| mergeUserStatistics | user_statistics, users, orders | LEFT JOIN | users.user_id = orders.user_id, user_statistics.user_id = users.user_id | MERGE INTO user_statistics us USING (SELECT u.user_id, COUNT(o.order_id) as total_orders, SUM(o.total_amount) as total_amount, MAX(o.order_date) as last_order_date FROM users u JOIN orders o ON u.user_id = o.user_id WHERE u.status = 'ACTIVE' AND o.order_status = 'COMPLETED' GROUP BY u.user_id) src ON (us.user_id = src.user_id) WHEN MATCHED THEN UPDATE SET total_orders = src.total_orders, total_amount = src.total_amount, last_order_date = src.last_order_date, updated_at = SYSDATE WHEN NOT MATCHED THEN INSERT (user_id, total_orders, total_amount, last_order_date, created_at, updated_at) VALUES (src.user_id, src.total_orders, src.total_amount, src.last_order_date, SYSDATE, SYSDATE) |
| mergeProductInventory | product_inventory, products, categories, brands | LEFT JOIN | products.category_id = categories.category_id, products.brand_id = brands.brand_id, product_inventory.product_id = products.product_id | MERGE INTO product_inventory pi USING (SELECT p.product_id, p.stock_quantity, c.category_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.status = 'ACTIVE') src ON (pi.product_id = src.product_id) WHEN MATCHED THEN UPDATE SET stock_quantity = src.stock_quantity, category_name = src.category_name, brand_name = src.brand_name, updated_at = SYSDATE WHEN NOT MATCHED THEN INSERT (product_id, stock_quantity, category_name, brand_name, created_at, updated_at) VALUES (src.product_id, src.stock_quantity, src.category_name, src.brand_name, SYSDATE, SYSDATE) |
| mergeOrderSummary | order_summary, orders | 없음 | MERGE INTO order_summary os USING (SELECT TRUNC(order_date) as order_date, COUNT(order_id) as total_orders, SUM(total_amount) as total_amount FROM orders WHERE order_status = 'COMPLETED' GROUP BY TRUNC(order_date)) src ON (os.order_date = src.order_date) WHEN MATCHED THEN UPDATE SET total_orders = src.total_orders, total_amount = src.total_amount, updated_at = SYSDATE WHEN NOT MATCHED THEN INSERT (order_date, total_orders, total_amount, created_at, updated_at) VALUES (src.order_date, src.total_orders, src.total_amount, SYSDATE, SYSDATE) |
| mergeUserActivityLog | user_activity_log, users, orders | LEFT JOIN | users.user_id = orders.user_id, user_activity_log.user_id = users.user_id | MERGE INTO user_activity_log ual USING (SELECT u.user_id, MAX(u.last_login_date) as last_activity, COUNT(o.order_id) as order_count FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY u.user_id) src ON (ual.user_id = src.user_id) WHEN MATCHED THEN UPDATE SET last_activity_date = src.last_activity, order_count = src.order_count, updated_at = SYSDATE WHEN NOT MATCHED THEN INSERT (user_id, last_activity_date, order_count, created_at, updated_at) VALUES (src.user_id, src.last_activity, src.order_count, SYSDATE, SYSDATE) |
| mergeCategoryStatistics | category_statistics, categories, products | LEFT JOIN | categories.category_id = products.category_id, category_statistics.category_id = categories.category_id | MERGE INTO category_statistics cs USING (SELECT c.category_id, c.category_name, COUNT(p.product_id) as product_count, AVG(p.price) as avg_price FROM categories c LEFT JOIN products p ON c.category_id = p.category_id GROUP BY c.category_id, c.category_name) src ON (cs.category_id = src.category_id) WHEN MATCHED THEN UPDATE SET category_name = src.category_name, product_count = src.product_count, avg_price = src.avg_price, updated_at = SYSDATE WHEN NOT MATCHED THEN INSERT (category_id, category_name, product_count, avg_price, created_at, updated_at) VALUES (src.category_id, src.category_name, src.product_count, src.avg_price, SYSDATE, SYSDATE) |

### 5.2 MergeQueryDao.java - MERGE 쿼리 (5개)

| 쿼리ID | 관련테이블 | 조인조건 | 쿼리내용 |
|--------|-----------|----------|----------|
| mergeUserOrderStatistics | user_statistics, users, orders | LEFT JOIN | users.user_id = orders.user_id, user_statistics.user_id = users.user_id | MERGE INTO user_statistics us USING (SELECT u.user_id, COUNT(o.order_id) as total_orders, SUM(o.total_amount) as total_amount, MAX(o.order_date) as last_order_date FROM users u JOIN orders o ON u.user_id = o.user_id WHERE u.status = 'ACTIVE' AND o.order_status = 'COMPLETED' AND u.created_date > '2024-01-01' GROUP BY u.user_id) src ON (us.user_id = src.user_id) WHEN MATCHED THEN UPDATE SET total_orders = src.total_orders, total_amount = src.total_amount, last_order_date = src.last_order_date, updated_at = SYSDATE WHEN NOT MATCHED THEN INSERT (user_id, total_orders, total_amount, last_order_date, created_at, updated_at) VALUES (src.user_id, src.total_orders, src.total_amount, src.last_order_date, SYSDATE, SYSDATE) |
| mergeProductInventory | product_inventory, products, categories, brands | LEFT JOIN | products.category_id = categories.category_id, products.brand_id = brands.brand_id, product_inventory.product_id = products.product_id | MERGE INTO product_inventory pi USING (SELECT p.product_id, p.stock_quantity, c.category_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.status = 'ACTIVE') src ON (pi.product_id = src.product_id) WHEN MATCHED THEN UPDATE SET stock_quantity = src.stock_quantity, category_name = src.category_name, brand_name = src.brand_name, updated_at = SYSDATE WHEN NOT MATCHED THEN INSERT (product_id, stock_quantity, category_name, brand_name, created_at, updated_at) VALUES (src.product_id, src.stock_quantity, src.category_name, src.brand_name, SYSDATE, SYSDATE) |
| mergeOrderSummary | order_summary, orders | 없음 | MERGE INTO order_summary os USING (SELECT TRUNC(order_date) as order_date, COUNT(order_id) as total_orders, SUM(total_amount) as total_amount FROM orders WHERE order_status = 'COMPLETED' GROUP BY TRUNC(order_date)) src ON (os.order_date = src.order_date) WHEN MATCHED THEN UPDATE SET total_orders = src.total_orders, total_amount = src.total_amount, updated_at = SYSDATE WHEN NOT MATCHED THEN INSERT (order_date, total_orders, total_amount, created_at, updated_at) VALUES (src.order_date, src.total_orders, src.total_amount, SYSDATE, SYSDATE) |
| mergeUserActivityLog | user_activity_log, users, orders | LEFT JOIN | users.user_id = orders.user_id, user_activity_log.user_id = users.user_id | MERGE INTO user_activity_log ual USING (SELECT u.user_id, MAX(u.last_login_date) as last_activity, COUNT(o.order_id) as order_count FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY u.user_id) src ON (ual.user_id = src.user_id) WHEN MATCHED THEN UPDATE SET last_activity_date = src.last_activity, order_count = src.order_count, updated_at = SYSDATE WHEN NOT MATCHED THEN INSERT (user_id, last_activity_date, order_count, created_at, updated_at) VALUES (src.user_id, src.last_activity, src.order_count, SYSDATE, SYSDATE) |
| mergeCategoryStatistics | category_statistics, categories, products | LEFT JOIN | categories.category_id = products.category_id, category_statistics.category_id = categories.category_id | MERGE INTO category_statistics cs USING (SELECT c.category_id, c.category_name, COUNT(p.product_id) as product_count, AVG(p.price) as avg_price FROM categories c LEFT JOIN products p ON c.category_id = p.category_id GROUP BY c.category_id, c.category_name) src ON (cs.category_id = src.category_id) WHEN MATCHED THEN UPDATE SET category_name = src.category_name, product_count = src.product_count, avg_price = src.avg_price, updated_at = SYSDATE WHEN NOT MATCHED THEN INSERT (category_id, category_name, product_count, avg_price, created_at, updated_at) VALUES (src.category_id, src.category_name, src.product_count, src.avg_price, SYSDATE, SYSDATE) |

## 6. 요약

### 6.1 SQL 쿼리 총계

| 쿼리타입 | 개수 | 비고 |
|---------|------|------|
| SQL_SELECT | 35개 | MyBatis XML 20개, JPA Repository 15개 |
| SQL_INSERT | 8개 | MyBatis XML 6개, Java DAO 2개 |
| SQL_UPDATE | 8개 | MyBatis XML 6개, Java DAO 2개 |
| SQL_DELETE | 8개 | MyBatis XML 6개, Java DAO 2개 |
| SQL_MERGE | 10개 | MyBatis XML 5개, Java DAO 5개 |
| **총계** | **69개** | **정제된 전체 쿼리 기준** |

### 6.2 조인관계 분석

| 조인타입 | 개수 | 비고 |
|---------|------|------|
| JOIN_EXPLICIT | 15개 | 명시적 JOIN ... ON 절 |
| JOIN_IMPLICIT | 10개 | WHERE 절의 암시적 조인 |
| JOIN_MERGEON | 10개 | MERGE ... USING ... ON 절 |
| **총계** | **35개** | **테이블간 관계 도출** |
