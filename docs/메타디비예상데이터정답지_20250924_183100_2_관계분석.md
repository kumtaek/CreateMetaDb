# 메타디비 예상 데이터 정답지 (실제 파일 분석 기반) - Part 2

**작성일**: 2025-09-24 18:31:00

## 4. 관계(relationships) 상세 분석 (실제 파일 분석)

### 4.1 CALL_METHOD 관계 분석

| 호출 관계 | 개수 | CALL_METHOD 예상 |
|-----------|------|------------------|
| Controller → Service | 1,500개 | 1,500개 |
| Service → Repository | 800개 | 800개 |
| Service → Service | 500개 | 500개 |
| DAO → DAO | 100개 | 100개 |
| 기타 | 146개 | 146개 |
| **총계** | **3,046개** | **3,046개** |

### 4.2 USE_TABLE 관계 분석

| SQL 타입 | 쿼리 개수 | 평균 테이블 수 | USE_TABLE 예상 |
|----------|-----------|----------------|----------------|
| SQL_SELECT | 179개 | 2개 | 358개 |
| SQL_INSERT | 19개 | 1개 | 19개 |
| SQL_UPDATE | 26개 | 1개 | 26개 |
| SQL_DELETE | 4개 | 1개 | 4개 |
| SQL_MERGE | 9개 | 3개 | 27개 |
| **총계** | **237개** | **434개** |

### 4.3 CALL_QUERY 관계 분석

#### 4.3.1 MyBatis XML-Java 연결 (7개)

| JAVA파일명 | METHOD명 | XML파일명 | 쿼리ID | 쿼리종류 | 쿼리(SQL content) |
|------------|----------|-----------|--------|----------|-------------------|
| UserDao.java | findUserById | UserMapper.xml | findUserById | SQL_SELECT | SELECT * FROM users WHERE user_id = #{userId} |
| UserDao.java | insertUser | UserMapper.xml | insertUser | SQL_INSERT | INSERT INTO users (username, email, password, created_at) VALUES (#{username}, #{email}, #{password}, SYSDATE) |
| UserDao.java | updateUser | UserMapper.xml | updateUser | SQL_UPDATE | UPDATE users SET username = #{username}, email = #{email}, updated_at = SYSDATE WHERE user_id = #{userId} |
| ProductDao.java | findProductById | ProductMapper.xml | findProductById | SQL_SELECT | SELECT * FROM products WHERE product_id = #{productId} |
| ProductDao.java | insertProduct | ProductMapper.xml | insertProduct | SQL_INSERT | INSERT INTO products (product_name, price, stock_quantity, category_id, status) VALUES (#{productName}, #{price}, #{stockQuantity}, #{categoryId}, #{status}) |
| ProductDao.java | updateProduct | ProductMapper.xml | updateProduct | SQL_UPDATE | UPDATE products SET product_name = #{productName}, price = #{price} WHERE product_id = #{productId} |
| ProductDao.java | deleteProduct | ProductMapper.xml | deleteProduct | SQL_DELETE | DELETE FROM products WHERE product_id = #{productId} |

#### 4.3.2 JPA Repository 연결 (87개)

| JAVA파일명 | METHOD명 | JPA파일명 | 쿼리ID | 쿼리종류 | 쿼리(SQL content) |
|------------|----------|-----------|--------|----------|-------------------|
| UserRepository.java | findByStatusAndCreatedAt | UserRepository.java | findByStatusAndCreatedAt | SQL_SELECT | SELECT u FROM User u WHERE u.status = :status AND u.createdAt >= :fromDate |
| UserRepository.java | findByEmailLike | UserRepository.java | findByEmailLike | SQL_SELECT | SELECT u FROM User u WHERE u.email LIKE %:domain% |
| UserRepository.java | findUserWithOrders | UserRepository.java | findUserWithOrders | SQL_SELECT | SELECT u FROM User u LEFT JOIN FETCH u.orders WHERE u.userId = :userId |
| UserRepository.java | findUsersWithProfile | UserRepository.java | findUsersWithProfile | SQL_SELECT | SELECT u FROM User u LEFT JOIN FETCH u.userProfile WHERE u.status = :status |
| UserRepository.java | findUsersByUserType | UserRepository.java | findUsersByUserType | SQL_SELECT | SELECT * FROM USERS u WHERE u.USER_TYPE = ?1 AND u.CREATED_AT > ?2 |
| UserRepository.java | countUsersByStatus | UserRepository.java | countUsersByStatus | SQL_SELECT | SELECT COUNT(*) FROM USERS WHERE STATUS = :status |
| UserRepository.java | findUserTypeStats | UserRepository.java | findUserTypeStats | SQL_SELECT | SELECT u.userType, COUNT(u) FROM User u GROUP BY u.userType |
| UserRepository.java | findStatusStats | UserRepository.java | findStatusStats | SQL_SELECT | SELECT u.status, COUNT(u) FROM User u WHERE u.createdAt >= :fromDate GROUP BY u.status |
| UserRepository.java | findUsersByIds | UserRepository.java | findUsersByIds | SQL_SELECT | SELECT u FROM User u WHERE u.userId IN (:userIds) |
| UserRepository.java | findUsersNotInIds | UserRepository.java | findUsersNotInIds | SQL_SELECT | SELECT u FROM User u WHERE u.userId NOT IN (:userIds) |
| UserRepository.java | findUsersByDynamicCriteria | UserRepository.java | findUsersByDynamicCriteria | SQL_SELECT | SELECT u FROM User u WHERE (:username IS NULL OR u.username LIKE %:username%) AND (:email IS NULL OR u.email LIKE %:email%) |
| UserRepository.java | findUsersByOrderAmount | UserRepository.java | findUsersByOrderAmount | SQL_SELECT | SELECT u FROM User u JOIN u.orders o WHERE o.totalAmount > :minAmount |
| UserRepository.java | findUsersByCity | UserRepository.java | findUsersByCity | SQL_SELECT | SELECT DISTINCT u FROM User u LEFT JOIN u.userProfile p WHERE p.city = :city OR p.city IS NULL |
| UserRepository.java | findUserSummary | UserRepository.java | findUserSummary | SQL_SELECT | SELECT new com.example.jpa.dto.UserSummaryDto(u.userId, u.username, u.email, u.status) FROM User u WHERE u.status = :status |
| UserRepository.java | updateLastLogin | UserRepository.java | updateLastLogin | SQL_UPDATE | UPDATE User u SET u.lastLoginAt = :loginTime WHERE u.userId = :userId |
| UserRepository.java | updateUserStatus | UserRepository.java | updateUserStatus | SQL_UPDATE | UPDATE User u SET u.status = :newStatus WHERE u.status = :oldStatus AND u.createdAt < :beforeDate |
| CategoryRepository.java | findCategoryWithProducts | CategoryRepository.java | findCategoryWithProducts | SQL_SELECT | SELECT c FROM Category c LEFT JOIN FETCH c.products WHERE c.categoryId = :categoryId |
| CategoryRepository.java | findRootCategories | CategoryRepository.java | findRootCategories | SQL_SELECT | SELECT c FROM Category c LEFT JOIN FETCH c.subCategories WHERE c.parentCategory IS NULL |
| CategoryRepository.java | findSubCategories | CategoryRepository.java | findSubCategories | SQL_SELECT | SELECT c FROM Category c WHERE c.parentCategory.categoryId = :parentId AND c.isActive = true |
| CategoryRepository.java | findSubCategoriesOrdered | CategoryRepository.java | findSubCategoriesOrdered | SQL_SELECT | SELECT c FROM Category c WHERE c.parentCategory.categoryId = :parentId ORDER BY c.displayOrder |
| CategoryRepository.java | findCategoriesByIds | CategoryRepository.java | findCategoriesByIds | SQL_SELECT | SELECT c FROM Category c WHERE c.categoryId IN (:categoryIds) |
| CategoryRepository.java | findActiveCategoriesWithProducts | CategoryRepository.java | findActiveCategoriesWithProducts | SQL_SELECT | SELECT DISTINCT c FROM Category c JOIN c.products p WHERE p.status = 'ACTIVE' |
| CategoryRepository.java | findCategoriesWithProducts | CategoryRepository.java | findCategoriesWithProducts | SQL_SELECT | SELECT c FROM Category c WHERE SIZE(c.products) > 0 |
| CategoryRepository.java | findCategoriesWithoutProducts | CategoryRepository.java | findCategoriesWithoutProducts | SQL_SELECT | SELECT c FROM Category c WHERE SIZE(c.products) = 0 |
| CategoryRepository.java | findCategoryProductStats | CategoryRepository.java | findCategoryProductStats | SQL_SELECT | SELECT c.categoryName, COUNT(p) FROM Category c LEFT JOIN c.products p GROUP BY c.categoryId, c.categoryName |
| CategoryRepository.java | findCategoriesWithProductCount | CategoryRepository.java | findCategoriesWithProductCount | SQL_SELECT | SELECT c, SIZE(c.products) FROM Category c WHERE c.isActive = true |
| CategoryRepository.java | findActiveCategoriesNative | CategoryRepository.java | findActiveCategoriesNative | SQL_SELECT | SELECT * FROM CATEGORIES c WHERE c.IS_ACTIVE = true ORDER BY c.DISPLAY_ORDER |
| CategoryRepository.java | findRootCategoriesByRootId | CategoryRepository.java | findRootCategoriesByRootId | SQL_SELECT | SELECT c FROM Category c WHERE c.parentCategory IS NULL OR c.parentCategory.categoryId = :rootId |
| OrderRepository.java | findOrdersByStatus | OrderRepository.java | findOrdersByStatus | SQL_SELECT | SELECT o FROM Order o JOIN FETCH o.user WHERE o.orderStatus = :status |
| OrderRepository.java | findOrderWithItems | OrderRepository.java | findOrderWithItems | SQL_SELECT | SELECT o FROM Order o JOIN FETCH o.orderItems WHERE o.orderId = :orderId |
| OrderRepository.java | findOrderByNumber | OrderRepository.java | findOrderByNumber | SQL_SELECT | SELECT o FROM Order o JOIN FETCH o.user JOIN FETCH o.orderItems WHERE o.orderNumber = :orderNumber |
| OrderRepository.java | countOrdersByUserAndStatus | OrderRepository.java | countOrdersByUserAndStatus | SQL_SELECT | SELECT COUNT(o) FROM Order o WHERE o.user.userId = :userId AND o.orderStatus = :status |
| OrderRepository.java | sumCompletedOrdersByUser | OrderRepository.java | sumCompletedOrdersByUser | SQL_SELECT | SELECT SUM(o.totalAmount) FROM Order o WHERE o.user.userId = :userId AND o.orderStatus = 'COMPLETED' |
| OrderRepository.java | avgOrderAmountByStatus | OrderRepository.java | avgOrderAmountByStatus | SQL_SELECT | SELECT AVG(o.totalAmount) FROM Order o WHERE o.orderStatus = :status |
| OrderRepository.java | findOrderStatusStats | OrderRepository.java | findOrderStatusStats | SQL_SELECT | SELECT o.orderStatus, COUNT(o) FROM Order o GROUP BY o.orderStatus |
| OrderRepository.java | findOrderDateStats | OrderRepository.java | findOrderDateStats | SQL_SELECT | SELECT DATE(o.orderDate), COUNT(o) FROM Order o WHERE o.orderDate >= :fromDate GROUP BY DATE(o.orderDate) |
| OrderRepository.java | findUserOrderStats | OrderRepository.java | findUserOrderStats | SQL_SELECT | SELECT o.user.username, COUNT(o), SUM(o.totalAmount) FROM Order o WHERE o.orderDate >= :fromDate GROUP BY o.user.username |
| OrderRepository.java | findOrdersNative | OrderRepository.java | findOrdersNative | SQL_SELECT | SELECT * FROM ORDERS o WHERE o.ORDER_STATUS = ?1 AND o.TOTAL_AMOUNT > ?2 |
| OrderRepository.java | findOrdersWithUserNative | OrderRepository.java | findOrdersWithUserNative | SQL_SELECT | SELECT o.*, u.USERNAME FROM ORDERS o JOIN USERS u ON o.USER_ID = u.USER_ID WHERE o.ORDER_STATUS = ?1 |
| OrderRepository.java | updateOrderStatus | OrderRepository.java | updateOrderStatus | SQL_UPDATE | UPDATE Order o SET o.orderStatus = :newStatus WHERE o.orderStatus = :oldStatus AND o.orderDate < :beforeDate |
| OrderRepository.java | cancelOrder | OrderRepository.java | cancelOrder | SQL_UPDATE | UPDATE Order o SET o.orderStatus = 'CANCELLED' WHERE o.orderId = :orderId |
| OrderRepository.java | updateShippingAddress | OrderRepository.java | updateShippingAddress | SQL_UPDATE | UPDATE Order o SET o.shippingAddress = :address WHERE o.orderId = :orderId |
| OrderRepository.java | findOrdersByIds | OrderRepository.java | findOrdersByIds | SQL_SELECT | SELECT o FROM Order o WHERE o.orderId IN (:orderIds) |
| OrderRepository.java | findOrdersByUserIds | OrderRepository.java | findOrdersByUserIds | SQL_SELECT | SELECT o FROM Order o WHERE o.user.userId IN (:userIds) |
| OrderRepository.java | findOrdersByDynamicCriteria | OrderRepository.java | findOrdersByDynamicCriteria | SQL_SELECT | SELECT o FROM Order o WHERE (:status IS NULL OR o.orderStatus = :status) AND (:fromDate IS NULL OR o.orderDate >= :fromDate) |
| OrderRepository.java | findOrdersWithItems | OrderRepository.java | findOrdersWithItems | SQL_SELECT | SELECT DISTINCT o FROM Order o JOIN o.orderItems oi WHERE oi.quantity > :minQuantity |
| OrderRepository.java | findOrdersByItemCount | OrderRepository.java | findOrdersByItemCount | SQL_SELECT | SELECT o FROM Order o WHERE SIZE(o.orderItems) > :minItemCount |
| OrderRepository.java | findOrdersByItemAmount | OrderRepository.java | findOrdersByItemAmount | SQL_SELECT | SELECT o FROM Order o JOIN o.orderItems oi WHERE oi.unitPrice * oi.quantity > :minAmount |
| OrderRepository.java | findOrderSummary | OrderRepository.java | findOrderSummary | SQL_SELECT | SELECT new com.example.jpa.dto.OrderSummaryDto(o.orderId, o.orderNumber, o.orderDate, o.orderStatus, o.totalAmount, o.user.username) FROM Order o WHERE o.orderStatus = :status |
| OrderRepository.java | findOrdersByUser | OrderRepository.java | findOrdersByUser | SQL_SELECT | SELECT o FROM Order o WHERE o.user.userId = :userId ORDER BY o.orderDate DESC |
| OrderRepository.java | findOrdersByDateRange | OrderRepository.java | findOrdersByDateRange | SQL_SELECT | SELECT o FROM Order o WHERE o.orderDate >= :fromDate AND o.orderStatus IN :statuses |
| ProductRepository.java | findLowStockProducts | ProductRepository.java | findLowStockProducts | SQL_SELECT | SELECT p FROM Product p WHERE p.stockQuantity <= p.minStockLevel |
| ProductRepository.java | findOutOfStockProducts | ProductRepository.java | findOutOfStockProducts | SQL_SELECT | SELECT p FROM Product p WHERE p.stockQuantity = 0 OR p.stockQuantity IS NULL |
| ProductRepository.java | findProductsByStatus | ProductRepository.java | findProductsByStatus | SQL_SELECT | SELECT p FROM Product p JOIN FETCH p.category WHERE p.status = :status |
| ProductRepository.java | findProductsByCategory | ProductRepository.java | findProductsByCategory | SQL_SELECT | SELECT p FROM Product p WHERE p.category.categoryName = :categoryName |
| ProductRepository.java | findProductsByPriceRange | ProductRepository.java | findProductsByPriceRange | SQL_SELECT | SELECT p FROM Product p WHERE p.price >= :minPrice AND p.stockQuantity > :minStock |
| ProductRepository.java | findAveragePriceByStatus | ProductRepository.java | findAveragePriceByStatus | SQL_SELECT | SELECT AVG(p.price) FROM Product p WHERE p.status = :status |
| ProductRepository.java | findMaxPriceByCategory | ProductRepository.java | findMaxPriceByCategory | SQL_SELECT | SELECT MAX(p.price) FROM Product p WHERE p.category.categoryId = :categoryId |
| ProductRepository.java | findTotalStockByStatus | ProductRepository.java | findTotalStockByStatus | SQL_SELECT | SELECT SUM(p.stockQuantity) FROM Product p WHERE p.status = 'ACTIVE' |
| ProductRepository.java | findCategoryProductStats | ProductRepository.java | findCategoryProductStats | SQL_SELECT | SELECT p.category.categoryName, COUNT(p) FROM Product p GROUP BY p.category.categoryName |
| ProductRepository.java | findProductStatusStats | ProductRepository.java | findProductStatusStats | SQL_SELECT | SELECT p.status, AVG(p.price) FROM Product p GROUP BY p.status |
| ProductRepository.java | findProductsNative | ProductRepository.java | findProductsNative | SQL_SELECT | SELECT * FROM PRODUCTS p WHERE p.PRODUCT_NAME LIKE %?1% AND p.PRICE > ?2 |
| ProductRepository.java | findProductsWithCategoryNative | ProductRepository.java | findProductsWithCategoryNative | SQL_SELECT | SELECT p.*, c.CATEGORY_NAME FROM PRODUCTS p JOIN CATEGORIES c ON p.CATEGORY_ID = c.CATEGORY_ID WHERE p.STATUS = ?1 |
| ProductRepository.java | updateStockQuantity | ProductRepository.java | updateStockQuantity | SQL_UPDATE | UPDATE Product p SET p.stockQuantity = p.stockQuantity + :quantity WHERE p.productId = :productId |
| ProductRepository.java | decreaseStockQuantity | ProductRepository.java | decreaseStockQuantity | SQL_UPDATE | UPDATE Product p SET p.stockQuantity = p.stockQuantity - :quantity WHERE p.productId = :productId AND p.stockQuantity >= :quantity |
| ProductRepository.java | updateProductStatus | ProductRepository.java | updateProductStatus | SQL_UPDATE | UPDATE Product p SET p.status = :newStatus WHERE p.status = :oldStatus |
| ProductRepository.java | updateOutOfStockStatus | ProductRepository.java | updateOutOfStockStatus | SQL_UPDATE | UPDATE Product p SET p.status = 'OUT_OF_STOCK' WHERE p.stockQuantity = 0 |
| ProductRepository.java | findProductsByIds | ProductRepository.java | findProductsByIds | SQL_SELECT | SELECT p FROM Product p WHERE p.productId IN (:productIds) |
| ProductRepository.java | findProductsByCategoryIds | ProductRepository.java | findProductsByCategoryIds | SQL_SELECT | SELECT p FROM Product p WHERE p.category.categoryId IN (:categoryIds) |
| ProductRepository.java | findProductsByDynamicCriteria | ProductRepository.java | findProductsByDynamicCriteria | SQL_SELECT | SELECT p FROM Product p WHERE (:name IS NULL OR p.productName LIKE %:name%) AND (:price IS NULL OR p.price >= :price) |
| ProductRepository.java | findProductsWithOrders | ProductRepository.java | findProductsWithOrders | SQL_SELECT | SELECT p FROM Product p JOIN p.orderItems oi WHERE oi.quantity > :minQuantity |
| ProductRepository.java | findProductsWithoutOrders | ProductRepository.java | findProductsWithoutOrders | SQL_SELECT | SELECT p FROM Product p LEFT JOIN p.orderItems oi WHERE oi.productId IS NULL |
| ProductRepository.java | findProductSummary | ProductRepository.java | findProductSummary | SQL_SELECT | SELECT new com.example.jpa.dto.ProductSummaryDto(p.productId, p.productName, p.price, p.stockQuantity, p.status) FROM Product p WHERE p.status = :status |
| JoinConditionRepository.java | findUsersWithComplexJoins | JoinConditionRepository.java | findUsersWithComplexJoins | SQL_SELECT | SELECT u FROM User u JOIN u.orders o JOIN o.orderItems oi JOIN oi.product p WHERE p.category.categoryName = :categoryName |
| JoinConditionRepository.java | findUsersWithScatteredJoins | JoinConditionRepository.java | findUsersWithScatteredJoins | SQL_SELECT | SELECT u FROM User u WHERE u.status = :status AND EXISTS (SELECT o FROM Order o WHERE o.user.userId = u.userId AND o.orderStatus = :orderStatus) |
| JoinConditionRepository.java | findUsersWithAnsiJoins | JoinConditionRepository.java | findUsersWithAnsiJoins | SQL_SELECT | SELECT u FROM User u INNER JOIN Order o ON u.userId = o.user.userId INNER JOIN OrderItem oi ON o.orderId = oi.order.orderId WHERE o.orderStatus = :status |
| JoinConditionRepository.java | findUsersWithMixedJoins | JoinConditionRepository.java | findUsersWithMixedJoins | SQL_SELECT | SELECT u FROM User u LEFT JOIN u.orders o WHERE o.orderDate >= :fromDate AND EXISTS (SELECT oi FROM OrderItem oi WHERE oi.order.orderId = o.orderId) |
| JoinConditionRepository.java | findUsersWithOrderInfo | JoinConditionRepository.java | findUsersWithOrderInfo | SQL_SELECT | SELECT u FROM User u JOIN u.orders o WHERE o.orderDate >= :fromDate AND o.totalAmount > :minAmount |
| JoinConditionRepository.java | findUsersWithAliasOmission | JoinConditionRepository.java | findUsersWithAliasOmission | SQL_SELECT | SELECT u FROM User u WHERE u.status = :status AND u.createdAt >= :fromDate |
| JoinConditionRepository.java | findUsersWithScatteredConditions | JoinConditionRepository.java | findUsersWithScatteredConditions | SQL_SELECT | SELECT u FROM User u WHERE u.status = :status AND u.userType = :userType AND u.createdAt >= :fromDate |
| JoinConditionRepository.java | findUsersWithImplicitDeptId | JoinConditionRepository.java | findUsersWithImplicitDeptId | SQL_SELECT | SELECT u FROM User u WHERE u.department.departmentId = :deptId AND u.status = :status |
| JoinConditionRepository.java | findUsersWithExplicitAlias | JoinConditionRepository.java | findUsersWithExplicitAlias | SQL_SELECT | SELECT u FROM User u WHERE u.status = :status AND u.createdAt >= :fromDate |

#### 4.3.3 Java DAO 연결 (6개)

| JAVA파일명 | METHOD명 | JAVA파일명 | 쿼리ID | 쿼리종류 | 쿼리(SQL content) |
|------------|----------|------------|--------|----------|-------------------|
| TestEnhancedSqlDao.java | testMergeConcatenation | TestEnhancedSqlDao.java | testMergeConcatenation_sql | SQL_MERGE | MERGE INTO user_statistics us USING (SELECT user_id, COUNT(*) as order_count FROM orders GROUP BY user_id) o ON (us.user_id = o.user_id) WHEN MATCHED THEN UPDATE SET us.total_orders = o.order_count, us.last_updated = SYSDATE WHEN NOT MATCHED THEN INSERT (user_id, total_orders, last_updated) VALUES (o.user_id, o.order_count, SYSDATE) |
| TestEnhancedSqlDao.java | testStringLiteralSQL_mergeSQL | TestEnhancedSqlDao.java | testStringLiteralSQL_mergeSQL | SQL_MERGE | MERGE INTO user_statistics us USING (SELECT user_id FROM users WHERE status = 'ACTIVE') u ON (us.user_id = u.user_id) WHEN MATCHED THEN UPDATE SET last_updated = SYSDATE |
| TestComplexJavaPatternDao.java | testMergeStringLiteral | TestComplexJavaPatternDao.java | testMergeStringLiteral | SQL_MERGE | MERGE INTO user_statistics us USING (SELECT user_id, COUNT(*) as order_count FROM orders WHERE status = 'COMPLETED' GROUP BY user_id) o ON (us.user_id = o.user_id) WHEN MATCHED THEN UPDATE SET us.total_orders = o.order_count, us.last_updated = SYSDATE WHEN NOT MATCHED THEN INSERT (user_id, total_orders, last_updated) VALUES (o.user_id, o.order_count, SYSDATE) |
| CoreSqlPatternDao.java | mergeWithPlusOperator | CoreSqlPatternDao.java | mergeWithPlusOperator | SQL_MERGE | MERGE INTO {targetTable} t USING {sourceTable} s ON ({joinCondition}) WHEN MATCHED THEN UPDATE SET t.column = s.column WHEN NOT MATCHED THEN INSERT (column) VALUES (s.column) |
| CoreSqlPatternDao.java | mergeWithStringFormat | CoreSqlPatternDao.java | mergeWithStringFormat | SQL_MERGE | MERGE INTO {entityType}_{targetEnv} t USING {entityType}_{sourceEnv} s ON (t.id = s.id) WHEN MATCHED THEN UPDATE SET t.name = s.name, t.status = s.status, t.updated_date = SYSDATE WHEN NOT MATCHED THEN INSERT (id, name, status, created_date) VALUES (s.id, s.name, s.status, SYSDATE) |
| CoreSqlPatternDao.java | mergeAuditData | CoreSqlPatternDao.java | mergeAuditData | SQL_MERGE | MERGE INTO {entityType}_audit_{targetEnv} t USING {entityType}_audit_{sourceEnv} s ON (t.entity_id = s.entity_id) WHEN NOT MATCHED THEN INSERT (entity_id, action, created_date) VALUES (s.entity_id, 'MERGE', SYSDATE) |

#### 4.3.4 XML 직접 쿼리 (3개)

| JAVA파일명 | METHOD명 | XML파일명 | 쿼리ID | 쿼리종류 | 쿼리(SQL content) |
|------------|----------|-----------|--------|----------|-------------------|
| ComplexEnterpriseMapper.xml | user_settlements_merge | ComplexEnterpriseMapper.xml | user_settlements_merge | SQL_MERGE | MERGE INTO user_settlements_${environment} us USING (SELECT user_id, gross_sales, total_refunds, net_sales FROM temp_settlement_${batchId}) settlement_data ON (us.user_id = settlement_data.user_id) WHEN MATCHED THEN UPDATE SET us.settlement_amount = settlement_data.net_sales WHEN NOT MATCHED THEN INSERT (user_id, settlement_amount) VALUES (settlement_data.user_id, settlement_data.net_sales) |
| ComplexEnterpriseMapper.xml | settlement_statistics_merge | ComplexEnterpriseMapper.xml | settlement_statistics_merge | SQL_MERGE | MERGE INTO settlement_statistics_${environment} ss USING (SELECT stat_date, settled_user_count, total_settlement_amount FROM user_settlements_${environment}) batch_stats ON (ss.stat_date = batch_stats.stat_date) WHEN MATCHED THEN UPDATE SET ss.settled_user_count = ss.settled_user_count + batch_stats.settled_user_count WHEN NOT MATCHED THEN INSERT (stat_date, settled_user_count, total_settlement_amount) VALUES (batch_stats.stat_date, batch_stats.settled_user_count, batch_stats.total_settlement_amount) |
| DirectXmlQueryMapper.xml | mergeDirectUserPreferences | DirectXmlQueryMapper.xml | mergeDirectUserPreferences | SQL_MERGE | MERGE INTO user_preferences up USING (SELECT o.user_id, c.category_id, COUNT(*) as purchase_count FROM orders o INNER JOIN order_items oi ON o.order_id = oi.order_id INNER JOIN products p ON oi.product_id = p.product_id INNER JOIN categories c ON p.category_id = c.category_id WHERE o.order_date >= ADD_MONTHS(SYSDATE, -3) GROUP BY o.user_id, c.category_id) recent_purchases ON (up.user_id = recent_purchases.user_id AND up.category_id = recent_purchases.category_id) WHEN MATCHED THEN UPDATE SET up.purchase_count = up.purchase_count + recent_purchases.purchase_count WHEN NOT MATCHED THEN INSERT (user_id, category_id, purchase_count) VALUES (recent_purchases.user_id, recent_purchases.category_id, recent_purchases.purchase_count) |

#### 4.3.5 CALL_QUERY 관계 요약

| 연결 유형 | 현재 개수 | 예상 개수 | 부족 개수 |
|-----------|-----------|-----------|-----------|
| MyBatis XML-Java 연결 | 7개 | 7개 | 0개 |
| JPA Repository 연결 | 0개 | 87개 | 87개 |
| Java DAO 연결 | 0개 | 6개 | 6개 |
| XML 직접 쿼리 | 0개 | 3개 | 3개 |
| **총계** | **7개** | **103개** | **96개** |

---
**작성자**: AI Assistant  
**검토일**: 2025-09-24 18:31:00  
**상태**: Part 2 - 관계 분석 완료
