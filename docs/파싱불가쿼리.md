# 파싱 불가능한 SQL 쿼리 사례 분석

## 개요

현재 SQL 파서가 테이블명을 정확히 인식하지 못하는 케이스들을 분석하고, 각 사례별로 소스 파일 위치와 파서의 한계점을 정리한 문서입니다.

## 1. 서브쿼리 케이스 - 파서의 한계

### 소스 파일 위치

- **파일**: `CreateMetaDb/projects/SampleSrc/src/main/resources/mybatis/mapper/MicroserviceMapper.xml`
- **라인**: 59-67
- **쿼리 ID**: `selectDashboardData`

### 쿼리 내용

```xml
<select id="selectDashboardData" resultType="map">
    SELECT 
        (SELECT COUNT(*) FROM users WHERE del_yn = 'N') as total_users,
        (SELECT COUNT(*) FROM products WHERE del_yn = 'N' AND status = 'ACTIVE') as total_products,
        (SELECT COUNT(*) FROM orders WHERE del_yn = 'N') as total_orders,
        (SELECT SUM(total_amount) FROM orders WHERE del_yn = 'N' AND status = 'COMPLETED') as total_revenue,
        (SELECT COUNT(*) FROM notifications WHERE del_yn = 'N' AND is_read = 'N') as unread_notifications,
        (SELECT COUNT(*) FROM recommendations WHERE del_yn = 'N' AND status = 'ACTIVE') as active_recommendations
</select>
```

### 파서 한계점

- **현재 파서 인식 결과**: `['USERS WHERE', 'PRODUCTS WHERE', 'ORDERS WHERE', 'ORDERS WHERE', 'NOTIFICATIONS WHERE', 'RECOMMENDATIONS WHERE']`
- **실제 테이블명**: `users`, `products`, `orders`, `notifications`, `recommendations`
- **문제점**: 서브쿼리 내부의 테이블명을 인식하지 못하고 WHERE 절까지 포함하여 파싱

### 개선 방향

- 정규식을 확장하여 `(SELECT ... FROM table)` 패턴 인식
- 서브쿼리 내부의 FROM 절을 별도로 파싱하는 로직 추가

## 2. UNION 케이스 - 복잡한 구조

### 소스 파일 위치

- **파일**: `CreateMetaDb/projects/SampleSrc/src/main/resources/mybatis/mapper/MicroserviceMapper.xml`
- **라인**: 70-108
- **쿼리 ID**: `selectGlobalSearch`

### 쿼리 내용

```xml
<select id="selectGlobalSearch" parameterType="string" resultType="map">
    SELECT 'user' as type, user_id as id, username as name, email as description, created_at
    FROM users
    WHERE (username LIKE CONCAT('%', #{query}, '%') OR email LIKE CONCAT('%', #{query}, '%'))
      AND del_yn = 'N'

    UNION ALL

    SELECT 'product' as type, product_id as id, product_name as name, description, created_at
    FROM products
    WHERE (product_name LIKE CONCAT('%', #{query}, '%') OR description LIKE CONCAT('%', #{query}, '%'))
      AND del_yn = 'N'
      AND status = 'ACTIVE'

    UNION ALL

    SELECT 'order' as type, order_id as id, CONCAT('Order #', order_id) as name, 
           CONCAT('Total: $', total_amount) as description, order_date as created_at
    FROM orders
    WHERE order_id LIKE CONCAT('%', #{query}, '%')
      AND del_yn = 'N'

    ORDER BY created_at DESC
    LIMIT 50
</select>
```

### 파서 한계점

- **현재 파서 인식 결과**: `['USERS\n        WHERE', 'PRODUCTS\n        WHERE', 'ORDERS\n        WHERE']`
- **실제 테이블명**: `users`, `products`, `orders`
- **문제점**: UNION의 각 쿼리에서 테이블명을 개별적으로 인식해야 하는데 줄바꿈과 WHERE 절까지 포함하여 파싱

### 개선 방향

- `UNION ALL` 구분자로 쿼리를 분할한 후 각각 개별적으로 파싱
- 줄바꿈과 공백 처리 개선

## 3. 동적 SQL 케이스 - MyBatis 동적 태그

### 소스 파일 위치

- **파일**: `CreateMetaDb/projects/SampleSrc/src/main/resources/mybatis/mapper/VersionedMapper.xml`
- **라인**: 90-116
- **쿼리 ID**: `selectOrdersV2`

### 쿼리 내용

```xml
<select id="selectOrdersV2" resultType="map">
    SELECT o.order_id, o.user_id, o.order_date, o.total_amount, o.status, o.created_at,
           u.username, u.email, COUNT(oi.order_item_id) as item_count
    FROM orders o
    JOIN users u ON o.user_id = u.user_id
    LEFT JOIN order_items oi ON o.order_id = oi.order_id AND oi.del_yn = 'N'
    WHERE o.del_yn = 'N'
    <if test="status != null and status != ''">
        AND o.status = #{status}
    </if>
    <if test="dateFrom != null and dateFrom != ''">
        AND o.order_date >= #{dateFrom}
    </if>
    <if test="dateTo != null and dateTo != ''">
        AND o.order_date <= #{dateTo}
    </if>
    GROUP BY o.order_id
    ORDER BY o.order_date DESC
</select>
```

### 파서 한계점

- **현재 파서 인식 결과**: `FROM: ['ORDERS O'], JOIN: ['USERS U', 'ORDER_ITEMS OI']`
- **실제 테이블명**: `orders`, `users`, `order_items`
- **문제점**: MyBatis 동적 태그(`<if test="...">`) 처리가 필요하지만 현재 파서는 이를 고려하지 않음

### 개선 방향

- MyBatis 동적 태그 제거 후 파싱하는 전처리 단계 추가
- `#{parameter}` 바인딩 변수 처리

## 4. 시스템 함수 케이스 - 테이블이 아닌 함수

### 소스 파일 위치

- **파일**: `CreateMetaDb/projects/SampleSrc/src/main/resources/mybatis/mapper/ProxyMapper.xml`
- **라인**: 21-35
- **쿼리 ID**: `insertUserToV1`

### 쿼리 내용

```xml
<insert id="insertUserToV1" parameterType="map">
    INSERT INTO users_v1 (
        username, email, status, created_at, del_yn
    ) VALUES (
        #{userData.username}, #{userData.email}, #{userData.status}, NOW(), 'N'
    )
</insert>
```

### 파서 한계점

- **현재 파서 인식 결과**: `['USERS_V1']`
- **실제 테이블명**: `users_v1`
- **문제점**: `NOW()` 같은 시스템 함수는 테이블이 아니지만 현재는 정상 인식됨

### 개선 방향

- 시스템 함수 목록을 정의하여 테이블명에서 제외
- `NOW()`, `SYSDATE`, `CURRENT_TIMESTAMP` 등 처리

## 

### 파서 한계점

- 시스템 테이블(`DUAL`, `INFORMATION_SCHEMA.*`)은 메타데이터에 포함되지 않음 - 포함 안되는게 맞음.
- 임시 테이블은 런타임에 생성되어 파싱 시점에는 존재하지 않음
- 동적 테이블명은 실제 실행 시점에만 결정됨

## 6. 파서 개선 방향

### 1. 서브쿼리 지원

- 정규식 확장: `(SELECT ... FROM table)` 패턴 인식
- 재귀적 파싱으로 중첩된 서브쿼리 처리

### 2. UNION 지원

- `UNION ALL` 구분자로 쿼리 분할
- 각 분할된 쿼리를 개별적으로 파싱

### 3. 동적 SQL 전처리

- MyBatis 태그 제거 후 파싱
- `#{parameter}` 바인딩 변수 처리

### 4. 시스템 함수 필터링

- 시스템 함수 목록 정의
- 테이블명 후보에서 시스템 함수 제외

### 5. 줄바꿈 및 공백 처리

- 정규식에서 줄바꿈(`\n`) 및 공백 처리 개선
- WHERE 절과 테이블명 분리

## 7. 현재 파서 코드 위치

### 테이블명 추출 로직

- **파일**: `CreateMetaDb/xml_loading.py`
- **메서드**: `_extract_table_names_from_sql()` (라인 413-470)
- **메서드**: `_is_valid_table_name_simple()` (라인 472-497)

### 정규식 패턴들

```python
# FROM 절 추출
from_pattern = r'\bFROM\s+([A-Z_][A-Z0-9_]*(?:\s+[A-Z_][A-Z0-9_]*)?)'

# JOIN 절 추출  
join_pattern = r'\b(?:JOIN|INNER\s+JOIN|LEFT\s+JOIN|RIGHT\s+JOIN|OUTER\s+JOIN)\s+([A-Z_][A-Z0-9_]*(?:\s+[A-Z_][A-Z0-9_]*)?)'

# UPDATE 절 추출
update_pattern = r'\bUPDATE\s+([A-Z_][A-Z0-9_]*)'

# INSERT INTO 절 추출
insert_pattern = r'\bINSERT\s+INTO\s+([A-Z_][A-Z0-9_]*)'

# DELETE FROM 절 추출
delete_pattern = r'\bDELETE\s+FROM\s+([A-Z_][A-Z0-9_]*)'
```

## 8. 결론

현재 파서는 기본적인 SQL 구문의 테이블명 추출은 잘 수행하지만, 다음과 같은 복잡한 구조에서는 한계가 있습니다:

1. **서브쿼리**: 중첩된 SELECT 문 내부의 테이블명 인식 불가
2. **UNION**: 여러 쿼리가 결합된 구조에서 개별 테이블명 파싱 어려움
3. **동적 SQL**: MyBatis 태그가 포함된 쿼리에서 전처리 필요
4. **시스템 함수**: 테이블이 아닌 함수 호출과의 구분 필요

이러한 한계로 인해 "Related Tables" 컬럼이 비어있거나 부정확하게 표시되는 경우가 발생하며, 이는 정상적인 현상으로 파악됩니다.
