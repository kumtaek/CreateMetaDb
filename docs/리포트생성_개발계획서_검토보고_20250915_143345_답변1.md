# 리포트 생성 개발계획서 검토보고 답변

## 1. CallChainReport 검토보고에 대한 의견

### 1.1 문제점 검토 의견

#### 1.1.1 누락된 연계 경로 (JSP -> Class)

**검토의견: class는 method compoents.parent_id로 조인 연결됨.

#### 1.1.2 비효율적인 데이터 조회 (GROUP_CONCAT)

**검토의견: 완전 동의**

- **현재 문제**: SQLite의 GROUP_CONCAT 기본 제한(1,000,000바이트)과 성능 이슈가 실제로 발생할 수 있습니다.

- **개선안**: 다음과 같이 수정하겠습니다:
  
  ```sql
  -- 1단계: 기본 연계 체인 조회
  SELECT cls.component_name, m.component_name, xml_file.file_name, q.component_name, q.component_type
  FROM components cls
  JOIN components m ON cls.component_id = m.parent_id
  -- ... 기타 조인
  
  -- 2단계: 각 쿼리별 테이블 정보 별도 조회
  SELECT q.component_id, GROUP_CONCAT(t.table_name) as related_tables
  FROM components q
  LEFT JOIN relationships r2 ON q.component_id = r2.src_id
  LEFT JOIN tables t ON r2.dst_id = t.component_id
  WHERE q.component_id IN (위 쿼리 결과의 component_id들)
  GROUP BY q.component_id
  ```

#### 1.1.3 하드코딩된 필터 옵션

**검토의견: 완전 동의**

- **개선안**: 동적 필터 옵션 생성으로 수정하겠습니다:
  
  ```python
  def _get_filter_options(self) -> Dict[str, List[str]]:
      # 동적으로 쿼리 타입 조회
      query_types_query = """
          SELECT DISTINCT component_type 
          FROM components 
          WHERE component_type LIKE 'SQL_%' OR component_type = 'QUERY'
          AND project_id = (SELECT project_id FROM projects WHERE project_name = ?)
          AND del_yn = 'N'
      """
      query_types = [row['component_type'] for row in self.db_utils.execute_query(query_types_query, (self.project_name,))]
  ```

#### 1.1.4 클라이언트 사이드 필터링의 한계

**검토의견: 부분적으로 동의**

- **현재 한계**: 대용량 데이터에서는 실제로 성능 문제가 발생할 수 있습니다.
- **제안**: 초기에는 클라이언트 사이드 필터링으로 구현하되, 데이터가 1000건 이상일 경우 서버 사이드 필터링으로 전환하는 하이브리드 접근법을 제안합니다.
- **구현 계획**: 
  - 1단계: 클라이언트 사이드 필터링으로 MVP 구현
  - 2단계: 데이터량에 따른 서버 사이드 필터링 자동 전환 로직 추가

#### 1.1.5 불완전한 통계 정보

**검토의견: 완전 동의**

- **개선안**: 관계 유형별 상세 통계 제공:
  
  ```sql
  SELECT 
      CASE 
          WHEN rel_type LIKE 'JOIN_%' THEN 'JOIN'
          WHEN rel_type = 'FK' THEN 'FOREIGN_KEY'
          WHEN rel_type = 'CALL_METHOD' THEN 'METHOD_CALL'
          WHEN rel_type = 'CALL_QUERY' THEN 'QUERY_CALL'
          ELSE 'OTHER'
      END as relation_category,
      COUNT(*) as count
  FROM relationships r
  JOIN projects p ON r.project_id = p.project_id
  WHERE p.project_name = ? AND r.del_yn = 'N'
  GROUP BY relation_category
  ```

### 1.2 개선점 검토 의견

#### 1.2.1 전체 연계 경로 추적

**의견: 데이터 구조 확인 후 구현**

- 먼저 실제 메타데이터베이스에서 JSP-Class 관계 데이터 존재 여부를 확인하겠습니다.
- 데이터가 존재한다면 쿼리를 수정하여 완전한 연계 경로를 제공하겠습니다.

#### 1.2.2 서버 사이드 필터링

**의견: 단계적 구현**

- 1단계: 클라이언트 사이드 필터링으로 기본 기능 구현
- 2단계: 성능 최적화를 위한 서버 사이드 필터링 추가
- 페이지네이션은 초기 버전에서는 제외하고, 필요시 후속 버전에서 추가

## 2. ERD Report 검토보고에 대한 의견

### 2.1 문제점 검토 의견

#### 2.1.1 N+1 쿼리 문제

**검토의견: 완전 동의**

- **개선안**: 단일 쿼리로 최적화하겠습니다:
  
  ```sql
  SELECT 
      t.table_name,
      c.column_name,
      c.data_type,
      c.is_primary_key,
      c.is_nullable,
      c.column_order
  FROM tables t
  JOIN columns c ON t.table_id = c.table_id
  JOIN projects p ON t.project_id = p.project_id
  WHERE p.project_name = ? 
    AND t.del_yn = 'N' 
    AND c.del_yn = 'N'
  ORDER BY t.table_name, c.column_order
  ```

#### 2.1.2 오프라인 환경 미지원 (Mermaid.js CDN)

**검토의견: 완전 동의**

- **해결방안**: Mermaid.js 파일을 프로젝트에 포함시키고 로컬 경로로 로드하겠습니다:
  
  ```html
  <!-- CDN 대신 로컬 파일 사용 -->
  <script src="./libs/mermaid.min.js"></script>
  ```
- **구현 계획**: 
  1. Mermaid.js 파일을 `./libs/` 디렉토리에 포함
  2. HTML 템플릿에서 상대 경로로 로드
  3. 오프라인 환경에서 테스트

#### 2.1.3 부정확한 Mermaid 문법

**검토의견: 완전 동의**

- **PK 표시 개선**: Mermaid ERD에서 PK는 컬럼명 옆에 `PK` 표시가 아닌, 관계 정의에서 표현해야 합니다.
- **관계 유형별 시각화 개선**:
  
  ```javascript
  // 관계 유형별 다른 선 스타일 적용
  const relationshipStyle = {
      'FK': '||--o{',           // Foreign Key
      'JOIN_EXPLICIT': '||--||', // Explicit Join
      'JOIN_IMPLICIT': '}o--o{', // Implicit Join
      'INHERITANCE': '||--||'    // Inheritance
  };
  ```

#### 2.1.4 과도한 데이터 타입 단순화

**검토의견: 부분적으로 동의**

- **개선안**: 기본 다이어그램에서는 간소화하되, 상세 정보 테이블에서는 원본 데이터 타입을 보존:
  
  ```python
  def _normalize_data_type(self, data_type: str) -> str:
      # 다이어그램용 간소화
      if data_type.upper().startswith(('VARCHAR', 'CHAR', 'TEXT')):
          return 'string'
      elif data_type.upper().startswith('INT'):
          return 'int'
      # ... 기타 타입들
      return data_type
  ```

#### 2.1.5 사용성 부족한 UI (패닝 기능)

**검토의견: 동의하되 우선순위 조정**

- **구현 계획**: 
  
  - 1단계: 기본 확대/축소 기능 구현
  - 2단계: 패닝 기능 추가 (마우스 드래그로 이동)

- **기술적 구현**:
  
  ```javascript
  // 패닝 기능 구현
  let isPanning = false;
  let startX, startY;
  
  diagram.addEventListener('mousedown', (e) => {
      isPanning = true;
      startX = e.clientX;
      startY = e.clientY;
  });
  
  diagram.addEventListener('mousemove', (e) => {
      if (isPanning) {
          // 다이어그램 이동 로직
      }
  });
  ```

## 3. 종합 의견 및 구현 계획

### 3.1 우선순위별 구현 계획

#### 높은 우선순위 (즉시 수정)

1. **N+1 쿼리 문제 해결** (ERD Report)
2. **오프라인 환경 지원** (Mermaid.js 로컬화)
3. **동적 필터 옵션 생성** (CallChain Report)

#### 중간 우선순위 (1차 개선)

1. **GROUP_CONCAT 성능 개선** (CallChain Report)
2. **Mermaid 문법 수정** (ERD Report)
3. **관계 유형별 상세 통계** (CallChain Report)

#### 낮은 우선순위 (2차 개선)

1. **서버 사이드 필터링** (CallChain Report)
2. **패닝 기능 추가** (ERD Report)
3. **JSP 연계 경로 추가** (CallChain Report)

### 3.2 기술적 제약사항 고려

- **메타데이터베이스 스키마**: 실제 데이터 구조를 먼저 확인한 후 쿼리 수정
- **성능 vs 기능**: 초기에는 기본 기능에 집중하고, 성능 최적화는 단계적으로 진행
- **호환성**: 기존 코드와의 호환성을 유지하면서 점진적 개선

### 3.3 검토보고에 대한 감사

제시해주신 문제점들은 모두 타당하며, 실제 운영 환경에서 발생할 수 있는 중요한 이슈들입니다. 특히 N+1 쿼리 문제와 오프라인 환경 지원은 즉시 수정이 필요한 부분으로 인식하고 있습니다.

제안해주신 개선점들을 단계적으로 구현하여 더욱 견고하고 사용자 친화적인 리포트 생성 시스템을 만들어가겠습니다.
