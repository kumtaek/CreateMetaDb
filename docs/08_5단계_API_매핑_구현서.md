# 처리플로우 상세 - 5단계: API 매핑 정리 (단순화)

## 개요

**목적**: 프론트엔드에서 호출하는 API 정보를 정리하여 백엔드와 연결  
**핵심 기능**: 프론트엔드 API 호출 = 백엔드 API 진입점 (동일한 URL)  
**실행 함수**: `APIMappingLoadingEngine.execute_api_mapping()`  
**구현 상태**: 🔄 **개발 예정** (현재 미구현)  
**파일**: `api_mapping_loading.py` (5단계 메인 엔진)  
**단순화 설계**: API_URL 하나로 프론트엔드와 백엔드 연결 (중복 저장 불필요)  
**메모리 최적화**: 스트리밍 처리로 한 파일씩만 메모리에 로드하여 처리

## 처리 플로우 차트

```mermaid
flowchart TD
    A[5단계 시작] --> B[데이터베이스 연결]
    B --> C[4단계 결과 조회]
    C --> D[컨트롤러 메서드 분석]
    D --> E[API URL 생성]
    E --> F[API_URL 컴포넌트 생성]
    F --> G[components 테이블에 저장]
    G --> H[CALL_API 관계 생성]
    H --> I[통계 정보 출력]
    I --> J[5단계 완료]
    
    D --> D1[Spring Boot 분석]
    D --> D2[Servlet 분석]
    
    D1 --> D1a["@RequestMapping + @GetMapping\nAPI URL 조합"]
    D2 --> D2a["@WebServlet\nURL 패턴 분석"]
    
    style A fill:#e1f5fe
    style J fill:#c8e6c9
    style F fill:#fff3e0
    style G fill:#fff3e0
```

## 5단계 실행 흐름

### 1. 데이터베이스 연결 (`execute_api_mapping`)

```python
def execute_api_mapping(self) -> bool:
```

**기능**:
- 프로젝트 메타데이터베이스 연결
- 4단계에서 분석된 컨트롤러 메서드 조회
- API 매핑 정리 시작

**처리 과정**:
1. 데이터베이스 연결 확인
2. 4단계 결과 조회 (컨트롤러 메서드)
3. API 매핑 분석 시작

### 2. 컨트롤러 메서드 조회

```python
def get_controller_methods(self, project_id: int) -> List[ControllerMethod]:
```

**기능**:
- 4단계에서 분석된 컨트롤러 메서드 조회
- Spring Boot, Servlet 등 다양한 프레임워크 지원

**SQL 쿼리**:
```sql
SELECT c.component_id, c.component_name, c.class_name, c.method_name, c.layer
FROM components c
WHERE c.project_id = ? 
  AND c.layer IN ('CONTROLLER', 'REST_CONTROLLER', 'SERVLET')
  AND c.component_type = 'METHOD'
  AND c.del_yn = 'N'
```

### 3. API URL 생성

```python
def build_api_url(self, method: ControllerMethod) -> str:
```

**기능**:
- @RequestMapping과 @GetMapping 조합으로 API URL 생성
- Spring Boot, Servlet 등 다양한 프레임워크 지원

**처리 과정**:
1. @RequestMapping 경로 추출
2. @GetMapping/@PostMapping 경로 추출
3. API URL 조합 생성

**예시**:
```java
@RequestMapping("/api")
@GetMapping("/user-profile")
// 결과: /api/user-profile
```

### 4. API_URL 컴포넌트 생성

```python
def create_api_url_component(self, frontend_file_id: int, api_url: str, http_method: str) -> None:
```

**기능**:
- API_URL 타입의 컴포넌트 생성
- components 테이블에 저장

**컴포넌트 데이터**:
```python
component_data = {
    'project_id': self.project_id,
    'file_id': frontend_file_id,  # JSP/JSX 파일 ID
    'component_name': f'{api_url}:{http_method}',  # /api/user-profile:GET
    'component_type': 'API_URL',
    'parent_id': None,
    'layer': 'FRONTEND',
    'line_start': None,
    'line_end': None
}
```

**핵심 개념**:
- **프론트엔드 API 호출 = 백엔드 API 진입점**: 동일한 URL이므로 중복 저장 불필요
- **file_id로 프론트 파일 연결**: JSP/JSX 파일에서 호출하는 API임을 명시
- **component_name에 모든 정보 포함**: URL:HTTP_METHOD 형태로 고유 식별

### 5. 관계 생성

```python
def create_api_relationships(self, api_urls: List[APIUrl]) -> None:
```

**기능**:
- API_URL → METHOD 관계 생성
- relationships 테이블에 저장

**관계 데이터**:
```python
relationship_data = {
    'src_id': api_url.component_id,  # API_URL 컴포넌트 ID
    'dst_id': method.component_id,   # METHOD 컴포넌트 ID
    'rel_type': 'CALL_METHOD',       # 컴포넌트에서 메서드로의 호출
    'confidence': 1.0
}
```

## 데이터베이스 스키마

### components 테이블 (API_URL 타입)

| 컬럼명 | 데이터타입 | 설명 | 예시 |
|--------|------------|------|------|
| component_id | INTEGER | 컴포넌트 고유 ID | 1001 |
| project_id | INTEGER | 프로젝트 ID | 1 |
| file_id | INTEGER | JSP/JSX 파일 ID | 201 |
| component_name | VARCHAR(200) | API URL과 HTTP 메서드 조합 | /api/user-profile:GET |
| component_type | VARCHAR(20) | 컴포넌트 타입 | API_URL |
| layer | VARCHAR(30) | 계층 | FRONTEND |
| line_start | INTEGER | 시작 라인 | NULL |
| line_end | INTEGER | 종료 라인 | NULL |

**핵심 개념**:
- **file_id**: JSP/JSX 파일 ID (프론트엔드 파일과 연결)
- **component_name**: URL:HTTP_METHOD 형태로 고유 식별
- **중복 저장 불필요**: 프론트엔드 API 호출 = 백엔드 API 진입점

### relationships 테이블

| 컬럼명 | 데이터타입 | 설명 | 예시 |
|--------|------------|------|------|
| relationship_id | INTEGER | 관계 고유 ID | 2001 |
| src_id | INTEGER | 소스 ID (API_URL) | 1001 |
| dst_id | INTEGER | 대상 ID (METHOD) | 2001 |
| rel_type | VARCHAR(30) | 관계 타입 | CALL_METHOD |
| confidence | FLOAT | 신뢰도 | 1.0 |

## 주요 개선사항

### 1. 단순화된 구조
- **중복 제거**: 프론트엔드 API 호출 = 백엔드 API 진입점 (동일한 URL)
- **단일 컴포넌트**: API_URL 하나로 프론트엔드와 백엔드 연결
- **명확한 연결**: file_id로 프론트엔드 파일과 API_URL 연결

### 2. 3가지 핵심 관계
- **CALL_METHOD**: 컴포넌트 → METHOD (API_URL → METHOD, METHOD → METHOD)
- **CALL_QUERY**: METHOD → SQL (메서드 → 쿼리)
- **USE_TABLE**: SQL → TABLE (쿼리 → 테이블)

### 3. 직관적인 호출 체인
```
JSP 파일 → API_URL → METHOD → SQL → TABLE
```

## 설정 파일

### api_mapping_keyword.yaml

```yaml
# API 매핑 분석 키워드 설정
api_mapping:
  # HTTP 메서드 매핑
  http_methods:
    GET: "GET"
    POST: "POST"
    PUT: "PUT"
    DELETE: "DELETE"
    PATCH: "PATCH"
  
  # 기본 API 경로
  default_api_path: "/api"
  
  # 컨트롤러 계층 식별
  controller_layers:
    - "CONTROLLER"
    - "REST_CONTROLLER"
    - "SERVLET"
  
  # API URL 조합 규칙
  url_combination:
    request_mapping: "base_path"
    method_mapping: "method_path"
    separator: ""
```

## 통계 정보

### 처리 결과 통계

```python
def print_statistics(self, stats: Dict[str, Any]) -> None:
    """API 매핑 처리 통계 출력"""
    print(f"=== 5단계 API 매핑 정리 완료 ===")
    print(f"처리된 컨트롤러: {stats['total_controllers']}개")
    print(f"생성된 API_CALL: {stats['total_api_calls']}개")
    print(f"생성된 관계: {stats['total_relationships']}개")
    print(f"처리 시간: {stats['processing_time']:.2f}초")
```

## 에러 처리

### 예외 상황 처리

```python
def handle_error(self, error_message: str) -> None:
    """에러 처리 및 로깅"""
    logger.error(f"5단계 API 매핑 정리 실패: {error_message}")
    # 에러 발생 시 handle_error()로 exit
    handle_error(error_message)
```

### 주요 에러 상황
1. **데이터베이스 연결 실패**: 연결 정보 확인
2. **4단계 결과 없음**: 4단계 먼저 실행 필요
3. **API URL 생성 실패**: 컨트롤러 어노테이션 확인
4. **컴포넌트 생성 실패**: 데이터베이스 제약조건 확인

## 성능 최적화

### 메모리 최적화
- **스트리밍 처리**: 한 번에 하나의 컨트롤러만 메모리에 로드
- **배치 처리**: API_CALL 컴포넌트를 배치로 생성
- **캐시 활용**: 4단계 결과를 캐시하여 재사용

### 처리 속도 최적화
- **인덱스 활용**: components 테이블의 인덱스 활용
- **병렬 처리**: 여러 컨트롤러를 병렬로 처리
- **SQL 최적화**: 효율적인 쿼리 사용

## 검증 방법

### 1. API_CALL 컴포넌트 검증
```sql
-- API_CALL 컴포넌트 생성 확인
SELECT component_name, api_url, call_method, class_name, method_name
FROM components
WHERE component_type = 'API_CALL'
  AND project_id = 1;
```

### 2. 관계 생성 검증
```sql
-- CALL_API 관계 생성 확인
SELECT r.rel_type, c1.component_name as api_call, c2.component_name as method
FROM relationships r
JOIN components c1 ON r.src_id = c1.component_id
JOIN components c2 ON r.dst_id = c2.component_id
WHERE r.rel_type = 'CALL_API';
```

### 3. 통계 검증
```sql
-- API 매핑 통계 확인
SELECT 
    COUNT(*) as total_api_calls,
    COUNT(DISTINCT class_name) as total_controllers,
    COUNT(DISTINCT api_url) as unique_api_urls
FROM components
WHERE component_type = 'API_CALL'
  AND project_id = 1;
```

## 관련 문서

- [메타데이터베이스 스키마 정의서 v3.0](../메타데이터베이스스키마정의서.md)
- [4단계 Java 소스코드 분석](../처리플로우_상세_4단계_Java소스코드분석및관계생성.md)
- [API 매핑 사례 분석](../API_매핑_사례_분석.md)

이 문서는 기존의 복잡한 API 진입점 분석을 단순화하여 효율적이고 명확한 API 매핑 정리 기능을 제공합니다.
