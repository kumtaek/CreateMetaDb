# MyBatis 동적 SQL 파서 보강 및 개선 방안 상세 보고서

**작성일**: 2025-09-13
**문서 목적**: 현행 MyBatis XML 파서의 동적 SQL 분석 로직의 한계점을 명확히 하고, 분석 정확도와 범위를 획기적으로 개선하기 위한 구체적인 기술 전략 및 실행 계획을 제시함.

---

## 1. 개요

현행 동적 SQL 파서는 `통합개발계획서`에 따라 정규식을 사용하여 `<if>`, `<choose>` 등의 동적 태그를 제거하고 내부 SQL 조각들을 단순 병합하는 방식으로 구현되어 있습니다. 이 방식은 기본적인 JOIN 관계 추출에는 일부 효과적이나, MyBatis가 제공하는 **문맥 기반의 지능형 기능들을 해석하지 못하여** 분석의 정확도에 명백한 한계를 가집니다.

본 보고서는 이러한 **'상태 비저장(Stateless)'** 방식의 파서를 **'상태 저장(Stateful) 및 문맥 인식(Context-aware)'** 파서로 고도화하는 것을 목표로 하며, 이를 위한 4가지 핵심 개선 방안과 상세 구현 방법을 제안합니다.

---

## 2. 현행 파서의 한계점 분석

MyBatis 메뉴얼 검토 결과, 현재 파서는 다음과 같은 핵심 기능들을 처리하지 못하고 있습니다.

| 기능 분류 | 대상 태그 | 문제점 | 분석에 미치는 영향 |
| :--- | :--- | :--- | :--- |
| **지능형 태그** | `<where>`, `<set>`, `<trim>` | 내부 SQL 내용에 따른 키워드(WHERE, SET) 자동 추가 및 불필요한 `AND`, `OR`, `,` 제거 로직 부재 | 유효하지 않은 SQL 구문 생성으로 인한 파싱 실패 및 관계 분석 오류 |
| **반복 구문** | `<foreach>` | `open`, `close`, `separator` 속성을 해석하지 못하고 내부 변수만 남김 | `IN (...)` 절을 사용하는 JOIN 조건이나 WHERE 절 완전 누락 |
| **변수 선언** | `<bind>` | 쿼리 내에서 OGNL 표현식으로 새 변수를 선언하는 기능을 전혀 인지하지 못함 | `LIKE` 절의 동적 패턴 등, 바인딩된 변수를 사용하는 구문 분석 실패 |
| **조건부 로직** | `<if>`, `<choose>`, `<when>` | 모든 `test` 조건을 '참'으로 간주하고 모든 SQL 조각을 병합 | 실제로는 동시에 존재할 수 없는 JOIN 관계(False-positive) 다수 생성 |

---

## 3. 개선 목표 및 핵심 전략: 문맥 인식 파싱 파이프라인 도입

- **개선 목표**: 단순 텍스트 치환 방식에서 벗어나, **동적 태그의 규칙과 문맥을 시뮬레이션**하여 실행 가능한 SQL 구문에 최대한 가까운 형태로 재구성한 후 분석을 수행.
- **핵심 전략**: **'문맥 인식 파싱 파이프라인'**을 도입하여 4단계 분석을 수행합니다.

    1.  **1단계 (DOM 파싱)**: `xml.etree.ElementTree` 등 Python 표준 라이브러리를 사용하여 XML을 텍스트가 아닌 DOM(Document Object Model) 트리로 해석합니다. 이를 통해 태그 간의 부모-자식 관계 및 속성을 정확히 파악합니다.

    2.  **2단계 (태그 시뮬레이션)**: DOM 트리를 재귀적으로 순회(traverse)하며 각 동적 태그 노드를 만날 때마다 해당 태그의 고유 규칙을 적용하여 SQL 조각을 조건부로 생성, 수정, 조합합니다. 이 과정에서 파싱 컨텍스트(예: `<bind>` 변수)를 유지하고 전달합니다.

    3.  **3단계 (SQL 재구성)**: 시뮬레이션 결과를 바탕으로 최종 분석 대상이 될 완전한 SQL 문자열을 완성합니다.

    4.  **4단계 (관계 분석)**: 최종 재구성된 SQL을 대상으로 기존의 정규식 기반 JOIN 패턴 분석을 수행하여 관계를 추출합니다.

---

## 4. 상세 개선 방안 및 구현 가이드

### 4.1. 지능형 태그 시뮬레이터 구현 (`<where>`, `<set>`, `<trim>`)

이 태그들은 내부 SQL 조각을 먼저 처리한 후, 그 결과에 따라 자신의 동작을 결정하는 후처리(Post-processing) 방식으로 구현해야 합니다.

- **`xml_keyword.yaml` 설정 추가 제안:**
  ```yaml
  # config/parser/xml_keyword.yaml
  intelligent_tags:
    where:
      prefix: "WHERE"
      prefix_overrides: ["AND ", "OR "]
    set:
      prefix: "SET"
      suffix_overrides: [","]
  ```

- **구현 가이드 (Python 의사코드):**
  ```python
  # parser/xml_parser.py 내부에 구현
  
  class MybatisParser:
      def __init__(self):
          # yaml 파일에서 intelligent_tags 설정 로드
          self.intelligent_tag_rules = self.config.get('intelligent_tags', {})

      def _process_node(self, node, context):
          """DOM 노드를 재귀적으로 처리하는 메인 핸들러"""
          if node.tag in self.intelligent_tag_rules:
              return self._simulate_intelligent_tag(node, context)
          # ... 다른 태그 처리 로직 ...
          else:
              # 일반 텍스트 노드나 SQL 구문은 그대로 반환
              return node.text or ""

      def _simulate_intelligent_tag(self, node, context):
          """<trim>, <where>, <set> 태그의 동작을 시뮬레이션"""
          
          # 1. 자식 노드들의 SQL 조각을 먼저 재귀적으로 처리하여 조합
          child_sql_parts = [self._process_node(child, context) for child in node]
          content = "".join(child_sql_parts).strip()

          if not content:
              return "" # 내용이 없으면 아무것도 반환하지 않음

          rules = self.intelligent_tag_rules.get(node.tag, {})
          
          # <trim> 태그의 속성을 직접 사용하거나, <where>/<set>의 규칙을 적용
          prefix_overrides = node.get('prefixOverrides', rules.get('prefix_overrides', [])
          suffix_overrides = node.get('suffixOverrides', rules.get('suffix_overrides', [])

          # 2. 불필요한 접두사/접미사 제거
          for override in prefix_overrides:
              if content.lower().startswith(override.lower()):
                  content = content[len(override):].lstrip()
                  break
          
          for override in suffix_overrides:
              if content.lower().endswith(override.lower()):
                  content = content[:-len(override)].rstrip()
                  break

          # 3. 최종 SQL 조각에 접두사/접미사 추가
          prefix = node.get('prefix', rules.get('prefix', ''))
          suffix = node.get('suffix', rules.get('suffix', ''))
          
          if content:
              return f" {prefix} {content} {suffix} "
          return ""
  ```

### 4.2. `<foreach>` 구문 재구성기 구현

`IN` 절과 같은 반복 구문을 분석하기 위해, 컬렉션을 순회하는 대신 **대표값(Sample Data)을 포함한 형태로 SQL을 재구성**합니다.

- **구현 가이드 (Python 의사코드):**
  ```python
  # parser/xml_parser.py 내 _process_node 메서드에 추가
  
  def _reconstruct_foreach_tag(self, node, context):
      """<foreach> 태그를 샘플 데이터 기반의 SQL로 재구성"""
      open_str = node.get('open', '')
      close_str = node.get('close', '')
      separator = node.get('separator', ',')
      item_variable = node.get('item')
      
      # 내부 템플릿 (예: #{item.id})
      template = node.text.strip()

      # 샘플 항목 2개로 재구성 (실제 변수 대신 플레이스홀더 사용)
      sample_item_1 = template.replace(f"#{{{item_variable}}}", "'sample_val_1'")
      sample_item_2 = template.replace(f"#{{{item_variable}}}", "'sample_val_2'")
      
      # 최종 SQL 조립
      content = f"{sample_item_1}{separator}{sample_item_2}"
      
      return f" {open_str}{content}{close_str} "
  ```

### 4.3. `<bind>` 변수 컨텍스트 관리자 구현

SQL 매퍼 하나를 파싱하는 동안 `bind_context` 딕셔너리를 유지하여, 선언된 변수를 후속 SQL 분석에 활용합니다.

- **구현 가이드 (Python 의사코드):**
  ```python
  # parser/xml_parser.py

  def parse_sql_mapper(self, xml_root):
      # 매퍼 단위로 컨텍스트 초기화
      bind_context = {} 
      
      # root부터 재귀적으로 노드 처리 시작
      return self._process_node(xml_root, bind_context)

  def _process_node(self, node, context):
      # ... 기존 핸들러 로직 ...
      if node.tag == 'bind':
          return self._process_bind_tag(node, context)
      # ...
      # 일반 텍스트 노드 처리 시, 컨텍스트에 있는 변수 치환
      text = node.text or ""
      for name, value in context.items():
          text = text.replace(f"#{{{name}}}", value)
      return text

  def _process_bind_tag(self, node, context):
      """<bind> 태그를 처리하여 컨텍스트에 변수를 저장"""
      name = node.get('name')
      # value는 OGNL 표현식이므로, 분석을 위해 대표적인 결과값(예: '%sample%')으로 치환
      value_placeholder = "'%sample_pattern%'" 
      context[name] = value_placeholder
      
      return "" # <bind> 태그 자체는 SQL을 생성하지 않음
  ```

### 4.4. (장기 과제) 조건부 SQL 경로 분석

모든 경우의 수를 생성하는 것은 비효율적이므로, **'조건부 관계'** 개념을 도입하여 메타데이터의 정확성을 높입니다.

- **개선 방향**:
    1.  **분석 단계**: 파서는 `<if test="...">`와 같은 조건부 블록을 만나면, 내부의 SQL 조각에서 추출된 JOIN 관계에 **'조건 정보'를 메타데이터로 추가**합니다.
    2.  **DB 저장 단계**: `relationships` 테이블에 `is_conditional` (Y/N), `condition_expression` (TEXT)와 같은 컬럼을 추가합니다.
    3.  **데이터 저장**: 조건부 블록에서 발견된 JOIN은 `is_conditional='Y'`로, `condition_expression`에는 `test` 속성의 값(예: `username != null`)을 저장합니다.
- **기대 효과**: "테이블 A와 B는 `username` 파라미터가 있을 때만 JOIN 관계를 맺는다" 와 같이 훨씬 정교하고 정확한 메타데이터를 구축할 수 있습니다. 이는 향후 애플리케이션의 데이터 흐름을 추적하거나 영향도를 분석할 때 결정적인 정보를 제공합니다.

---

## 5. 기대 효과 및 결론

- **정확도 향상**: 불필요한 `AND`, `,` 등이 제거되어 유효한 SQL 구문 분석 확률 증가, `IN` 절 JOIN 등 누락되었던 관계 다수 발견.
- **분석 범위 확대**: `<bind>` 변수, `<foreach>` 반복문 등 기존에 분석이 불가능했던 복잡한 동적 쿼리 패턴까지 분석 범위에 포함.
- **오류 감소**: 실제로는 발생할 수 없는 SQL 조합(상호 배타적 조건)을 분석에서 제외하여 '거짓된 관계(False-positive)' 생성을 최소화.
- **신뢰성 확보**: 분석 결과물인 메타데이터의 신뢰도가 크게 향상되어, 사용자가 이를 바탕으로 더 정확한 의사결정을 내릴 수 있음.

**결론적으로,** 제안된 개선안은 현행 파서를 한 단계 발전시켜, 소스코드를 단순한 텍스트가 아닌 **'실행 가능한 로직'**으로 이해하고 분석하는 기반을 마련할 것입니다. 이는 프로젝트 전체의 데이터 관계를 훨씬 더 정확하게 파악하는 데 결정적인 역할을 할 것입니다.
