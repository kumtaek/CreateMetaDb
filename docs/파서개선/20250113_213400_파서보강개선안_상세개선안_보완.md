 몇 가지 기술적 이슈와 모호한 점들이 있어서 정리해드릴게요:                                                                                                                                                                                                                         🔍 모호한 점들                                                                                                                                                                                                                                                                            1. 기존 구현과의 통합 문제                                                                                                                                                                                                                                                                - 현재 xml_parser.py에는 7단계 컨트롤타워 구현됨                                                                                             - 개선안은 4단계 DOM 파이프라인 제안                                                                                                         - ❓ 질문: 기존 7단계를 완전 대체할 건지, 아니면 통합할 건지?                                                                                                                                                                                                                             2. DOM 파싱 vs 현재 정규식 방식                                                                                                                                                                                                                                                           - 현재: BeautifulSoup + 정규식 기반                                                                                                          - 개선안: xml.etree.ElementTree DOM 방식                                                                                                     - ❓ 질문: 기존 파싱 로직을 완전히 교체할 건지?                                                                                                                                                                                                                                           3. 샘플 데이터 정책                                                                                                                                                                                                                                                                       # 개선안 예시                                                                                                                                sample_item_1 = template.replace(placeholder, "'sample_val_1'")                                                                              sample_item_2 = template.replace(placeholder, "'sample_val_2'")                                                                              - ❓ 질문: sample_val_1, sample_val_2 고정값 사용할 건지?                                                                                    - 더 지능적인 샘플 생성 필요한지? (예: 컬럼 타입별 적절한 값)                                                                                                                                                                                                                             ⚠️ 기술적 이슈들                                                                                                                                                                                                                                                                         1. 성능 우려사항                                                                                                                                                                                                                                                                          # DOM 트리 방식은 메모리 사용량 증가                                                                                                         xml_root = xml.etree.ElementTree.parse(file_path)                                                                                            - 대용량 XML 파일 처리 시 메모리 부족 가능성                                                                                                 - 해결방안: 스트리밍 파싱 또는 청크 단위 처리 필요                                                                                                                                                                                                                                        2. 컨텍스트 변수 치환 복잡성                                                                                                                                                                                                                                                              # OGNL 표현식 처리                                                                                                                           value_placeholder = "'%sample_pattern%'"                                                                                                     - MyBatis는 복잡한 OGNL 표현식 사용 (user.name, @util@getValue())                                                                            - ❓ 질문: OGNL 표현식 얼마나 정교하게 시뮬레이션할 건지?                                                                                                                                                                                                                                 3. 조건부 SQL 경로 폭발 문제                                                                                                                                                                                                                                                              <if test="name != null">AND name = #{name}</if>                                                                                              <if test="age != null">AND age = #{age}</if>                                                                                                 <if test="city != null">AND city = #{city}</if>                                                                                              - 조건 3개면 2³ = 8가지 경우의 수                                                                                                           - ❓ 질문: 모든 경우의 수 생성할 건지, 아니면 대표 케이스만?                                                                                                                                                                                                                              🛠️ 구체적 개발 제안                                                                                                                                                                                                                                                                      1단계: 기존 구조 유지하면서 점진적 개선                                                                                                                                                                                                                                                   # xml_parser.py 내 기존 7단계 유지 + DOM 파싱 추가                                                                                           def _analyze_join_relationships(self, sql_content: str, file_path: str, component_id: int):                                                      # 0. DOM 파싱 시도 (실패시 기존 방식으로 fallback)                                                                                           try:                                                                                                                                             dom_result = self._parse_with_dom(file_path)                                                                                                 if dom_result:                                                                                                                                   return self._analyze_dom_based_joins(dom_result, component_id)                                                                       except Exception as e:                                                                                                                           # 파싱 오류로 처리, 기존 방식으로 계속                                                                                                       pass                                                                                                                                                                                                                                                                                  # 기존 7단계 로직 실행                                                                                                                       return self._analyze_with_existing_pipeline(sql_content, file_path, component_id)                                                                                                                                                                                                     2단계: 설정 기반 규칙 추가                                                                                                                                                                                                                                                                - config/parser/mybatis_dom_rules.yaml 생성                                                                                                  - 기존 sql_keyword.yaml과 분리된 DOM 전용 규칙                                                                                                                                                                                                                                            3단계: 샘플 데이터 정책 정의                                                                                                                                                                                                                                                              - 컬럼 타입별 대표값 매핑                                                                                                                    - INTEGER → 1, 2, VARCHAR → 'sample1', 'sample2'                                                                                                           

# MyBatis 파서 개선안에 대한 답변 및 구체적 실행 계획

**문서 목적**: 제안된 MyBatis 파서 개선안의 모호한 점과 기술적 이슈에 대해 명확한 답변을 제공하고, 안정적인 개발을 위한 구체적인 단계별 실행 계획을 제시합니다.

---

## 1. 모호한 점들에 대한 답변

### 1.1. 기존 구현(7단계)과 개선안(4단계)의 통합 문제

**결론: 기존 7단계 구조를 유지하며, 4단계 DOM 파이프라인을 핵심 분석 엔진으로 점진적으로 통합하는 전략을 채택합니다.**

- **통합 방식**: 기존 `xml_parser.py`의 7단계 컨트롤 타워(`_analyze_join_relationships` 등)는 그대로 유지합니다. 개선안의 DOM 파싱 및 재구성 로직은 이 컨트롤 타워의 **초기 단계(0단계)**에 편입됩니다.
- **기대 효과**:
  - **안정성**: DOM 파싱에 실패하더라도 기존 정규식 기반 분석 로직으로 Fallback 할 수 있어, 분석이 중단되는 위험을 방지합니다.
  - **점진적 개발**: 새로운 DOM 파서가 모든 케이스를 처리하지 못하더라도, 처리 가능한 부분은 DOM으로 분석하고 나머지는 기존 방식으로 처리하여 점진적으로 개선 범위를 넓힐 수 있습니다.

### 1.2. DOM 파싱 vs 현재 정규식 방식

**결론: `xml.etree.ElementTree` 를 주력 파서로 사용하되, 기존 BeautifulSoup + 정규식 방식은 Fallback 옵션으로 유지합니다.**

- **전략**: 새로운 DOM 파싱 방식을 우선적으로 시도하고, 여기서 처리하지 못하는 예외적인 케이스나 파싱 오류 발생 시에만 기존 방식을 보조적으로 사용하거나 해당 구문을 건너뜁니다. 이는 제안해주신 `try-except`를 이용한 Fallback 구조와 정확히 일치하는 방향입니다.

### 1.3. 샘플 데이터 정책

**결론: 초기에는 고정값을 사용하고, 장기적으로는 지능형 샘플 생성을 목표로 합니다.**

- **1단계 (단기)**: `'sample_val_1'`, `'sample_val_2'` 와 같은 **고정된 문자열 값을 사용**합니다. 이는 구현이 간단하고, `IN` 절의 구문 자체를 복원하여 JOIN 관계를 찾는 초기 목표를 달성하는 데 효과적입니다.
- **2단계 (장기)**: 메타데이터(DB 스키마 정보)를 활용하여, 대상 컬럼의 데이터 타입(`INTEGER`, `VARCHAR` 등)을 조회하고, 해당 **타입에 맞는 샘플 데이터를 생성**하는 방식으로 고도화합니다. 예를 들어, `INTEGER` 타입 컬럼에는 `1, 2`를, `VARCHAR` 타입 컬럼에는 `'sample1', 'sample2'`를 사용하는 방식입니다.

---

## 2. 기술적 이슈에 대한 해결 방안

### 2.1. 성능 우려사항 (DOM 파서의 메모리 사용량)

**결론: 일반적인 파일은 표준 라이브러리로 처리하고, 대용량 파일에 대해서는 스트리밍 방식의 `iterparse`를 도입합니다.**

- **해결 방안**: 대부분의 XML 매퍼 파일은 크기가 크지 않아 `xml.etree.ElementTree`로도 충분합니다. 하지만 수십 MB가 넘는 매우 큰 XML 파일의 경우, 메모리 문제를 방지하기 위해 **스트리밍 파서인 `iterparse`** 사용을 고려합니다. `lxml` 라이브러리의 `iterparse`는 DOM 전체를 메모리에 올리지 않고 이벤트를 순차적으로 처리하므로 메모리 사용량이 매우 낮습니다.  --> lxml 보류. 개발 안함!!!
  
  ```python
  # lxml 라이브러리 필요: pip install lxml
  from lxml import etree
  
  def stream_parse_large_xml(file_path):
      # iterparse는 특정 태그가 시작되거나 끝날 때 이벤트를 발생시킴
      # 이를 이용해 필요한 부분만 메모리에 올려 처리 가능
      for event, element in etree.iterparse(file_path, events=('end',), tag='select'):
          # <select> 태그가 끝날 때마다 해당 element만 처리
          process_sql_statement(element)
          # 메모리에서 element를 정리하여 메모리 사용량을 낮춤
          element.clear()
          while element.getprevious() is not None:
              del element.getparent()[0]
  ```

### 2.2. 컨텍스트 변수 치환 복잡성 (OGNL)

**결론: OGNL 표현식 전체를 완벽하게 실행하는 것은 목표로 하지 않습니다. 단순 변수 참조와 기본적인 문자열 결합 수준을 1차 목표로 설정합니다.**

- **처리 범위**:
  - **1순위**: 단순 변수 참조 (`#{user.name}` → `'sample_string'`)
  - **2순위**: `_parameter` 객체 속성 접근 (`#{_parameter.userId}` → `'sample_id'`)
  - **3순위**: 기본적인 문자열 결합 (`'%' + name + '%'` → `'%sample_pattern%'`)
- **처리 불가**: 외부 Java 메소드 호출(`@util@getValue()`)과 같은 복잡한 OGNL 표현식은 현재 파서의 분석 범위를 벗어나는 것으로 명확히 정의하고, 해당 부분은 주석 처리하거나 플레이스홀더로만 남겨둡니다.

### 2.3. 조건부 SQL 경로 폭발 문제

**결론: 모든 경우의 수를 생성하는 대신, 각 `<if>` 블록을 독립적으로 평가하여 '조건부 관계'로 저장하는 전략을 사용합니다.**

- **해결 방안**: 여러 `<if>` 조건이 중첩되거나 나열될 때, 모든 조합(2^n)을 생성하는 것은 비효율적이고 불필요합니다. 대신, 앞선 보고서에서 제안하고 DB 스키마에 반영된 바와 같이, 각 조건부 블록에서 발견된 JOIN 관계를 **`relationships` 테이블에 `is_conditional='Y'` 및 `condition_expression` 컬럼에 조건식을 저장**하는 방식으로 처리합니다.
- **예시**:
  - `<if test="name != null">` 내부의 JOIN은 `is_conditional='Y'`, `condition_expression='name != null'`로 기록됩니다.
  - 이를 통해 "이 JOIN은 `name` 파라미터가 존재할 때만 유효하다"는 훨씬 더 정확하고 유용한 메타데이터를 구축할 수 있습니다.

---

## 3. 종합 개발 전략 및 단계별 실행 계획

제안해주신 내용을 바탕으로, 아래와 같이 2단계에 걸친 점진적 개발 계획을 수립합니다.

### **1단계: 기본 DOM 파서 통합 및 안정화**

1. **Fallback 구조 구현**:
   
   - `xml_parser.py`의 메인 분석 함수 내에 `try...except` 블록을 추가합니다.
   - `try` 블록에서 새로운 DOM 파서(`_parse_with_dom`)를 호출합니다.
   - `except` 블록이나 DOM 파서가 `None`을 반환할 경우, 기존 정규식 기반 분석 로직(`_analyze_with_existing_pipeline`)이 실행되도록 구현합니다.

2. **DOM 전용 설정 파일 분리**:
   
   - `config/parser/mybatis_dom_rules.yaml` 파일을 생성하여, `<where>`, `<set>`과 같은 DOM 파서 전용 규칙을 `sql_keyword.yaml`과 분리하여 관리합니다.

3. **핵심 태그 시뮬레이터 구현**:
   
   - `xml.etree.ElementTree`를 사용하여 `<where>`, `<set>`, `<trim>`, `<foreach>` 태그에 대한 시뮬레이션 로직을 1차적으로 구현합니다.
   - `<foreach>`의 샘플 데이터는 `'sample_val_1'`, `'sample_val_2'`와 같은 고정값을 사용합니다.

4. **단순 `<bind>` 컨텍스트 처리**:
   
   - 단일 SQL 구문 내에서 `<bind>`로 선언된 변수가 후속 구문에서 치환되도록 하는 기본 컨텍스트 관리 기능을 구현합니다.

### **2단계: 파서 고도화 및 분석 범위 확대**

1. **성능 최적화**:
   
   - 대용량 XML 파일 처리 시 성능 저하가 관측될 경우, `lxml.iterparse`를 이용한 스트리밍 파싱 로직을 도입합니다.

2. **조건부 관계 분석 구현**:
   
   - `<if>`, `<choose>` 태그를 분석하여, 그 안에서 발견되는 JOIN 관계를 `is_conditional='Y'` 플래그 및 `condition_expression`과 함께 저장하는 로직을 구현합니다.

3. **지능형 샘플 데이터 생성**:
   
   - DB 스키마 정보를 조회하여, `<foreach>` 구문 내 변수가 참조하는 컬럼의 데이터 타입을 확인하고, 해당 타입에 맞는 샘플 데이터(예: `INTEGER` -> `1, 2`)를 생성하는 기능을 추가합니다.

4. **OGNL 처리 범위 확대**:
   
   - 단순 변수 참조 외에, 자주 사용되는 OGNL 패턴(예: `_parameter` 사용, 간단한 문자열 연산)에 대한 처리 규칙을 점진적으로 추가합니다.
