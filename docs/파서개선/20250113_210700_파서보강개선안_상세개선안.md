# MyBatis 동적 SQL 파서 최종 개선안 상세 보고서

**문서 ID**: `20250113_210000_메타생성_정답지3_비교대사보고서_상세개선안`
**작성일**: 2025-09-13
**작성자**: Gemini
**문서 목적**: 현행 MyBatis XML 파서의 한계를 극복하고, 동적 SQL 분석 정확도를 혁신적으로 개선하기 위한 최종 상세 방안을 제시합니다. 본 문서는 소스 코드 예시, 설정 파일 구조, 명확한 에러 처리 지침을 포함하여 개발자가 즉시 구현에 참고할 수 있도록 작성되었습니다.

---

## 1. 개선 목표 및 핵심 전략

### 1.1. 목표
단순 정규식 기반의 '상태 비저장(Stateless)' 파싱 방식에서 탈피하여, MyBatis 동적 태그의 문맥과 규칙을 시뮬레이션하는 **'상태 저장(Stateful) 및 문맥 인식(Context-aware)' 파서**를 구현합니다. 이를 통해 실제 실행 가능한 SQL에 최대한 근접한 형태로 구문을 재구성하여 분석 정확도를 극대화합니다.

### 1.2. 핵심 전략: 문맥 인식 파싱 파이프라인
파싱 프로세스는 아래 4단계 파이프라인을 따릅니다.

1.  **[1단계] DOM 파싱**: `xml.etree.ElementTree`를 사용해 XML 파일을 DOM(Document Object Model) 트리로 변환합니다. 이를 통해 태그 간의 계층 구조와 속성을 명확히 인지합니다.
2.  **[2단계] 태그 시뮬레이션**: DOM 트리를 재귀적으로 순회하며, 각 동적 태그의 규칙을 적용하여 SQL 조각을 조건부로 생성, 수정, 조합합니다. 이 과정에서 파싱 컨텍스트(예: `<bind>` 변수)를 하위 노드로 전달하며 유지합니다.
3.  **[3단계] SQL 재구성**: 시뮬레이션 결과를 종합하여 최종 분석 대상 SQL 문자열을 완성합니다.
4.  **[4단계] 관계 분석**: 재구성된 최종 SQL을 대상으로 기존 JOIN 패턴 분석 로직을 적용하여 관계를 추출합니다.

---

## 2. 필수 개발 규칙 및 공통 구현 사항

본격적인 기능 개선에 앞서, 프로젝트 전반의 안정성과 유지보수성을 위해 아래 규칙을 반드시 준수해야 합니다.

### 2.1. 에러 처리 전략
파싱 과정의 안정성을 보장하기 위해 에러를 '파싱 오류'와 '시스템 오류'로 명확히 구분하여 처리합니다.

-   **파싱 오류 (Parsing Error)**: 특정 파일의 특정 구문 해석 실패 시, 해당 파일의 분석만 건너뛰고 전체 프로세스는 중단되지 않습니다.
    -   **처리**: `try...except` 블록으로 파싱 로직을 감싸고, 오류 발생 시 `has_error='Y'`, `error_message`를 상세히 기록 후 `None` 또는 빈 문자열을 반환하여 계속 진행합니다.
    -   **절대 금지**: `exit()` 호출 금지.

-   **시스템 오류 (System Exception)**: 설정 파일 누락, DB 연결 실패 등 프로세스 진행이 불가능한 모든 예외 상황입니다.
    -   **처리**: 전사적인 `handle_error()` 유틸리티 함수를 호출하여 심각한 오류임을 로깅하고, 즉시 `exit()`를 통해 프로세스를 중단시켜야 합니다.

```python
# 예시: parser/xml_parser.py
from util.error_handler import handle_error
from util.logger import logger

def parse_single_file(file_path):
    try:
        # ... 파일 읽기 및 기본 준비 ...
        xml_root = ...
        sql_mapper_parser = MybatisParser()
        reconstructed_sql = sql_mapper_parser.parse_sql_mapper(xml_root)
        return reconstructed_sql, None  # 성공 시 에러 메시지는 None
    except Exception as e:
        # 파싱 오류로 간주
        error_message = f"MyBatis XML 파싱 실패: {file_path}, 오류: {str(e)}"
        logger.error(error_message)
        # 이 파일에 대한 메타데이터 생성 시 has_error='Y' 와 error_message를 저장
        return None, error_message # 파싱 실패 시 None과 에러 메시지 반환
    
def main_process():
    try:
        # ... 전체 프로세스 실행 ...
        for file_path in files:
            reconstructed_sql, error_msg = parse_single_file(file_path)
            if error_msg:
                # DB에 에러 상태 저장 로직
                save_parsing_error_to_db(file_path, error_msg)
            if reconstructed_sql:
                # 메타데이터 추출 및 저장
                analyze_and_save(reconstructed_sql)

    except Exception as e:
        # 시스템 오류 (예: DB 접속 불가)
        handle_error(f"치명적 시스템 오류 발생: {e}") # 내부에서 exit() 호출
```

### 2.2. 하드코딩 지양 및 설정 기반 개발
파싱 로직에 사용되는 모든 키워드, 패턴, 규칙은 `config/parser/` 하위의 YAML 파일로 분리하여 관리합니다. 이를 통해 향후 유지보수성과 확장성을 확보합니다.

-   **경로 관리**: 경로 문자열을 직접 조합하지 말고, `os.path.join`과 같은 공통 유틸리티 함수를 사용하여 OS 독립적인 경로를 생성합니다.

```python
# 예시: util/config_loader.py
import yaml
import os

def load_parser_config(config_name):
    """
    config/parser 경로에서 특정 YAML 설정을 로드합니다.
    """
    # 하드코딩된 상대 경로 대신, 프로젝트 루트를 기준으로 동적 경로 생성
    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    config_path = os.path.join(project_root, 'config', 'parser', config_name)
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except FileNotFoundError:
        # 시스템 오류에 해당
        handle_error(f"파서 설정 파일을 찾을 수 없습니다: {config_path}")
```

---

## 3. 상세 기능 개선 방안 및 구현 가이드

### 3.1. 지능형 태그 시뮬레이터 (`<where>`, `<set>`, `<trim>`)
내부 SQL 조각을 먼저 처리한 후, 그 결과에 따라 동적으로 SQL 키워드를 추가/제거하는 기능을 구현합니다.

-   **설정 파일 (`config/parser/mybatis_rules.yaml`):**
    ```yaml
    # MyBatis 동적 태그 규칙 정의
    intelligent_tags:
      where:
        prefix: "WHERE"
        prefix_overrides: ["AND ", "OR "]
        suffix_overrides: []
      set:
        prefix: "SET"
        prefix_overrides: []
        suffix_overrides: [","]
    ```

-   **구현 가이드 (`parser/xml_parser.py`):**
    ```python
    # MybatisParser 클래스 내
    def __init__(self):
        # 설정 파일 로드
        self.rules = load_parser_config('mybatis_rules.yaml')
        self.intelligent_tag_rules = self.rules.get('intelligent_tags', {})

    def _process_node(self, node, context):
        """DOM 노드를 태그 종류에 따라 분기하여 처리"""
        tag_name = node.tag.lower()
        
        if tag_name in self.intelligent_tag_rules or tag_name == 'trim':
            return self._simulate_intelligent_tag(node, context)
        # ... 다른 태그 처리 로직 ...
        else:
            # 일반 텍스트 노드는 컨텍스트 변수 치환 후 반환
            return self._replace_context_vars(node.text or "", context)

    def _simulate_intelligent_tag(self, node, context):
        """<trim>, <where>, <set> 태그의 동작을 시뮬레이션"""
        tag_name = node.tag.lower()
        
        # 1. 자식 노드들의 SQL 조각을 재귀적으로 처리하여 조합
        child_sql_parts = [self._process_node(child, context) for child in node]
        content = "".join(child_sql_parts).strip()

        if not content:
            return ""

        # 2. 규칙 적용: <trim>은 속성에서, <where>/<set>은 설정 파일에서 가져옴
        rules = self.intelligent_tag_rules.get(tag_name, {})
        prefix = node.get('prefix', rules.get('prefix', ''))
        suffix = node.get('suffix', rules.get('suffix', ''))
        prefix_overrides = node.get('prefixOverrides', rules.get('prefix_overrides', [])).split('|')
        suffix_overrides = node.get('suffixOverrides', rules.get('suffix_overrides', [])).split('|')

        # 3. 불필요한 접두사/접미사 제거
        for override in prefix_overrides:
            if content.lower().startswith(override.strip().lower()):
                content = content[len(override):].lstrip()
                break
        
        for override in suffix_overrides:
            if content.lower().endswith(override.strip().lower()):
                content = content[:-len(override)].rstrip()
                break

        # 4. 최종 SQL 조각에 접두사/접미사 추가
        if content:
            return f" {prefix} {content} {suffix} "
        return ""
    ```

### 3.2. `<foreach>` 구문 재구성기
`IN (...)` 절과 같은 반복 구문을 분석하기 위해, 실제 데이터를 넣는 대신 **대표값(Sample Data) 2개를 포함한 형태로 SQL을 재구성**합니다.

-   **구현 가이드 (`parser/xml_parser.py` 내 `_process_node`에 분기 추가):**
    ```python
    # MybatisParser 클래스 내
    def _reconstruct_foreach_tag(self, node, context):
        """<foreach> 태그를 샘플 데이터 기반의 SQL로 재구성"""
        open_str = node.get('open', '')
        close_str = node.get('close', '')
        separator = node.get('separator', ', ')
        item_variable = node.get('item')
        
        # 내부 템플릿 (예: #{item.id})
        # 자식 노드가 있을 수 있으므로, text 뿐만 아니라 자식 노드 결과도 포함
        child_sql_parts = [self._process_node(child, context) for child in node]
        template = (node.text or "").strip() + "".join(child_sql_parts)

        if not item_variable or not template:
            return ""

        # 샘플 항목 2개로 재구성 (실제 변수 대신 플레이스홀더 사용)
        # #{item} 또는 #{item.property} 형태 모두 대응
        placeholder = f"#{{{item_variable}"
        sample_item_1 = template.replace(placeholder, "'sample_val_1'")
        sample_item_2 = template.replace(placeholder, "'sample_val_2'")
        
        # 최종 SQL 조립
        content = f"{sample_item_1}{separator}{sample_item_2}"
        
        return f" {open_str}{content}{close_str} "
    ```

### 3.3. `<bind>` 변수 컨텍스트 관리자
SQL 매퍼 단위로 `bind_context` 딕셔너리를 유지하여, 선언된 변수를 후속 SQL 분석에 활용합니다.

-   **구현 가이드 (`parser/xml_parser.py`):**
    ```python
    # MybatisParser 클래스
    def parse_sql_mapper(self, xml_root):
        """매퍼 파싱의 시작점. 컨텍스트를 초기화하고 재귀 호출 시작"""
        bind_context = {} 
        
        # <sql> 태그 조각들을 먼저 파싱하여 저장해두는 것이 효율적일 수 있음
        # ...
        
        # 각 <select>, <insert> 등 CRUD 태그를 순회하며 파싱
        reconstructed_sqls = {}
        for statement_node in xml_root.findall('.//select') + xml_root.findall('.//insert') + ...:
            statement_id = statement_node.get('id')
            reconstructed_sqls[statement_id] = self._process_node(statement_node, bind_context.copy()) # 각 구문은 독립 컨텍스트
        return reconstructed_sqls

    def _process_node(self, node, context):
        # ... 기존 핸들러 로직 ...
        if node.tag.lower() == 'bind':
            self._process_bind_tag(node, context)
            return "" # <bind> 태그 자체는 SQL을 생성하지 않음
        # ...
    
    def _process_bind_tag(self, node, context):
        """<bind> 태그를 처리하여 컨텍스트에 변수를 저장"""
        name = node.get('name')
        # value는 OGNL 표현식이므로, 분석을 위해 대표적인 결과값(예: '%sample%')으로 치환
        value_placeholder = "'%sample_pattern%'" 
        if name:
            context[name] = value_placeholder
    
    def _replace_context_vars(self, text, context):
        """주어진 텍스트에서 컨텍스트 변수들을 치환"""
        for name, value in context.items():
            text = text.replace(f"#{{{name}}}", value)
        return text
    ```

### 3.4. 조건부 SQL 경로 분석 (장기 과제)
모든 경우의 수를 생성하는 대신, **'조건부 관계'** 개념을 도입하여 메타데이터의 정확성을 높입니다.

-   **DB 스키마 변경 제안**:
    -   `relationships` 테이블에 `is_conditional` (CHAR(1), Default 'N'), `condition_expression` (VARCHAR(1024)) 컬럼 추가.

-   **개선 방향**:
    1.  **파서 로직**: `<if test="...">` 블록 내에서 JOIN 관계가 발견되면, 해당 관계 정보에 `is_conditional='Y'` 플래그와 `test` 속성값(`username != null`)을 함께 저장합니다.
    2.  **DB 저장 로직**: 메타데이터 저장 시, 이 플래그와 조건부 표현식을 새로운 컬럼에 함께 기록합니다.
-   **기대 효과**: "테이블 A와 B는 `username` 파라미터가 있을 때만 JOIN 관계를 맺는다" 와 같이 훨씬 정교하고 정확한 메타데이터를 구축할 수 있습니다. 이는 향후 애플리케이션의 데이터 흐름 추적이나 영향도 분석 시 결정적인 정보를 제공합니다.

---

## 4. 결론 및 기대 효과

-   **정확도 향상**: 유효한 SQL 구문 분석 확률이 증가하고, `IN` 절 JOIN 등 누락되었던 관계를 다수 발견할 수 있습니다.
-   **분석 범위 확대**: `<bind>`, `<foreach>` 등 기존에 분석이 불가능했던 복잡한 동적 쿼리 패턴까지 분석 범위에 포함됩니다.
-   **오탐 감소**: 실제로는 발생할 수 없는 SQL 조합(상호 배타적 조건)을 분석에서 제외하여 '거짓된 관계(False-positive)' 생성을 최소화합니다.
-   **유지보수성 증대**: 규칙과 로직이 분리되어, 새로운 동적 SQL 패턴 추가 시 코드 변경을 최소화할 수 있습니다.

본 개선안을 통해, 소스 코드를 단순 텍스트가 아닌 **'실행 가능한 로직'**으로 이해하고 분석하는 고도화된 파서의 기반을 마련할 수 있으며, 이는 프로젝트 메타데이터의 신뢰도를 크게 향상시킬 것입니다.
