# 연관관계 도출 집중 개선안

## 📋 문서 개요

**목적**: SourceAnalyzer의 핵심 목표인 **연관관계 도출**에 집중한 개선 방안 제시  
**기존 문제**: 복잡한 파서 구현에 치중하여 연관관계 연결고리 도출이 부족  
**새로운 접근**: 파싱 정확도보다는 **연결고리 추적**에 집중  

## 🎯 핵심 목표

```
프론트파일(JSP/JSX/Vue) → API_URL → CLASS/METHOD → XML → QUERY → TABLE → Column
```

이 **완전한 연결고리**를 정확하고 신뢰할 수 있게 도출하는 것이 최우선 목표입니다.

## 🔍 SampleSrc 기술 스택 분석 결과

### 현재 지원 기술 요소

#### 1. **Java 파일 (91개)**
- **Spring Boot Controllers**: `JpaUserController`, `MicroserviceController` 등
- **JPA Entities**: `User`, `Order`, `Product` 등 (`@Entity`, `@Table` 어노테이션)
- **JPA Repositories**: `UserRepository`, `OrderRepository` 등 (Spring Data JPA)
- **Services**: `JpaUserService`, `UserService` 등 (비즈니스 로직)
- **MyBatis Mappers**: `UserMapper.java` 등 (인터페이스)

#### 2. **XML 파일 (20개)**
- **MyBatis Mappers**: `UserMapper.xml`, `ProductMapper.xml` 등
- **JPA 설정**: `persistence.xml`
- **동적 SQL**: `<if>`, `<choose>`, `<foreach>` 태그 포함
- **Include 태그**: `<sql>`, `<include>` 패턴

#### 3. **프론트엔드 파일 (23개)**
- **JSP**: `user/list.jsp`, `product/searchResult.jsp` 등 (전통적 웹)
- **Vue.js**: `JpaUserManagement.vue`, `UserManagement.vue` 등
- **React/JSX**: `ModernReactComponent.jsx`, `UserSearchDashboard.jsx` 등
- **TypeScript**: `TypeScriptUserManagement.tsx` 등

#### 4. **JPA 관련 파일들**
- **Entity 클래스**: `@Entity`, `@Table`, `@Column` 어노테이션
- **Repository 인터페이스**: Spring Data JPA 메서드 쿼리
- **Controller**: REST API 엔드포인트 (`@RestController`, `@RequestMapping`)

## 🚨 현재 시스템의 핵심 문제점

### 1. **API_URL → METHOD 매핑 로직 부재** (최우선)
```python
# util/database_utils.py:939-940
# 임시로 모든 METHOD 컴포넌트 중에서 첫 번째를 반환 (단순 구현)
# TODO: 실제 URL 패턴 매칭 로직 구현 필요
```

**문제**: JSP/Vue/React에서 호출하는 API와 실제 Java Controller 메소드 간 연결 불가  
**영향**: 프론트엔드 → 백엔드 연결고리가 끊어짐

### 2. **Java → XML 연결고리 부재**
```python
# config/target_source_config.yaml에서 경로 매핑만 정의
# 실제 Java 메소드에서 XML 파일로의 연결 로직 부재
```

**문제**: MyBatis Mapper 인터페이스와 XML 파일 간 매핑 추적 불가  
**영향**: Java → XML → SQL 연결고리가 끊어짐

### 3. **JPA Entity → TABLE 매핑 부재**
**문제**: JPA Entity의 `@Table` 어노테이션과 실제 데이터베이스 테이블 연결 불가  
**영향**: Entity → TABLE → Column 연결고리가 끊어짐

### 4. **프론트엔드 API 호출 패턴 분석 부족**
**문제**: Vue/React의 axios 호출, JSP의 AJAX 호출 패턴 분석 부족  
**영향**: 프론트엔드 → API_URL 연결고리 불완전

### 5. **연관관계 도출 정확도 부족**
**문제**: 추론(inferred) 컴포넌트에 의존하여 실제 연결 관계 파악 어려움  
**영향**: 전체 연결고리의 신뢰도 하락

## 🎯 우선순위별 개선 방안

### **1순위: API_URL → METHOD 매핑 강화**

#### 1.1 Spring Controller 어노테이션 분석 로직 구현
```python
class SpringControllerAnalyzer:
    def analyze_controller_methods(self, java_file: str) -> List[Dict[str, Any]]:
        """
        Spring Controller의 @RequestMapping, @GetMapping 등 어노테이션 분석
        """
        # @RestController, @Controller 클래스 찾기
        # @RequestMapping, @GetMapping, @PostMapping 메소드 찾기
        # URL 패턴과 HTTP 메소드 매핑
        pass
    
    def extract_api_mappings(self, controller_content: str) -> List[Dict[str, Any]]:
        """
        Controller에서 API 매핑 정보 추출
        """
        # 정규식으로 어노테이션 파싱
        # 클래스 레벨 @RequestMapping + 메소드 레벨 @GetMapping 조합
        pass
```

#### 1.2 URL 패턴 정규화 및 매칭 알고리즘
```python
class URLPatternMatcher:
    def normalize_url_pattern(self, url: str) -> str:
        """
        URL 패턴 정규화 (/api/users/{id} -> /api/users/*)
        """
        pass
    
    def match_api_to_method(self, api_url: str, http_method: str, 
                           controller_methods: List[Dict]) -> Optional[int]:
        """
        API URL과 HTTP 메소드로 매칭되는 Controller 메소드 찾기
        """
        pass
```

### **2순위: Java → XML 연결고리 구현**

#### 2.1 MyBatis Mapper 인터페이스 분석
```python
class MyBatisMapperAnalyzer:
    def analyze_mapper_interface(self, java_file: str) -> List[Dict[str, Any]]:
        """
        MyBatis Mapper 인터페이스의 메소드와 XML SQL ID 매핑
        """
        # @Mapper 어노테이션 클래스 찾기
        # 인터페이스 메소드명과 XML SQL ID 매핑
        pass
    
    def find_matching_xml_file(self, mapper_interface: str) -> Optional[str]:
        """
        Mapper 인터페이스에 대응하는 XML 파일 찾기
        """
        # 경로 매핑 설정 활용
        # 파일명 매칭 (UserMapper.java -> UserMapper.xml)
        pass
```

#### 2.2 Java 메소드 → XML SQL ID 연결
```python
class JavaXmlConnector:
    def connect_java_to_xml(self, java_method: str, xml_file: str) -> bool:
        """
        Java 메소드명과 XML SQL ID 연결 관계 생성
        """
        # Java: getUserById() -> XML: <select id="getUserById">
        # 관계 테이블에 CALL_QUERY_M2S 관계 저장
        pass
```

### **3순위: JPA Entity → TABLE 매핑 구현**

#### 3.1 JPA Entity 어노테이션 분석
```python
class JPAEntityAnalyzer:
    def analyze_entity_annotations(self, java_file: str) -> List[Dict[str, Any]]:
        """
        JPA Entity의 @Table, @Column 어노테이션 분석
        """
        # @Entity 클래스 찾기
        # @Table(name="USERS") -> TABLE: USERS
        # @Column(name="USER_ID") -> COLUMN: USER_ID
        pass
    
    def extract_table_mappings(self, entity_content: str) -> Dict[str, str]:
        """
        Entity 클래스에서 테이블/컬럼 매핑 정보 추출
        """
        pass
```

#### 3.2 JPA Repository → TABLE 연결
```python
class JPARepositoryConnector:
    def connect_repository_to_table(self, repository: str, entity: str) -> bool:
        """
        JPA Repository와 Entity, TABLE 간 연결 관계 생성
        """
        # UserRepository -> User Entity -> USERS TABLE
        # 관계 테이블에 USE_TABLE_S2D 관계 저장
        pass
```

### **4순위: 프론트엔드 API 호출 패턴 강화**

#### 4.1 Vue.js API 호출 분석
```python
class VueApiAnalyzer:
    def analyze_vue_api_calls(self, vue_file: str) -> List[Dict[str, Any]]:
        """
        Vue 컴포넌트의 axios API 호출 패턴 분석
        """
        # axios.get('/api/jpa/users') 패턴 찾기
        # API URL과 HTTP 메소드 추출
        pass
```

#### 4.2 React/JSX API 호출 분석
```python
class ReactApiAnalyzer:
    def analyze_react_api_calls(self, jsx_file: str) -> List[Dict[str, Any]]:
        """
        React 컴포넌트의 fetch/axios API 호출 패턴 분석
        """
        # fetch('/api/v2/users') 패턴 찾기
        # API URL과 HTTP 메소드 추출
        pass
```

#### 4.3 TypeScript API 호출 분석
```python
class TypeScriptApiAnalyzer:
    def analyze_typescript_api_calls(self, tsx_file: str) -> List[Dict[str, Any]]:
        """
        TypeScript 컴포넌트의 API 호출 패턴 분석
        """
        # 타입 안전성을 갖춘 API 호출 패턴 분석
        pass
```

### **5순위: 체인 연결 검증 시스템**

#### 5.1 연결고리 무결성 검증
```python
class ChainIntegrityValidator:
    def validate_chain_integrity(self, project_id: int) -> Dict[str, Any]:
        """
        전체 연결고리의 무결성 검증
        """
        # JSP → API_URL → METHOD → XML → QUERY → TABLE → Column
        # 각 단계별 연결 상태 확인
        # 끊어진 연결고리 감지 및 리포트
        pass
    
    def detect_broken_chains(self, project_id: int) -> List[Dict[str, Any]]:
        """
        끊어진 연결고리 감지
        """
        pass
```

#### 5.2 연결 신뢰도 점수 시스템
```python
class ConnectionReliabilityScorer:
    def calculate_connection_score(self, connection_type: str, 
                                 connection_data: Dict) -> float:
        """
        연결 관계의 신뢰도 점수 계산 (0.0 ~ 1.0)
        """
        # 직접 매핑: 1.0
        # 패턴 매칭: 0.8
        # 추론: 0.5
        pass
```

## 🔧 구현 세부 방안

### 1. **새로운 분석기 클래스 구조**

```python
# parser/relationship_analyzer.py
class RelationshipAnalyzer:
    """연관관계 도출 전용 분석기"""
    
    def __init__(self, project_name: str):
        self.project_name = project_name
        self.spring_analyzer = SpringControllerAnalyzer()
        self.mybatis_analyzer = MyBatisMapperAnalyzer()
        self.jpa_analyzer = JPAEntityAnalyzer()
        self.vue_analyzer = VueApiAnalyzer()
        self.react_analyzer = ReactApiAnalyzer()
        self.validator = ChainIntegrityValidator()
    
    def analyze_project_relationships(self) -> Dict[str, Any]:
        """
        프로젝트 전체의 연관관계 분석
        """
        pass
```

### 2. **설정 파일 확장**

```yaml
# config/parser/relationship_patterns.yaml
relationship_patterns:
  # Spring Controller 패턴
  spring_controller:
    class_annotations: ["@RestController", "@Controller"]
    method_annotations: ["@RequestMapping", "@GetMapping", "@PostMapping", "@PutMapping", "@DeleteMapping"]
    
  # JPA Entity 패턴
  jpa_entity:
    class_annotations: ["@Entity"]
    field_annotations: ["@Table", "@Column", "@Id", "@GeneratedValue"]
    
  # MyBatis Mapper 패턴
  mybatis_mapper:
    class_annotations: ["@Mapper"]
    interface_patterns: ["*Mapper.java"]
    
  # 프론트엔드 API 호출 패턴
  frontend_api:
    vue_patterns: ["axios.get", "axios.post", "axios.put", "axios.delete"]
    react_patterns: ["fetch(", "axios.get", "axios.post"]
    jsp_patterns: ["$.ajax", "$.get", "$.post"]
```

### 3. **데이터베이스 스키마 확장**

```sql
-- 연관관계 매핑 테이블 추가
CREATE TABLE relationship_mappings (
    mapping_id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    source_type VARCHAR(50) NOT NULL,  -- 'API_URL', 'METHOD', 'ENTITY'
    source_id INTEGER NOT NULL,
    target_type VARCHAR(50) NOT NULL,  -- 'METHOD', 'XML', 'TABLE'
    target_id INTEGER NOT NULL,
    mapping_type VARCHAR(50) NOT NULL, -- 'API_TO_METHOD', 'METHOD_TO_XML', 'ENTITY_TO_TABLE'
    confidence_score REAL DEFAULT 1.0, -- 연결 신뢰도 (0.0 ~ 1.0)
    mapping_data TEXT,                 -- 매핑 상세 정보 (JSON)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    del_yn CHAR(1) DEFAULT 'N',
    FOREIGN KEY (project_id) REFERENCES projects(project_id)
);

-- 연결고리 체인 테이블
CREATE TABLE connection_chains (
    chain_id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    chain_type VARCHAR(50) NOT NULL,   -- 'FRONTEND_TO_DB', 'API_TO_TABLE'
    chain_path TEXT NOT NULL,          -- 연결 경로 (JSON)
    chain_score REAL DEFAULT 0.0,     -- 전체 체인 신뢰도
    is_complete BOOLEAN DEFAULT FALSE, -- 완전한 체인 여부
    broken_points TEXT,                -- 끊어진 지점들 (JSON)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    del_yn CHAR(1) DEFAULT 'N',
    FOREIGN KEY (project_id) REFERENCES projects(project_id)
);
```

### 4. **리포트 생성기 확장**

```python
# reports/relationship_report_generator.py
class RelationshipReportGenerator:
    """연관관계 도출 리포트 생성기"""
    
    def generate_chain_report(self, project_id: int) -> str:
        """
        연결고리 분석 리포트 생성
        """
        pass
    
    def generate_broken_chain_report(self, project_id: int) -> str:
        """
        끊어진 연결고리 리포트 생성
        """
        pass
    
    def generate_confidence_report(self, project_id: int) -> str:
        """
        연결 신뢰도 리포트 생성
        """
        pass
```

## 📊 기대 효과

### 1. **연결고리 완성도 향상**
- **현재**: 추론에 의존한 불완전한 연결
- **개선 후**: 직접 매핑 기반의 정확한 연결

### 2. **연관관계 신뢰도 향상**
- **현재**: 연결 상태 불명확
- **개선 후**: 신뢰도 점수 기반의 명확한 연결

### 3. **개발자 생산성 향상**
- **현재**: 수동으로 연결 관계 파악 필요
- **개선 후**: 자동화된 연결고리 분석

### 4. **시스템 이해도 향상**
- **현재**: 부분적인 시스템 구조 파악
- **개선 후**: 전체 시스템의 완전한 연결고리 파악

## 🚀 구현 로드맵

### **Phase 1 (1-2주): API_URL → METHOD 매핑**
1. Spring Controller 어노테이션 분석기 구현
2. URL 패턴 매칭 알고리즘 구현
3. API_URL → METHOD 관계 생성 로직 구현

### **Phase 2 (2-3주): Java → XML 연결고리**
1. MyBatis Mapper 인터페이스 분석기 구현
2. Java 메소드 → XML SQL ID 매핑 로직 구현
3. 경로 매핑 설정 활용한 동적 연결

### **Phase 3 (2-3주): JPA Entity → TABLE 매핑**
1. JPA Entity 어노테이션 분석기 구현
2. Repository → Entity → TABLE 연결 로직 구현
3. JPA 쿼리 메소드 분석 및 매핑

### **Phase 4 (1-2주): 프론트엔드 API 호출 강화**
1. Vue/React/TypeScript API 호출 패턴 분석기 구현
2. 프론트엔드 → API_URL 연결 로직 강화

### **Phase 5 (1-2주): 체인 검증 시스템**
1. 연결고리 무결성 검증기 구현
2. 신뢰도 점수 시스템 구현
3. 끊어진 연결고리 감지 및 리포트

## 📝 결론

현재 SourceAnalyzer는 **파싱 기술**은 우수하지만, **연관관계 도출** 관점에서는 개선이 필요합니다. 

**핵심은 복잡한 파서보다는 단순하고 정확한 연결 매핑**에 집중하는 것입니다.

`프론트파일 → API_URL → CLASS/METHOD → XML → QUERY → TABLE → Column` 이 연결고리를 **정확하고 신뢰할 수 있게** 도출하는 것이 최우선 목표이며, 이를 통해 개발자들이 시스템의 전체 구조를 명확하게 파악할 수 있게 됩니다.

---

**작성일**: 2024년 12월 19일  
**작성자**: AI Assistant  
**문서 버전**: 1.0
