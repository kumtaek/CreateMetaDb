# 연관관계 도출 개선 - 상세 개발 계획서 v2

## 1. 문서 개요

**목표**: SourceAnalyzer의 핵심 목표인 **"누락 없는 연관관계 도출"**을 달성하기 위한 소스 코드 레벨의 상세 개발 계획을 수립한다.

**핵심 원칙**:
1.  **탐색 우선**: 정확성보다 **탐지율(Recall)**을 우선한다. 잘못된 연결(False Positive)이 일부 포함되더라도, 놓치는 연결(False Negative)이 없도록 설계한다.
2.  **단순한 규칙과 패턴 활용**: 복잡한 AST(추상 구문 트리) 파싱을 최소화하고, 정규식, 명명 컨벤션, 키워드 검색 등 가볍고 빠른 규칙 기반의 분석을 지향한다.
3.  **기존 구조 확장**: 새로운 기능을 위해 기존 코드를 전면 재작성하는 대신, `parser`, `util` 등 각 모듈의 역할을 존중하며 필요한 기능을 확장 및 추가한다.

---

## 2. 현재 소스 구조 분석 및 개선 방향

현재 소스 구조는 파일 타입별 파서(`parser/*.py`)가 각 컴포넌트를 개별적으로 분석하고 `database_utils.py`를 통해 DB에 저장하는 방식이다. 연관관계 도출을 위해, 각 파서에서 추출한 **"연결 포인트"** 정보를 새로운 중앙 관리 모듈로 보내고, 이 모듈이 관계를 설정하는 흐름으로 개선한다.

- **`main.py`**: 전체 분석 프로세스를 오케스트레이션. 마지막 단계에 '연관관계 설정' 단계를 추가해야 한다.
- **`parser/*.py`**: 각 파일 타입 분석 시, 연관관계의 단서가 되는 정보(API URL, Mapper ID 등)를 추출하는 로직을 추가해야 한다.
- **`util/database_utils.py`**: 컴포넌트 정보 외에, 컴포넌트 간의 '연관관계'를 저장하는 함수가 추가되어야 한다.
- **`database/create_table_script.sql`**: 연관관계를 저장할 새로운 테이블 스키마가 필요하다.

---

## 3. 단계별 상세 개발 계획

### **Phase 1: 기반 구축 (DB 스키마 및 중앙 관리 모듈)**

이 단계는 모든 연관관계를 저장하고 관리하기 위한 기본 틀을 마련한다.

#### **1.1. `database/create_table_script.sql` 수정**

-   **목표**: 컴포넌트 간의 모든 연결을 저장할 `relationships` 테이블을 추가한다.
-   **수정 내용**: 아래 SQL 구문을 `create_table_script.sql` 파일에 추가한다.

    ```sql
    -- 통합 관계 정보 (모든 관계를 통합 관리)
    CREATE TABLE IF NOT EXISTS relationships (
        relationship_id INTEGER PRIMARY KEY AUTOINCREMENT,  -- 관계 고유 식별자
        src_id INTEGER NOT NULL,                       -- 소스 컴포넌트 ID (components 테이블 참조)
        dst_id INTEGER NOT NULL,                       -- 대상 컴포넌트 ID (components 테이블 참조)
        rel_type VARCHAR(50) NOT NULL,                -- 관계 타입: 'CALLS_API', 'IMPLEMENTS_API', 'EXECUTES_QUERY', 'MAPS_TO_TABLE' 등
        line_number INTEGER,                           -- 관계가 시작된 소스 코드의 라인 번호
        created_at DATETIME DEFAULT (datetime('now', '+9 hours')),
        del_yn CHAR(1) DEFAULT 'N',
        FOREIGN KEY (src_id) REFERENCES components (id),
        FOREIGN KEY (dst_id) REFERENCES components (id),
        UNIQUE(src_id, dst_id, rel_type)
    );
    ```

#### **1.2. `util/database_utils.py` 수정**

-   **목표**: `relationships` 테이블에 연관관계 데이터를 CRUD하는 함수를 추가한다.
-   **추가 함수**:

    ```python
    # database_utils.py 내에 추가

    def insert_relationship(self, project_name, source_id, target_id, rel_type, line_number=None):
        """컴포넌트 간의 연관관계를 저장합니다."""
        if source_id is None or target_id is None:
            app_logger.warning(f"소스 또는 타겟 ID가 없어 관계를 저장할 수 없습니다: {rel_type}")
            return

        sql = """
            INSERT OR IGNORE INTO relationships (src_id, dst_id, rel_type, line_number)
            VALUES (?, ?, ?, ?)
        """
        # project_name은 현재 스키마에 없으므로 제거
        self.execute_update(sql, (source_id, target_id, rel_type, line_number))

    def find_component(self, project_id, component_name, component_type=None, file_id=None):
        """이름, 타입, 파일 ID로 컴포넌트 ID를 찾습니다."""
        query = "SELECT id FROM components WHERE project_id = ? AND name = ?"
        params = [project_id, component_name]
        if component_type:
            query += " AND type = ?"
            params.append(component_type)
        if file_id:
            query += " AND file_id = ?"
            params.append(file_id)
        query += " LIMIT 1"
        
        result = self.execute_query(query, tuple(params))
        return result[0]['id'] if result else None
    ```

### **Phase 2: API URL ↔ Controller Method 연결**

`SampleSrc`의 `JpaUserController.java`와 `UserManagement.vue` 사이의 연결고리를 완성한다.

#### **2.1. `parser/java_parser.py` 수정**

-   **목표**: Java 파일을 분석하며 Spring Controller의 `@RequestMapping`, `@GetMapping` 등 어노테이션을 파싱하여 `(URL + HTTP Method)`와 `(클래스 + 메소드)` 정보를 추출한다.
-   **수정 로직**: `JavaParser` 클래스 내에 `_analyze_spring_controller`와 같은 내부 메소드를 추가한다.

    ```python
    # java_parser.py 내 JavaParser 클래스에 추가
    import re

    def parse(self, file_path, content):
        # ... 기존 로직 ...
        # Spring Controller 분석 로직 추가
        if '@RestController' in content or '@Controller' in content:
            self._analyze_spring_controller(file_path, content)
        # ...

    def _analyze_spring_controller(self, file_path, content):
        class_level_mapping = re.search(r'@RequestMapping\["(.*?)"\]', content)
        base_url = class_level_mapping.group(1) if class_level_mapping else ''

        method_pattern = r'@(Get|Post|Put|Delete)Mapping\["(.*?)"\][\s\S]*?(?:public|private|protected)[\s\S]*?(\w+)\s*\([^)]*\)'
        matches = re.finditer(method_pattern, content)

        for match in matches:
            http_method, method_url, method_name = match.groups()
            full_url = (base_url + method_url).replace('//', '/')
            
            # 1. API_URL 컴포넌트 저장 (존재하지 않을 경우)
            # 이 단계에서는 API_URL 컴포넌트를 확정하지 않고, Frontend 분석 결과와 매칭하여 생성/연결
            
            # 2. METHOD 컴포넌트 ID 찾기 (이미 생성되어 있어야 함)
            # 클래스명은 파일명 등 다른 수단으로 미리 알아내야 함
            class_name = self._find_class_for_method(content, match.start())
            method_comp_name = f"{class_name}.{method_name}"
            method_comp_id = self.db.find_component(self.project_id, method_comp_name, 'METHOD')

            # 3. API_URL과 METHOD를 직접 연결하는 대신, API_URL 컴포넌트에 URL 정보를 임시 저장하거나 별도 관리
            # 예: self.api_mappings[full_url] = method_comp_id
    ```

#### **2.2. `parser/jsp_parser.py` (및 신규 `js_parser.py`) 수정**

-   **목표**: JSP, Javascript, Vue, JSX 파일 내에서 `axios`, `fetch` 등의 API 호출 구문을 찾아 URL 문자열을 추출하고, 이를 기반으로 `API_URL` 컴포넌트와 `CALLS_API` 관계를 생성한다.
-   **수정 로직**: `JspParser`에 정규식을 이용한 API URL 추출 로직을 추가한다.

    ```python
    # jsp_parser.py 내 JspParser 클래스에 추가
    def parse(self, file_path, content):
        # ...
        # API 호출 URL 추출 (axios, fetch, $.ajax 등 패턴 확장)
        api_patterns = [r'axios\.get\(["\'](.*?)["\']\)', r'fetch\(["\'](.*?)["\']\)', r'url\s*:\s*["\'](.*?)["\']']
        all_urls = []
        for pattern in api_patterns:
            all_urls.extend(re.findall(pattern, content))
        
        file_comp_id = self.db.find_component(self.project_id, file_path, 'FILE')

        for url in all_urls:
            if not url.startswith('http'):
                # 1. API_URL 컴포넌트 생성 또는 조회
                api_comp_id = self.db.find_or_insert_component(self.project_id, url, 'API_URL', file_id)

                # 2. FILE -> API_URL 관계 저장 (CALLS_API)
                self.db.insert_relationship(self.project_id, file_comp_id, api_comp_id, 'CALLS_API', line_number)
    ```

### **Phase 3: Java Mapper ↔ MyBatis XML 연결**

`SampleSrc`의 `UserMapper.java`와 `UserMapper.xml`을 연결한다.

#### **3.1. `parser/xml_parser.py` 수정**

-   **목표**: MyBatis XML의 `<mapper namespace="...">`를 Java FQCN(정규화된 클래스 이름)으로 인식하고, 각 `<select id="...">`를 `METHOD` 컴포넌트와 연결한다.
-   **수정 로직**: `XmlParser`의 `parse` 메소드에 namespace 기반 연결 로직을 추가한다.

    ```python
    # xml_parser.py 내 XmlParser 클래스에 추가
    def parse(self, file_path, content):
        # ...
        namespace_match = re.search(r'<mapper\s+namespace="([^"]+)">', content)
        if namespace_match:
            namespace = namespace_match.group(1) # 예: "com.example.mapper.UserMapper"
            
            # Java Mapper 인터페이스(CLASS) 컴포넌트 ID 찾기
            mapper_class_id = self.db.find_component(self.project_id, namespace, 'CLASS')

            query_ids = re.findall(r'<(?:select|insert|update|delete)\s+id="([^"]+)"', content)
            for query_id in query_ids:
                # 1. 쿼리 컴포넌트 ID 찾기 (이미 생성됨)
                query_comp_id = self.db.find_component(self.project_id, query_id, 'QUERY', self.current_file_id)
                
                # 2. Java 메소드 컴포넌트 ID 찾기 (이름 규칙: FQCN.methodName)
                method_comp_name = f"{namespace}.{query_id}"
                method_comp_id = self.db.find_component(self.project_id, method_comp_name, 'METHOD')

                # 3. METHOD -> QUERY 관계 저장 (EXECUTES_QUERY)
                if method_comp_id and query_comp_id:
                    self.db.insert_relationship(self.project_id, method_comp_id, query_comp_id, 'EXECUTES_QUERY', line_number)
    ```

### **Phase 4: JPA Entity ↔ DB Table 연결**

`SampleSrc`의 `jpa/entity/User.java`와 `USERS` 테이블을 연결한다.

#### **4.1. `parser/java_parser.py` 수정**

-   **목표**: `@Entity` 클래스에서 `@Table(name=...)`, `@Column(name=...)` 어노테이션을 분석하여 DB 테이블/컬럼과 매핑한다.
-   **수정 로직**: `JavaParser`에 `@Entity` 분석 로직을 추가한다.

    ```python
    # java_parser.py 내 JavaParser 클래스에 추가
    def parse(self, file_path, content):
        # ...
        if '@Entity' in content:
            self._analyze_jpa_entity(file_path, content)
        # ...

    def _analyze_jpa_entity(self, file_path, content):
        class_name = self._find_class_for_method(content, content.find('@Entity'))
        class_comp_id = self.db.find_component(self.project_id, class_name, 'CLASS')

        table_name_match = re.search(r'@Table\s*\(name\s*=\s*\"(.*?)\"\)', content)
        table_name = table_name_match.group(1) if table_name_match else class_name.upper()

        table_comp_id = self.db.find_component(self.project_id, table_name, 'TABLE')

        # CLASS -> TABLE 관계 저장 (MAPS_TO_TABLE)
        if class_comp_id and table_comp_id:
            self.db.insert_relationship(self.project_id, class_comp_id, table_comp_id, 'MAPS_TO_TABLE')
        
        # @Column 분석하여 필드와 컬럼 매핑 로직 추가
    ```

### **Phase 5: 통합 및 실행 흐름 변경**

#### **5.1. `main.py` 수정**

-   **목표**: 모든 개별 분석이 끝난 후, 수집된 연결 포인트들을 종합하여 최종 연관관계를 설정하고 리포트를 생성하는 단계를 추가한다.
-   **수정 로직**: `main` 함수에 `RelationshipBuilder` 와 `ChainReportGenerator` 호출 코드를 추가한다.

    ```python
    # main.py
    # ... (import 구문 추가)

    def main():
        # ... 1~5단계 분석 실행 ...
        
        logger.info("모든 컴포넌트 분석 완료. 최종 연관관계를 설정합니다.")
        # 신규: RelationshipBuilder 실행
        # 이 빌더는 각 파서가 수집한 연결 단서들을 종합하여 relationships 테이블을 완성한다.
        # 예: FILE(API호출) -> API_URL <- METHOD(API구현) 관계를 하나로 합침
        relationship_builder = RelationshipBuilder(project_name)
        relationship_builder.build_all_relationships()

        logger.info("연관관계 리포트를 생성합니다.")
        chain_reporter = ChainReportGenerator(project_name)
        chain_reporter.generate_report()
    ```

#### **5.2. `reports/chain_report_generator.py` 신규 생성**

-   **목표**: `relationships` 테이블을 재귀적으로 탐색하여 `프론트 → DB`까지 이어지는 모든 체인을 찾아내고, 그 결과를 HTML 또는 Markdown 파일로 생성한다.
-   **신규 파일 내용**:

    ```python
    # reports/chain_report_generator.py
    class ChainReportGenerator:
        def __init__(self, project_name):
            # ...

        def generate_report(self):
            # 1. DB에서 모든 'CALLS_API' 관계를 시작점으로 조회
            # 2. 각 시작점에서부터 DFS/BFS 탐색으로 모든 연결된 컴포넌트 추적
            # 3. 추적된 경로(체인)를 리스트업
            # 4. 완전한 체인(DB 테이블까지 도달)과 끊어진 체인을 구분하여 리포트 작성
            # 5. 결과를 HTML 파일로 저장
    ```

---

## 4. 결론

본 개발 계획서는 **"누락 없는 연관관계 도출"** 이라는 명확한 목표 아래, `SampleSrc` 프로젝트와 현재 분석기 소스 코드에 기반하여 구체적인 수정 방안을 제시했습니다. 각 단계는 독립적으로 개발 및 테스트가 가능하며, 최종적으로는 모든 연결고리를 탐색하고 시각화하는 통합된 시스템을 구축하게 될 것입니다.
