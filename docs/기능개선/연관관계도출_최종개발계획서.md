# 연관관계 도출 최종 개발 계획서

## 1. 최종 목표

- **유일 목표**: `relationships` 테이블에 `프론트엔드 → DB` 까지의 모든 연관관계를 **누락 없이** 저장한다.
- **제외 대상**: 리포트 생성, 신뢰도 점수, UI/시각화 등 부가적인 모든 내용은 본 계획에서 제외하고 오직 데이터 생성에만 집중한다.
- **전제 조건**: `database/create_table_script.sql` 파일은 수정하지 않으며, 기존 `relationships` 테이블 스키마를 그대로 활용한다.

---

## 2. 핵심 실행 계획: Parser-Builder 패턴 도입

복잡도를 낮추고 역할을 명확히 하기 위해, **파서(Parser)**와 **빌더(Builder)** 패턴을 도입한다.

1.  **파서 (Parser)**: 각 `parser/*.py`는 소스 파일을 분석하여 연관관계의 단서(raw data)만 추출하여 메모리(또는 임시 DB 테이블)에 적재한다. **이 단계에서는 `relationships` 테이블에 직접 저장하지 않는다.**
2.  **빌더 (Builder)**: 모든 파싱이 완료된 후, `RelationshipBuilder`가 실행된다. 빌더는 파서들이 수집한 단서들을 종합하여 `components` 테이블에서 실제 ID를 조회하고, `relationships` 테이블에 최종 관계를 INSERT 한다.

---

## 3. 소스 코드 레벨 상세 개발 계획

### **Phase 1: `relationships` 테이블 관리 기능 구현**

#### **1.1. `util/database_utils.py` 수정**

-   **목표**: `relationships` 테이블에 데이터를 저장하고 조회하는 기본 함수를 구현한다.
-   **수정 내용**: `DatabaseUtils` 클래스에 아래 함수를 추가/수정한다.

    ```python
    # util/database_utils.py

    def insert_relationship(self, src_id: int, dst_id: int, rel_type: str, line_number: int = None):
        """ relationships 테이블에 연관관계를 저장합니다. (중복 시 무시) """
        if src_id is None or dst_id is None:
            app_logger.warning(f"소스(src) 또는 타겟(dst) ID가 없어 관계 저장을 건너뜁니다: {rel_type}")
            return

        # 기존 relationships 테이블 스키마에 맞게 수정
        sql = """
            INSERT OR IGNORE INTO relationships (src_id, dst_id, rel_type, confidence, has_error, del_yn)
            VALUES (?, ?, ?, 1.0, 'N', 'N')
        """
        self.execute_update(sql, (src_id, dst_id, rel_type))

    def find_component_id(self, project_id: int, component_name: str, component_type: str = None, file_id: int = None) -> Optional[int]:
        """이름, 타입, 파일 ID로 컴포넌트 ID를 찾습니다."""
        query = "SELECT component_id FROM components WHERE project_id = ? AND component_name = ?"
        params = [project_id, component_name]
        if component_type:
            query += " AND component_type = ?"
            params.append(component_type)
        if file_id:
            query += " AND file_id = ?"
            params.append(file_id)
        query += " LIMIT 1"
        
        result = self.execute_query(query, tuple(params))
        return result[0]['component_id'] if result else None
    ```

### **Phase 2: 프론트엔드 → API URL 관계 도출**

-   **목표**: `*.jsp`, `*.jsx`, `*.vue`, `*.tsx` 파일에서 API 호출 URL을 추출하여 `FILE` 컴포넌트와 `API_URL` 컴포넌트 간의 `CALLS_API` 관계를 생성한다.

#### **2.1. `parser/jsp_parser.py` (및 기타 프론트엔드 파서) 수정**

-   **수정 내용**: `parse` 메소드에서 API 호출 패턴을 찾아 URL을 추출하고, **결과를 `RelationshipBuilder`가 사용할 수 있도록 리스트 형태로 반환**한다.

    ```python
    # parser/jsp_parser.py (예시)
    def parse(self, file_path, content):
        # ...
        api_calls = []
        api_patterns = [r'axios.get(["'](.*?)["'])', r'fetch(["'](.*?)["'])']
        for pattern in api_patterns:
            for match in re.finditer(pattern, content):
                url = match.group(1)
                line_number = content[:match.start()].count('\n') + 1
                if not url.startswith('http'):
                    api_calls.append({
                        'type': 'API_CALL',
                        'source_file': file_path,
                        'api_url': url,
                        'line': line_number
                    })
        return api_calls # 추출한 단서만 반환
    ```

### **Phase 3: API URL → Controller Method 관계 도출**

-   **목표**: Spring Controller 파일에서 `@RequestMapping` 등의 어노테이션을 분석하여 `API_URL`과 `METHOD`를 연결한다.

#### **3.1. `parser/java_parser.py` 수정**

-   **수정 내용**: `parse` 메소드에서 Controller를 식별하고, URL과 메소드명 정보를 추출하여 **결과를 리스트 형태로 반환**한다.

    ```python
    # parser/java_parser.py
    def parse(self, file_path, content):
        # ...
        extracted_data = []
        if '@RestController' in content or '@Controller' in content:
            class_name = self._find_class_for_method(content, content.find('@Controller'))
            base_url_match = re.search(r'@RequestMapping">(.*?)"', content)
            base_url = base_url_match.group(1) if base_url_match else ''

            method_pattern = r'@(Get|Post|Put|Delete)Mapping">(.*?)"\s*[\s\S]*?(\w+)\s*\([^)]*\)'
            for match in re.finditer(method_pattern, content):
                http_method, method_url, method_name = match.groups()
                full_url = (base_url + method_url).replace('//', '/')
                extracted_data.append({
                    'type': 'API_IMPLEMENTATION',
                    'api_url': full_url,
                    'class_name': class_name,
                    'method_name': method_name
                })
        # ... 다른 분석 결과와 함께 extracted_data 반환
        return extracted_data
    ```

### **Phase 4: Builder 구현 및 실행 흐름 통합**

-   **목표**: 각 파서가 생성한 단서들을 종합하여 `relationships` 테이블을 완성하는 `RelationshipBuilder`를 구현하고, `main.py`에서 호출한다.

#### **4.1. `relationship_builder.py` 신규 생성**

-   **신규 파일 내용**:

    ```python
    # relationship_builder.py
    from util.database_utils import DatabaseUtils

    class RelationshipBuilder:
        def __init__(self, project_name, project_id, all_extracted_data):
            self.project_name = project_name
            self.project_id = project_id
            self.db = DatabaseUtils(f'projects/{project_name}/metadata.db')
            self.data = all_extracted_data # 모든 파서의 결과 리스트

        def build_all_relationships(self):
            # 1. API 관련 관계 구축
            self._build_api_relationships()
            # 2. MyBatis 관련 관계 구축
            self._build_mybatis_relationships()
            # 3. JPA 관련 관계 구축
            self._build_jpa_relationships()
            # ... 등등

        def _build_api_relationships(self):
            api_calls = [d for d in self.data if d['type'] == 'API_CALL']
            api_impls = [d for d in self.data if d['type'] == 'API_IMPLEMENTATION']

            for call in api_calls:
                # FILE -> API_URL 관계
                file_id = self.db.find_component_id(self.project_id, call['source_file'], 'FILE')
                api_url_id = self.db.find_or_create_component(self.project_id, call['api_url'], 'API_URL', file_id)
                self.db.insert_relationship(file_id, api_url_id, 'CALLS_API', call['line'])

                # API_URL -> METHOD 관계
                for impl in api_impls:
                    if call['api_url'] == impl['api_url']:
                        method_name = f"{impl['class_name']}.{impl['method_name']}"
                        method_id = self.db.find_component_id(self.project_id, method_name, 'METHOD')
                        self.db.insert_relationship(api_url_id, method_id, 'IMPLEMENTS_API')
    ```

#### **4.2. `main.py` 수정**

-   **수정 내용**: 모든 파싱이 끝난 후, `RelationshipBuilder`를 호출한다.

    ```python
    # main.py
    from relationship_builder import RelationshipBuilder # 신규 임포트

    def main():
        # ... 모든 파일 분석 및 컴포넌트 저장 로직 ...
        # all_extracted_data = [ ... 모든 파서의 결과 취합 ... ]

        logger.info("모든 컴포넌트 분석 완료. 최종 연관관계를 설정합니다.")
        builder = RelationshipBuilder(project_name, project_id, all_extracted_data)
        builder.build_all_relationships()
        logger.info("연관관계 설정 완료.")
    ```

### **Phase 5: MyBatis 및 JPA 관계 도출 로직 추가**

-   **MyBatis**: `xml_parser.py`가 `<mapper namespace...>`와 `<select id...>` 정보를 추출하고, `RelationshipBuilder`가 이를 `METHOD` 컴포넌트와 `QUERY` 컴포넌트에 연결하여 `EXECUTES_QUERY` 관계를 생성한다.
-   **JPA**: `java_parser.py`가 `@Entity`, `@Table` 정보를 추출하고, `RelationshipBuilder`가 이를 `CLASS` 컴포넌트와 `TABLE` 컴포넌트에 연결하여 `MAPS_TO_TABLE` 관계를 생성한다.
-   **Query -> Table**: `xml_parser.py`와 `java_parser.py`(문자열 기반 쿼리)가 쿼리 내 `FROM`, `JOIN` 절을 분석하여 테이블명을 추출하고, `RelationshipBuilder`가 `QUERY` 컴포넌트와 `TABLE` 컴포넌트를 연결하여 `USES_TABLE` 관계를 생성한다.

---

## 4. 결론

본 최종 계획서는 **'관계 단서 추출(Parser)'**과 **'관계 설정(Builder)'**의 역할을 명확히 분리하여, 복잡도를 낮추고 오직 **`relationships` 테이블을 완성하는 최종 목표**에만 집중합니다. 이를 통해 기존 스키마를 변경하지 않으면서도, 누락 없는 연관관계 데이터베이스를 구축할 수 있습니다.
