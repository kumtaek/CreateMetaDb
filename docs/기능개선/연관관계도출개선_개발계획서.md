# 연관관계 도출 개선 - 상세 개발 계획서

## 1. 문서 개요

**목표**: SourceAnalyzer의 핵심 목표인 **"누락 없는 연관관계 도출"**을 달성하기 위한 소스 코드 레벨의 상세 개발 계획을 수립한다.

**핵심 원칙**:
1.  **탐색 우선**: 정확성보다 **탐지율(Recall)**을 우선한다. 잘못된 연결(False Positive)이 일부 포함되더라도, 놓치는 연결(False Negative)이 없도록 설계한다.
2.  **단순한 규칙과 패턴 활용**: 복잡한 AST(추상 구문 트리) 파싱을 최소화하고, 정규식, 명명 컨벤션, 키워드 검색 등 가볍고 빠른 규칙 기반의 분석을 지향한다.
3.  **기존 구조 확장**: 새로운 기능을 위해 기존 코드를 전면 재작성하는 대신, `parser`, `util` 등 각 모듈의 역할을 존중하며 필요한 기능을 확장 및 추가한다.

---

## 2. 현재 소스 구조 분석 및 개선 방향

현재 소스 구조는 파일 타입별 파서(`parser/*.py`)가 각 컴포넌트를 개별적으로 분석하고 `database_utils.py`를 통해 DB에 저장하는 방식이다. 연관관계 도출을 위해, 각 파서에서 추출한 **"연결 포인트"** 정보를 새로운 중앙 관리 모듈로 보내고, 이 모듈이 관계를 설정하는 흐름으로 개선한다.

- **`main.py`**: 전체 분석 프로세스를 오케스트레이션. 마지막 단계에 '연관관계 설정' 단계를 추가해야 한다.
- **`parser/*.py`**: 각 파일 타입 분석 시, 연관관계의 단서가 되는 정보(API URL, Mapper ID 등)를 추출하는 로직을 추가해야 한다.
- **`util/database_utils.py`**: 컴포넌트 정보 외에, 컴포넌트 간의 '연관관계'를 저장하는 함수가 추가되어야 한다.
- **`database/create_table_script.sql`**: 연관관계를 저장할 새로운 테이블 스키마가 필요하다.

---

## 3. 단계별 상세 개발 계획

### **Phase 1: 기반 구축 (DB 스키마 및 중앙 관리 모듈)**

이 단계는 모든 연관관계를 저장하고 관리하기 위한 기본 틀을 마련한다.

#### **1.1. `database/create_table_script.sql` 수정**

-   **목표**: 컴포넌트 간의 모든 연결을 저장할 `relationships` 테이블을 추가한다.
-   **수정 내용**: 아래 SQL 구문을 `create_table_script.sql` 파일에 추가한다.

    ```sql
    -- =================================================================
    -- 10. 컴포넌트 연관관계 테이블
    -- =================================================================
    CREATE TABLE IF NOT EXISTS relationships (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_name TEXT NOT NULL,
        source_id INTEGER NOT NULL,
        target_id INTEGER NOT NULL,
        type TEXT NOT NULL, -- 예: 'CALLS_API', 'IMPLEMENTS_API', 'EXECUTES_QUERY', 'MAPS_TO_TABLE'
        line_number INTEGER, -- 관계가 시작된 소스 코드의 라인 번호
        is_inferred INTEGER DEFAULT 0, -- 0: 직접/관례적, 1: 추론적
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (source_id) REFERENCES components (id),
        FOREIGN KEY (target_id) REFERENCES components (id)
    );
    CREATE INDEX IF NOT EXISTS idx_relationships_source ON relationships (source_id);
    CREATE INDEX IF NOT EXISTS idx_relationships_target ON relationships (target_id);
    ```

#### **1.2. `util/database_utils.py` 수정**

-   **목표**: `relationships` 테이블에 연관관계 데이터를 CRUD하는 함수를 추가한다.
-   **추가 함수**:

    ```python
    # database_utils.py 내에 추가

    def insert_relationship(self, project_name, source_id, target_id, rel_type, line_number=None, is_inferred=0):
        """컴포넌트 간의 연관관계를 저장합니다."""
        sql = """
            INSERT INTO relationships (project_name, source_id, target_id, type, line_number, is_inferred)
            VALUES (?, ?, ?, ?, ?, ?)
        """
        self.execute_sql(sql, (project_name, source_id, target_id, rel_type, line_number, is_inferred))

    def find_component_by_name_and_type(self, project_name, name, comp_type):
        """이름과 타입으로 컴포넌트 ID를 찾습니다."""
        sql = "SELECT id FROM components WHERE project_name = ? AND name = ? AND type = ?"
        result = self.fetch_one(sql, (project_name, name, comp_type))
        return result[0] if result else None

    # ... 기타 연관관계 조회/삭제 함수 ...
    ```

### **Phase 2: API URL ↔ Controller Method 연결**

가장 중요한 첫 번째 연결고리를 완성한다.

#### **2.1. `parser/java_parser.py` 수정**

-   **목표**: Java 파일을 분석하며 Spring Controller의 `@RequestMapping`, `@GetMapping` 등 어노테이션을 파싱하여 `(URL + HTTP Method)`와 `(클래스 + 메소드)` 정보를 추출한다.
-   **수정 로직**: `JavaParser` 클래스 내에 `_analyze_spring_controller`와 같은 내부 메소드를 추가한다.

    ```python
    # java_parser.py 내 JavaParser 클래스에 추가
    import re

    def parse(self, file_path, content):
        # ... 기존 로직 ...
        class_annotations, methods = self._parse_java_structure(content)

        # Spring Controller 분석 로직 추가
        if '@RestController' in class_annotations or '@Controller' in class_annotations:
            self._analyze_spring_controller(file_path, content, class_annotations, methods)

        # ...

    def _analyze_spring_controller(self, file_path, content, class_annotations, methods):
        base_url = ''
        class_level_mapping = re.search(r'@RequestMapping\(\s*value\s*=\s*"(.*?)"\s*\)', content)
        if class_level_mapping:
            base_url = class_level_mapping.group(1)

        for method in methods:
            method_name = method['name']
            method_content = method['content']
            
            # GetMapping, PostMapping 등 모든 HTTP 메소드 어노테이션에 대해 반복
            for http_method in ['Get', 'Post', 'Put', 'Delete', 'Request']:
                mapping_pattern = rf'@{http_method}Mapping\(\s*(?:value\s*=\s*)?"(.*?)"\s*\)'
                match = re.search(mapping_pattern, method_content)
                
                if match:
                    method_url = match.group(1)
                    full_url = (base_url + method_url).replace('//', '/')
                    
                    # 1. API_URL 컴포넌트 저장 (존재하지 않을 경우)
                    api_comp_id = self.db.find_or_insert_component(self.project_name, full_url, 'API_URL', file_path)
                    
                    # 2. METHOD 컴포넌트 ID 찾기
                    method_comp_id = self.db.find_component_by_name_and_type(self.project_name, f"{method['class_name']}.{method_name}", 'METHOD')

                    # 3. 연관관계 저장 (IMPLEMENTS_API)
                    if api_comp_id and method_comp_id:
                        self.db.insert_relationship(self.project_name, method_comp_id, api_comp_id, 'IMPLEMENTS_API', method['start_line'])
    ```

#### **2.2. `parser/jsp_parser.py` (및 신규 `js_parser.py`) 수정**

-   **목표**: JSP, Javascript 파일 내에서 `ajax`, `fetch`, `axios` 등의 API 호출 구문을 찾아 URL 문자열을 추출한다.
-   **수정 로직**: `JspParser`에 정규식을 이용한 API URL 추출 로직을 추가한다.

    ```python
    # jsp_parser.py 내 JspParser 클래스에 추가
    def parse(self, file_path, content):
        # ... 기존 로직 ...
        
        # API 호출 URL 추출
        # 예시: $.ajax({ url: "/api/users" ... })
        ajax_urls = re.findall(r'url\s*:\s*["\'](.*?)["\']', content)
        # 예시: fetch("/api/data")
        fetch_urls = re.findall(r'fetch\s*\(\s*["\'](.*?)["\']', content)
        
        all_urls = ajax_urls + fetch_urls
        
        # 1. JSP 파일 컴포넌트 ID 찾기
        jsp_comp_id = self.db.find_component_by_name_and_type(self.project_name, file_path.split('\\')[-1], 'JSP')

        for url in all_urls:
            if not url.startswith(('http', '//')):
                # 2. API_URL 컴포넌트 ID 찾기
                api_comp_id = self.db.find_component_by_name_and_type(self.project_name, url, 'API_URL')
                
                # 3. 연관관계 저장 (CALLS_API)
                if jsp_comp_id and api_comp_id:
                    # 라인 번호는 정규식으로 찾거나, 일단은 None으로 저장
                    self.db.insert_relationship(self.project_name, jsp_comp_id, api_comp_id, 'CALLS_API')
    ```

### **Phase 3: Java Mapper ↔ MyBatis XML 연결**

#### **3.1. `parser/xml_parser.py` 수정**

-   **목표**: MyBatis XML 파일을 파싱할 때, `<mapper namespace="...">` 값을 추출하여 Java Mapper 인터페이스와 연결할 준비를 한다.
-   **수정 로직**: `XmlParser`에서 `namespace`를 파싱하여 DB에 저장된 `CLASS` 타입 컴포넌트와 비교/연결한다.

    ```python
    # xml_parser.py 내XmlParser 클래스에 추가
    def parse(self, file_path, content):
        # ... 기존 로직 (쿼리, 테이블 등 추출) ...

        # Namespace 추출
        namespace_match = re.search(r'<mapper\s+namespace="([^"]+)">', content)
        if namespace_match:
            namespace = namespace_match.group(1) # 예: "com.example.mappers.UserMapper"
            
            # 1. XML 파일 컴포넌트 ID 찾기
            xml_comp_id = self.db.find_component_by_name_and_type(self.project_name, file_path.split('\\')[-1], 'XML')
            
            # 2. Java Mapper 인터페이스(CLASS) 컴포넌트 ID 찾기
            # namespace는 클래스의 FQCN(Fully Qualified Class Name)임
            mapper_class_id = self.db.find_component_by_name_and_type(self.project_name, namespace, 'CLASS')

            # 3. 연관관계 저장 (DEFINES_QUERIES_FOR)
            if xml_comp_id and mapper_class_id:
                self.db.insert_relationship(self.project_name, xml_comp_id, mapper_class_id, 'DEFINES_QUERIES_FOR')

            # 4. 각 쿼리 ID와 Java 메소드 연결
            query_ids = re.findall(r'<(?:select|insert|update|delete)\s+id="([^"]+)"', content)
            for query_id in query_ids:
                # 4.1. 쿼리 컴포넌트 ID 찾기
                query_comp_id = self.db.find_component_by_name_and_type(self.project_name, query_id, 'QUERY')
                # 4.2. Java 메소드 컴포넌트 ID 찾기 (namespace + query_id)
                method_comp_id = self.db.find_component_by_name_and_type(self.project_name, f"{namespace}.{query_id}", 'METHOD')

                if query_comp_id and method_comp_id:
                    # 4.3. 연관관계 저장 (CALLS_QUERY)
                    self.db.insert_relationship(self.project_name, method_comp_id, query_comp_id, 'CALLS_QUERY')
    ```

### **Phase 4: JPA Entity ↔ DB Table 연결**

#### **4.1. `parser/java_parser.py` 수정**

-   **목표**: `@Entity` 클래스에서 `@Table(name=...)`, `@Column(name=...)` 어노테이션을 분석하여 DB 테이블/컬럼과 매핑한다.
-   **수정 로직**: `JavaParser`에 `@Entity` 분석 로직을 추가한다.

    ```python
    # java_parser.py 내 JavaParser 클래스에 추가
    def parse(self, file_path, content):
        # ...
        # Spring Controller 분석 로직 아래에 추가
        if '@Entity' in class_annotations:
            self._analyze_jpa_entity(file_path, content, class_annotations)
        # ...

    def _analyze_jpa_entity(self, file_path, content, class_annotations):
        class_name = class_annotations.get('class_name') # 클래스 이름
        
        # 1. 테이블 이름 찾기
        table_name_match = re.search(r'@Table\s*\(\s*name\s*=\s*"(.*?)"\s*\)', content)
        table_name = table_name_match.group(1) if table_name_match else class_name.upper()

        # 2. Entity 클래스(CLASS) 컴포넌트 ID 찾기
        class_comp_id = self.db.find_component_by_name_and_type(self.project_name, class_name, 'CLASS')
        
        # 3. DB 테이블(TABLE) 컴포넌트 ID 찾기
        table_comp_id = self.db.find_component_by_name_and_type(self.project_name, table_name, 'TABLE')

        # 4. 연관관계 저장 (MAPS_TO_TABLE)
        if class_comp_id and table_comp_id:
            self.db.insert_relationship(self.project_name, class_comp_id, table_comp_id, 'MAPS_TO_TABLE')
        
        # (추가 구현) @Column 분석하여 필드와 컬럼 매핑
    ```

### **Phase 5: 통합 및 리포트 생성**

#### **5.1. `main.py` 수정**

-   **목표**: 모든 분석이 끝난 후, 최종적으로 연관관계 체인을 조회하고 리포트를 생성하는 단계를 추가한다.
-   **수정 로직**: `main` 함수 마지막 부분에 리포트 생성기 호출 코드를 추가한다.

    ```python
    # main.py
    from reports.chain_report_generator import ChainReportGenerator # 신규 임포트

    def main():
        # ... 기존의 모든 파일 분석 및 컴포넌트 저장 로직 ...
        
        # 모든 분석 완료 후
        logger.info("모든 컴포넌트 분석 완료. 연관관계 리포트를 생성합니다.")
        
        # 신규 리포트 생성기 호출
        chain_reporter = ChainReportGenerator(project_name)
        chain_reporter.generate_report()
        
        logger.info(f"리포트 생성 완료. 'projects/{project_name}/report' 폴더를 확인하세요.")
    ```

#### **5.2. `reports/chain_report_generator.py` 신규 생성**

-   **목표**: `relationships` 테이블을 재귀적으로 탐색(Recursive Query)하여 `프론트 → DB`까지 이어지는 모든 체인을 찾아내고, 그 결과를 HTML 또는 Markdown 파일로 생성한다.
-   **신규 파일 내용**:

    ```python
    # reports/chain_report_generator.py
    import os
    from util.database_utils import DatabaseUtils

    class ChainReportGenerator:
        def __init__(self, project_name):
            self.project_name = project_name
            self.db = DatabaseUtils(project_name)
            self.report_path = f"projects/{project_name}/report/chain_report.html"

        def generate_report(self):
            # 1. DB에서 모든 연관관계 조회
            # 2. 프론트엔드 파일(JSP, JS 등)에서 시작하는 모든 경로 탐색
            # 3. 각 경로(체인)를 추적하며 연결고리 시각화
            # 4. 완전한 체인, 끊어진 체인 등을 구분하여 리포트 작성
            
            # 예시: 간단한 텍스트 리포트
            report_content = "<h1>연관관계 분석 리포트</h1>"
            
            # ... DB에서 연관관계 조회 및 체인 구성 로직 ...
            
            # 체인 예시:
            # chain = "list.jsp -> /api/users -> UserController.getUsers -> userMapper.xml -> getUsers -> USERS"
            # report_content += f"<p>{chain}</p>"

            with open(self.report_path, 'w', encoding='utf-8') as f:
                f.write(report_content)
    ```

---

## 4. 결론

본 개발 계획서는 **"누락 없는 연관관계 도출"** 이라는 명확한 목표 아래, 기존 코드 구조를 최대한 활용하면서 필요한 기능을 단계적으로 추가하는 데 초점을 맞췄습니다. 각 단계는 독립적으로 개발 및 테스트가 가능하며, 최종적으로는 모든 연결고리를 탐색하고 시각화하는 통합된 시스템을 구축하게 될 것입니다.

```