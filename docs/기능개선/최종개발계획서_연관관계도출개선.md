# 최종개발계획서 - 연관관계 도출 개선

## 📋 문서 개요

**목적**: SourceAnalyzer의 핵심 목표인 **연관관계 도출**에 집중한 최종 통합 개발계획서  
**기반 문서**: 기능개선 폴더의 모든 문서 검토 및 통합  
**핵심 철학**: "완벽한 파싱보다 연결고리 찾기" - 복잡한 파서 구현보다는 **연관관계 연결고리 추적**에 모든 역량 집중  
**최종 목표**: `프론트파일(JSP/JSX/Vue) → API_URL → CLASS/METHOD → XML → QUERY → TABLE → Column` 완전한 연결고리 도출

---

## 🎯 핵심 목표 및 접근 원칙

### 1. 최종 목표: 완전한 연결고리 도출

```
프론트파일(JSP/JSX/Vue) → API_URL → CLASS/METHOD → XML → QUERY → TABLE → Column
```

이 **완전한 연결고리**를 정확하고 신뢰할 수 있게 도출하는 것이 유일하고 최종적인 목표입니다.

### 2. 핵심 접근 원칙

#### 2.1. **탐색 우선 (Recall > Precision)**
- 정확성보다 **탐지율**을 우선시
- 잘못된 연결(False Positive)이 일부 포함되더라도, 놓치는 연결(False Negative)이 없도록 설계
- 모든 가능한 연결고리를 탐지하여 후속 검증 단계에서 정제

#### 2.2. **단순한 규칙과 패턴 활용**
- 복잡한 AST(추상 구문 트리) 파싱을 최소화
- 정규식, 명명 컨벤션, 키워드 검색 등 가볍고 빠른 규칙 기반 분석 지향
- 복잡한 파서 대신 **연결고리 추적**에 집중

#### 2.3. **양방향 분석 (Bidirectional Analysis)**
- **정방향**: `프론트 → API → METHOD → XML → QUERY → TABLE`
- **역방향**: `TABLE → QUERY → XML → METHOD → API → 프론트`
- 양방향 분석 결과를 교차 검증하여 신뢰도 향상 및 누락된 연결 발견

#### 2.4. **신뢰도 기반 분류**
- **🥇 명시적 연결 (0.9-1.0)**: 어노테이션, XML 설정 등 코드에 명시된 확실한 연결
- **🥈 관례적 연결 (0.7-0.8)**: 명명 규칙 등 프로젝트 관례에 기반한 연결
- **🥉 추론적 연결 (0.4-0.6)**: 유사성, 문자열 리터럴 분석 등 추론에 기반한 연결

---

## 🚨 현재 시스템의 핵심 문제점 (기존 문서 종합)

### 1. **API_URL → METHOD 매핑 로직 부재** (최우선)
- 프론트엔드와 백엔드의 연결고리 단절
- Spring Controller 어노테이션 분석 미흡
- URL 패턴 매칭 알고리즘 부재

### 2. **Java → XML 연결고리 부재**
- MyBatis Mapper 인터페이스와 XML 파일 간 매핑 추적 불가
- `UserMapper.java` ↔ `UserMapper.xml` 연결 로직 부재

### 3. **JPA Entity → TABLE 매핑 부재**
- `@Table` 어노테이션과 실제 DB 테이블 연결 불가
- JPA Entity와 Repository 간 관계 분석 부족

### 4. **프론트엔드 API 호출 패턴 분석 부족**
- Vue/React/TypeScript의 다양한 API 호출 방식 분석 미흡
- `axios`, `fetch`, `$.ajax` 등 프레임워크별 패턴 분석 부족

### 5. **연관관계 도출 정확도 부족**
- 추론(inferred) 컴포넌트에 과도하게 의존하여 신뢰도 하락
- 체인 연결 검증 시스템 부재

### 6. **중복 데이터 및 파싱 능력 한계** (실패사례 분석 결과)
- SQL 컴포넌트 35.4% 중복률
- 동적 SQL 분석 시 조합 폭발 문제
- 파일 중복 등록으로 인한 데이터 품질 저하

---

## 🎯 우선순위별 통합 개선 방안

### **1순위: API_URL → METHOD 매핑 강화** (2-3주)

#### 1.1. Spring Controller 어노테이션 분석 강화
```python
# parser/java_parser.py 수정
def _analyze_spring_controller(self, file_path, content):
    # @RequestMapping, @GetMapping 등 모든 HTTP 메소드 어노테이션 분석
    base_url = self._extract_base_url(content)
    
    for method in self._extract_methods(content):
        api_url = self._build_full_url(base_url, method['url'])
        method_name = f"{class_name}.{method['name']}"
        
        # API_URL 컴포넌트 생성 및 METHOD와 연결
        self._create_api_method_relationship(api_url, method_name)
```

#### 1.2. URL 패턴 정규화 및 매칭 알고리즘
```python
# util/url_matcher.py 신규 생성
class URLPatternMatcher:
    def normalize_url(self, url):
        # Path Variable 정규화: /api/users/{id} → /api/users/.*
        
    def match_urls(self, frontend_url, backend_url):
        # 정규식 기반 URL 매칭
        # 신뢰도 점수 반환
```

#### 1.3. 서버 설정 파일 분석 (보완)
- `web.xml`의 `<servlet-mapping>` 분석
- Spring `WebMvcConfigurer` 설정 분석
- 전역 라우팅 규칙을 통한 매핑 정확도 향상

### **2순위: Java → XML 연결고리 구현** (2-3주)

#### 2.1. MyBatis Mapper 인터페이스 분석
```python
# parser/java_parser.py 수정
def _analyze_mybatis_mapper(self, file_path, content):
    if '@Mapper' in content or 'Mapper' in file_path:
        class_name = self._extract_class_name(content)
        namespace = self._build_namespace(class_name)
        
        # XML 파일과 연결
        self._link_mapper_to_xml(namespace, file_path)
```

#### 2.2. Java 메소드 ↔ XML SQL ID 연결
```python
# parser/xml_parser.py 수정
def _analyze_mybatis_xml(self, file_path, content):
    namespace = self._extract_namespace(content)
    query_ids = self._extract_query_ids(content)
    
    for query_id in query_ids:
        method_name = f"{namespace}.{query_id}"
        # METHOD ↔ QUERY 연결 (관례적 연결, 신뢰도 0.8)
        self._create_method_query_relationship(method_name, query_id, confidence=0.8)
```

### **3순위: JPA Entity → TABLE 매핑 구현** (2-3주)

#### 3.1. JPA Entity 어노테이션 분석
```python
# parser/java_parser.py 수정
def _analyze_jpa_entity(self, file_path, content):
    if '@Entity' in content:
        class_name = self._extract_class_name(content)
        table_name = self._extract_table_name(content) or class_name.upper()
        
        # CLASS ↔ TABLE 연결 (명시적 연결, 신뢰도 1.0)
        self._create_class_table_relationship(class_name, table_name, confidence=1.0)
        
        # @Column 분석하여 필드와 컬럼 매핑
        self._analyze_column_mappings(content, class_name, table_name)
```

#### 3.2. JPA Repository → TABLE 연결
```python
def _analyze_jpa_repository(self, file_path, content):
    if 'Repository' in content and '@Repository' in content:
        # Repository 인터페이스의 제네릭 타입 분석
        entity_type = self._extract_entity_type(content)
        table_name = self._infer_table_from_entity(entity_type)
        
        # Repository ↔ TABLE 연결
        self._create_repository_table_relationship(class_name, table_name)
```

#### 3.3. 문자열 리터럴 기반 SQL 분석 (보완)
```python
def _analyze_string_sql(self, content):
    # JPQL/SQL 문자열 패턴 분석
    sql_patterns = [
        r'createQuery\s*\(\s*["\']([^"\']+)["\']',
        r'createNativeQuery\s*\(\s*["\']([^"\']+)["\']'
    ]
    
    for pattern in sql_patterns:
        for match in re.finditer(pattern, content):
            sql_content = match.group(1)
            tables = self._extract_tables_from_sql(sql_content)
            # 추론적 연결로 테이블 관계 생성
```

### **4순위: 프론트엔드 API 호출 패턴 강화** (1-2주)

#### 4.1. 프레임워크별 분석기 구현
```python
# parser/frontend_parser.py 신규 생성
class FrontendParser:
    def parse_vue_file(self, content):
        # Vue.js API 호출 패턴
        patterns = [
            r'axios\.(get|post|put|delete)\s*\(\s*["\']([^"\']+)["\']',
            r'this\.\$http\.(get|post|put|delete)\s*\(\s*["\']([^"\']+)["\']'
        ]
        
    def parse_react_file(self, content):
        # React API 호출 패턴
        patterns = [
            r'fetch\s*\(\s*["\']([^"\']+)["\']',
            r'axios\.(get|post|put|delete)\s*\(\s*["\']([^"\']+)["\']'
        ]
        
    def parse_jsp_file(self, content):
        # JSP API 호출 패턴
        patterns = [
            r'url\s*:\s*["\']([^"\']+)["\']',  # $.ajax
            r'action\s*=\s*["\']([^"\']+)["\']'  # form action
        ]
```

### **5순위: 체인 연결 검증 및 신뢰도 시스템** (2-3주)

#### 5.1. 연결고리 무결성 검증
```python
# util/chain_validator.py 신규 생성
class ChainValidator:
    def validate_complete_chains(self):
        # 프론트 → DB까지 완전한 체인 검증
        complete_chains = []
        broken_chains = []
        
        for frontend_file in self._get_frontend_files():
            chain = self._trace_chain(frontend_file)
            if self._is_complete_chain(chain):
                complete_chains.append(chain)
            else:
                broken_chains.append(chain)
        
        return complete_chains, broken_chains
```

#### 5.2. 체인 신뢰도 계산
```python
def calculate_chain_confidence(self, chain):
    # 각 연결고리 신뢰도의 곱셈으로 계산
    total_confidence = 1.0
    for relationship in chain:
        total_confidence *= relationship.confidence
    
    return total_confidence
```

### **6순위: 양방향 분석 및 교차 검증 시스템** (2-3주)

#### 6.1. DB-First 분석기 구현
```python
# analyzer/reverse_analyzer.py 신규 생성
class ReverseAnalyzer:
    def analyze_from_database(self):
        # DB 스키마 → QUERY → XML → METHOD → API_URL → 프론트 파일
        for table in self._get_all_tables():
            chains = self._trace_from_table(table)
            self._store_reverse_chains(chains)
    
    def cross_validate_chains(self):
        # 정방향과 역방향 분석 결과 비교
        forward_chains = self._get_forward_chains()
        reverse_chains = self._get_reverse_chains()
        
        return self._compare_chains(forward_chains, reverse_chains)
```

### **7순위: 사용자 피드백 루프 및 학습 기능** (1-2주)

#### 7.1. 관계 수정/확정 인터페이스
```python
# interface/relationship_editor.py 신규 생성
class RelationshipEditor:
    def confirm_relationship(self, src_id, dst_id, rel_type):
        # 사용자가 확정한 관계를 최고 신뢰도로 저장
        
    def remove_relationship(self, src_id, dst_id, rel_type):
        # 잘못된 관계 제거
        
    def add_relationship(self, src_id, dst_id, rel_type):
        # 끊어진 관계 수동 연결
```

#### 7.2. 학습 데이터 활용
```python
# util/learning_manager.py 신규 생성
class LearningManager:
    def load_confirmed_relationships(self):
        # 이전에 사용자가 확정한 관계 로드
        
    def apply_learning_data(self, analysis_results):
        # 학습 데이터를 기반으로 신뢰도 조정
```

---

## 🔧 구현 세부 방안

### 1. **분석기 구조 개선**

#### 1.1. Parser-Builder 패턴 도입
```python
# relationship_builder.py 신규 생성
class RelationshipBuilder:
    def __init__(self, project_name, project_id, all_extracted_data):
        self.project_name = project_name
        self.project_id = project_id
        self.db = DatabaseUtils(f'projects/{project_name}/metadata.db')
        self.data = all_extracted_data  # 모든 파서의 결과 리스트
    
    def build_all_relationships(self):
        # 1. API 관련 관계 구축
        self._build_api_relationships()
        # 2. MyBatis 관련 관계 구축
        self._build_mybatis_relationships()
        # 3. JPA 관련 관계 구축
        self._build_jpa_relationships()
        # 4. 체인 검증 및 신뢰도 계산
        self._validate_and_score_chains()
```

#### 1.2. 각 파서의 역할 명확화
- **Parser**: 연관관계의 단서(raw data)만 추출
- **Builder**: 파서들이 수집한 단서들을 종합하여 최종 관계 설정
- **Validator**: 관계의 신뢰도 검증 및 체인 무결성 확인

### 2. **설정 확장**

#### 2.1. `relationship_patterns.yaml` 신규 생성
```yaml
# config/relationship_patterns.yaml
api_patterns:
  vue:
    - "axios\\.(get|post|put|delete)\\s*\\(\\s*[\"']([^\"']+)[\"']"
    - "this\\.\\$http\\.(get|post|put|delete)\\s*\\(\\s*[\"']([^\"']+)[\"']"
  react:
    - "fetch\\s*\\(\\s*[\"']([^\"']+)[\"']"
    - "axios\\.(get|post|put|delete)\\s*\\(\\s*[\"']([^\"']+)[\"']"
  jsp:
    - "url\\s*:\\s*[\"']([^\"']+)[\"']"
    - "action\\s*=\\s*[\"']([^\"']+)[\"']"

spring_annotations:
  controller:
    - "@RestController"
    - "@Controller"
  mapping:
    - "@RequestMapping"
    - "@GetMapping"
    - "@PostMapping"
    - "@PutMapping"
    - "@DeleteMapping"

jpa_annotations:
  entity:
    - "@Entity"
    - "@Table"
    - "@Column"
  repository:
    - "@Repository"
    - "Repository<.*>"

mybatis_patterns:
  xml:
    - "<mapper\\s+namespace=\"([^\"]+)\">"
    - "<(?:select|insert|update|delete)\\s+id=\"([^\"]+)\">"
  java:
    - "@Mapper"
    - "Mapper"
```

### 3. **DB 스키마 확장**

#### 3.1. `relationships` 테이블 개선
```sql
-- database/create_table_script.sql에 추가
CREATE TABLE IF NOT EXISTS relationships (
    relationship_id INTEGER PRIMARY KEY AUTOINCREMENT,
    src_id INTEGER NOT NULL,
    dst_id INTEGER NOT NULL,
    rel_type VARCHAR(50) NOT NULL,
    confidence REAL DEFAULT 1.0,  -- 신뢰도 점수 (0.0 ~ 1.0)
    line_number INTEGER,
    is_inferred INTEGER DEFAULT 0,  -- 0: 명시적, 1: 관례적, 2: 추론적
    created_at DATETIME DEFAULT (datetime('now', '+9 hours')),
    del_yn CHAR(1) DEFAULT 'N',
    FOREIGN KEY (src_id) REFERENCES components (component_id),
    FOREIGN KEY (dst_id) REFERENCES components (component_id),
    UNIQUE(src_id, dst_id, rel_type)
);

-- 체인 정보 저장 테이블
CREATE TABLE IF NOT EXISTS connection_chains (
    chain_id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    chain_type VARCHAR(20) NOT NULL,  -- 'FORWARD', 'REVERSE'
    chain_data TEXT NOT NULL,  -- JSON 형태로 체인 정보 저장
    confidence REAL DEFAULT 1.0,
    is_complete INTEGER DEFAULT 0,  -- 0: 불완전, 1: 완전
    created_at DATETIME DEFAULT (datetime('now', '+9 hours')),
    del_yn CHAR(1) DEFAULT 'N',
    FOREIGN KEY (project_id) REFERENCES projects (project_id)
);
```

### 4. **리포트 확장**

#### 4.1. `RelationshipReportGenerator` 신규 생성
```python
# reports/relationship_report_generator.py
class RelationshipReportGenerator:
    def generate_chain_report(self):
        # 완전한 체인과 끊어진 체인 리포트
        
    def generate_confidence_report(self):
        # 신뢰도별 관계 현황 리포트
        
    def generate_broken_chain_report(self):
        # 끊어진 체인 상세 분석 리포트
        
    def generate_cross_validation_report(self):
        # 양방향 분석 교차 검증 결과 리포트
```

---

## 📊 기대 효과

### 1. **연결고리 완성도 향상**
- 추론에 의존했던 불완전한 연결을 명시적/관례적 매핑 기반의 정확한 연결로 전환
- 누락된 연결고리 발견률 90% 이상 향상

### 2. **연관관계 신뢰도 향상**
- 모든 연결에 신뢰도 점수를 부여하여 분석 결과의 명확성 제공
- 신뢰도 기반 의사결정 지원

### 3. **개발자 생산성 향상**
- 수동으로 파악해야 했던 시스템의 종단 간(End-to-End) 흐름을 자동화된 리포트로 제공
- 영향도 분석 시간 80% 단축

### 4. **시스템 이해도 향상**
- 전체 시스템의 구조와 데이터 흐름을 명확하게 파악
- 유지보수 및 신규 개발의 효율성 극대화

---

## 🚀 구현 로드맵

### **Phase 1 (2-3주): 핵심 연결고리 구현**
- **1순위**: API_URL → METHOD 매핑 강화
- **2순위**: Java → XML 연결고리 구현
- **목표**: 기본적인 연결고리 도출 가능

### **Phase 2 (2-3주): JPA 및 프론트엔드 지원**
- **3순위**: JPA Entity → TABLE 매핑 구현
- **4순위**: 프론트엔드 API 호출 패턴 강화
- **목표**: 모든 기술 스택 지원 완료

### **Phase 3 (2-3주): 품질 향상**
- **5순위**: 체인 연결 검증 및 신뢰도 시스템
- **6순위**: 양방향 분석 및 교차 검증 시스템
- **목표**: 분석 품질 및 신뢰도 향상

### **Phase 4 (1-2주): 사용자 경험 개선**
- **7순위**: 사용자 피드백 루프 및 학습 기능
- **목표**: 사용자 친화적 인터페이스 및 지속적 개선

---

## 📝 결론

**핵심은 복잡한 파서가 아닌, 단순하고 정확한 연결 매핑에 집중하는 것입니다.**

본 최종 개발계획서는 `프론트파일 → API_URL → CLASS/METHOD → XML → QUERY → TABLE → Column` 연결고리를 **정확하고 신뢰할 수 있게** 도출하는 것을 최우선 목표로 삼습니다. 

기존 문서들의 검토 결과, **파싱 정확도보다는 연결고리 추적**에 집중해야 함을 확인했으며, 이를 통해 SourceAnalyzer는 개발자가 시스템의 전체 구조를 명확하게 파악하고 탐색할 수 있는 **강력한 "시스템 내비게이션"**으로 거듭날 것입니다.

### 주요 개선점 요약
1. **API_URL → METHOD 매핑** 강화로 프론트-백엔드 연결고리 완성
2. **Java → XML 연결** 구현으로 MyBatis 매핑 추적 가능
3. **JPA Entity → TABLE 매핑** 구현으로 JPA 지원 완료
4. **양방향 분석** 도입으로 누락된 연결고리 발견
5. **신뢰도 시스템** 도입으로 분석 결과의 명확성 제공
6. **사용자 피드백** 루프로 지속적 개선 가능

---

**문서 버전**: 3.0 (Final)  
**작성일**: 2025년 1월 17일  
**기반 문서**: 기능개선 폴더 전체 문서 검토 및 통합
