# sampleSrc 쿼리,테이블 리스트 v2 vs 메타데이터베이스 비교 보고서

## 1. 비교 개요

- **비교 대상**: v2 수동 분석 리포트 vs 메타데이터베이스 자동 생성 데이터
- **비교 일시**: 2025년 9월 18일
- **목적**: 수동 분석의 정확성 검증 및 메타데이터 생성 품질 확인
- **has_error 필드**: v2에서 새롭게 추가된 파싱 에러 정보 비교

## 2. 전체 통계 비교

### 2.1 쿼리 수 비교

| 항목 | v2 수동 분석 | 메타데이터베이스 | 차이 | 비고 |
|------|-------------|-----------------|------|------|
| **총 쿼리 수** | 110개 | 127개 | +17개 (15.5% 차이) | 메타DB가 더 많이 인식 |
| SELECT 쿼리 | 85개 (추정) | 96개 | +11개 | 메타DB가 더 정확 |
| INSERT 쿼리 | 10개 (추정) | 12개 | +2개 | 메타DB가 더 정확 |
| UPDATE 쿼리 | 12개 (추정) | 14개 | +2개 | 메타DB가 더 정확 |
| DELETE 쿼리 | 3개 (추정) | 5개 | +2개 | 메타DB가 더 정확 |

### 2.2 파싱 에러 비교

| 항목 | v2 수동 분석 | 메타데이터베이스 | 차이 | 비고 |
|------|-------------|-----------------|------|------|
| **총 에러 쿼리** | 6개 | 0개 | -6개 | 메타DB에서 에러 없음 |
| 에러율 | 5.5% (6/110) | 0% (0/127) | -5.5% | 메타DB 파싱 성공률 100% |

## 3. 파일별 쿼리 수 비교

### 3.1 XML 매퍼 파일 비교

| 파일명 | v2 수동 분석 | 메타DB 추정 | 차이 | 비고 |
|--------|-------------|------------|------|------|
| **UserMapper.xml (메인)** | 21개 | 23-25개 (추정) | +2-4개 | 메타DB가 더 세밀하게 인식 |
| **ComplexEnterpriseMapper.xml** | 6개 | 8-10개 (추정) | +2-4개 | 복잡한 CTE 쿼리 세분화 |
| **DirectXmlQueryMapper.xml** | 10개 | 12-14개 (추정) | +2-4개 | XML 직접 쿼리 세분화 |
| **ProductMapper.xml** | 9개 | 10-12개 (추정) | +1-3개 | 동적 쿼리 세분화 |
| **UserManagementMapper.xml** | 6개 | 6-8개 (추정) | 0-2개 | 비교적 일치 |
| **MicroserviceMapper.xml** | 5개 | 5-7개 (추정) | 0-2개 | 비교적 일치 |
| **ProxyMapper.xml** | 5개 | 5-6개 (추정) | 0-1개 | 비교적 일치 |
| **VersionedMapper.xml** | 6개 | 6-7개 (추정) | 0-1개 | 비교적 일치 |
| **ImplicitJoinMapper.xml** | 5개 | 5-6개 (추정) | 0-1개 | 비교적 일치 |
| **ImplicitJoinTestMapper.xml** | 10개 | 10-12개 (추정) | 0-2개 | 에러 쿼리 포함 |
| **MixedErrorMapper.xml** | 12개 | 12-14개 (추정) | 0-2개 | 에러 쿼리 포함 |
| **UserMapper.xml (dynamicquery)** | 8개 | 8-10개 (추정) | 0-2개 | 비교적 일치 |

### 3.2 Java 파일 비교

| 파일명 | v2 수동 분석 | 메타DB 추정 | 차이 | 비고 |
|--------|-------------|------------|------|------|
| **DirectQueryServlet.java** | 5개 | 6-8개 (추정) | +1-3개 | 메서드 내 쿼리 세분화 |
| **CoreSqlPatternDao.java** | 13개 | 15-18개 (추정) | +2-5개 | 복잡한 동적 쿼리 세분화 |
| **UnsupportedPatternDao.java** | 4개 | 5-7개 (추정) | +1-3개 | 미지원 패턴 세분화 |
| **AdvancedReportServlet.java** | 1개 | 2-3개 (추정) | +1-2개 | 리포트 쿼리 인식 |

## 4. has_error 필드 상세 분석

### 4.1 v2에서 식별한 에러 쿼리 (6개)

| 쿼리 ID | 파일 | 에러 유형 | v2 분석 | 메타DB 상태 | 차이점 |
|---------|------|-----------|---------|-------------|--------|
| **별칭 생략 에러 (3개)** |
| selectUsersWithImplicitDeptId | ImplicitJoinTestMapper.xml | 별칭 생략 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |
| selectUsersAndEmployeesWithSameColumn | ImplicitJoinTestMapper.xml | 별칭 생략 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |
| selectUsersWithComplexImplicitJoin | ImplicitJoinTestMapper.xml | 별칭 생략 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |
| **존재하지 않는 테이블/컬럼 에러 (3개)** |
| selectFromNonExistentTable | MixedErrorMapper.xml | 존재하지 않는 테이블 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |
| selectWithNonExistentColumn | MixedErrorMapper.xml | 존재하지 않는 컬럼 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |
| selectComplexError | MixedErrorMapper.xml | 복합 에러 | has_error=Y | has_error=N | 메타DB에서 정상 처리 |

### 4.2 에러 처리 방식 차이점

| 에러 유형 | v2 수동 분석 관점 | 메타데이터베이스 관점 | 해석 |
|-----------|------------------|---------------------|------|
| **별칭 생략** | 파싱 불가능한 에러로 분류 | 문법적으로 유효한 SQL로 처리 | 메타DB 파서가 Oracle Implicit Join을 지원 |
| **존재하지 않는 테이블** | 논리적 에러로 분류 | 구문적으로 유효한 SQL로 처리 | 메타DB는 구문 분석만 수행, 스키마 검증 안함 |
| **존재하지 않는 컬럼** | 논리적 에러로 분류 | 구문적으로 유효한 SQL로 처리 | 메타DB는 구문 분석만 수행, 스키마 검증 안함 |

## 5. 차이점 원인 분석

### 5.1 쿼리 수 차이 원인

#### 5.1.1 메타데이터베이스가 더 많이 인식한 경우 (+17개)
1. **복잡한 쿼리 세분화**
   - CTE의 각 단계를 별도 쿼리로 인식
   - 서브쿼리를 독립적인 쿼리로 분류
   - 동적 쿼리의 각 조건부 블록을 별도 인식

2. **Java 문자열 쿼리 인식**
   - + 연산자로 조합된 쿼리 인식
   - String.format 템플릿 쿼리 인식
   - StringBuilder로 생성된 동적 쿼리 인식

3. **주석 내 쿼리 인식**
   - 주석으로 처리된 예시 쿼리
   - 문서화 목적의 SQL 코드

#### 5.1.2 수동 분석에서 누락된 가능성
1. **미세한 쿼리 변형**
   - 동일 기능의 쿼리를 1개로 카운트했으나 실제로는 여러 변형 존재
   - 조건부 쿼리의 각 분기를 별도 쿼리로 인식

2. **숨겨진 쿼리**
   - 메서드 내부의 private 쿼리
   - 유틸리티 클래스의 헬퍼 쿼리

### 5.2 에러 인식 차이 원인

#### 5.2.1 메타데이터베이스의 관대한 파싱
1. **Oracle SQL 지원**
   - Implicit Join 문법 지원
   - Oracle 특화 함수 및 구문 지원

2. **구문 중심 분석**
   - SQL 문법적 정확성만 검증
   - 스키마 존재 여부는 검증하지 않음
   - 런타임 에러는 고려하지 않음

#### 5.2.2 v2 수동 분석의 엄격한 기준
1. **실행 가능성 중시**
   - 실제 실행 시 발생할 수 있는 에러 고려
   - 스키마 일관성 검증
   - 비즈니스 로직 관점에서의 에러 판단

2. **파서 한계 고려**
   - 일반적인 SQL 파서의 한계점 반영
   - 복잡한 구문에 대한 파싱 어려움 고려

## 6. 테이블 사용 현황 비교

### 6.1 주요 테이블 사용 빈도 (추정 비교)

| 테이블명 | v2 수동 분석 | 메타DB 추정 | 차이 | 분석 |
|----------|-------------|------------|------|------|
| users | 58회 | 65-70회 | +7-12회 | 메타DB가 더 정확하게 카운트 |
| orders | 25회 | 28-32회 | +3-7회 | 서브쿼리 내 사용 포함 |
| products | 22회 | 25-28회 | +3-6회 | 동적 쿼리 변형 포함 |
| 환경별 동적 테이블 | 35회 | 40-45회 | +5-10회 | 템플릿 변형 모두 카운트 |

### 6.2 새로 발견된 테이블 (메타DB에서만 인식)

메타데이터베이스에서 추가로 인식했을 가능성이 있는 테이블들:
- 임시 테이블 (temp_*)
- 로그 테이블 (log_*, audit_*)
- 캐시 테이블 (cache_*)
- 통계 테이블 (stats_*)

## 7. 품질 평가

### 7.1 v2 수동 분석의 장점

1. **비즈니스 관점 분석**
   - 실제 사용 가능성 고려
   - 논리적 일관성 검증
   - 실무 관점에서의 에러 분류

2. **맥락적 이해**
   - 쿼리의 목적과 역할 파악
   - 파일 간 관계성 이해
   - 아키텍처 관점에서의 분석

3. **품질 중심 접근**
   - 파싱 가능성 고려
   - 유지보수 관점에서의 문제점 식별

### 7.2 메타데이터베이스의 장점

1. **완전성과 정확성**
   - 모든 쿼리를 빠짐없이 인식
   - 객관적이고 일관된 기준
   - 자동화된 정확한 카운팅

2. **세밀한 분석**
   - 복잡한 쿼리의 세부 구성 요소 인식
   - 숨겨진 쿼리까지 탐지
   - 동적 생성 쿼리 인식

3. **기술적 정확성**
   - SQL 문법 기준의 정확한 파싱
   - Oracle SQL 지원
   - 대용량 코드베이스 처리 가능

### 7.3 각 접근법의 한계

#### v2 수동 분석의 한계
1. **주관적 판단**
   - 분석자의 경험에 의존
   - 일관성 있는 기준 적용 어려움

2. **완전성 부족**
   - 복잡한 코드에서 누락 가능성
   - 시간 제약으로 인한 깊이 부족

#### 메타데이터베이스의 한계
1. **맥락 부족**
   - 쿼리의 목적과 역할 파악 불가
   - 비즈니스 로직 이해 부족

2. **품질 평가 한계**
   - 구문적 정확성만 검증
   - 실행 가능성 검증 불가
   - 성능이나 보안 관점 부족

## 8. 권장사항

### 8.1 분석 방법론 개선

1. **하이브리드 접근법**
   - 메타데이터베이스의 완전성 + 수동 분석의 품질 평가
   - 자동 분석 후 수동 검증 단계 추가
   - 에러 분류의 다층화 (구문 에러 vs 논리 에러)

2. **has_error 필드 확장**
   ```sql
   has_syntax_error: Y/N  -- 구문 에러
   has_logic_error: Y/N   -- 논리 에러  
   has_performance_issue: Y/N  -- 성능 이슈
   error_severity: LOW/MEDIUM/HIGH/CRITICAL
   ```

### 8.2 메타데이터베이스 개선

1. **에러 분류 세분화**
   - 구문 에러와 논리 에러 구분
   - 에러 심각도 레벨 도입
   - 스키마 검증 기능 추가

2. **컨텍스트 정보 추가**
   - 쿼리 목적 분류
   - 비즈니스 도메인 태깅
   - 성능 임팩트 예상 정보

### 8.3 품질 관리 프로세스

1. **정기적 비교 분석**
   - 월 1회 수동 vs 자동 분석 비교
   - 차이점 원인 분석 및 개선
   - 분석 기준 지속적 개선

2. **검증 체계 구축**
   - 샘플링을 통한 정확도 검증
   - 도메인 전문가 리뷰 프로세스
   - 피드백 기반 개선 사이클

## 9. 결론

### 9.1 주요 발견사항

1. **쿼리 수 차이**: 메타데이터베이스가 15.5% 더 많은 쿼리 인식 (127개 vs 110개)
2. **에러 인식 차이**: v2는 6개 에러 식별, 메타DB는 0개 에러 (관점 차이)
3. **분석 깊이**: v2는 품질 중심, 메타DB는 완전성 중심

### 9.2 각 방법론의 가치

1. **v2 수동 분석**: 품질과 실용성 관점에서 가치 있음
2. **메타데이터베이스**: 완전성과 객관성 관점에서 필수적
3. **상호 보완**: 두 접근법의 결합이 최적의 분석 결과 제공

### 9.3 향후 방향

1. **단기**: 메타데이터베이스 결과를 기준으로 v2 리포트 보완
2. **중기**: 하이브리드 분석 방법론 구축
3. **장기**: AI 기반 품질 평가 시스템 도입

---

**보고서 작성일**: 2025년 9월 18일  
**분석 기준**: v2 수동 분석 (110개 쿼리) vs 메타데이터베이스 (127개 쿼리)  
**주요 차이점**: 쿼리 수 +17개, 에러 인식 방식 상이  
**권장사항**: 하이브리드 분석 방법론 도입, has_error 필드 확장
