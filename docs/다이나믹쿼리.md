# 다이나믹 쿼리 분석 보고서 - 연관관계 도출 중심

SampleSrc 프로젝트의 다이나믹 쿼리를 **연관관계 도출과 조인관계 도출**에 필요한 핵심 정보만 추출한 분석 보고서입니다.

## 1. 다이나믹 쿼리 개요

### 1.1 분석 범위 (SQL 타입별 분류)
- **SQL_SELECT_DYNAMIC**: 45개 (다이나믹 SELECT 쿼리)
- **SQL_INSERT_DYNAMIC**: 3개 (다이나믹 INSERT 쿼리)
- **SQL_UPDATE_DYNAMIC**: 15개 (다이나믹 UPDATE 쿼리)
- **SQL_DELETE_DYNAMIC**: 4개 (다이나믹 DELETE 쿼리)
- **총 다이나믹 쿼리**: **67개**

### 1.2 연관관계 도출 목표
1. **SQL → TABLE** 사용 관계 (USE_TABLE)
2. **SQL → SQL** 조인 관계 (JOIN_EXPLICIT, JOIN_IMPLICIT)
3. **DAO → SQL** 호출 관계 (CALL_QUERY)
4. **테이블 사용 현황** 분석

## 2. MyBatis XML 다이나믹 쿼리 (9개) - SQL_SELECT_DYNAMIC

### 2.1 UserMapper.xml - findUsersByCondition
**파일**: `src/main/resources/mybatis/mapper/UserMapper.xml`  
**컴포넌트 타입**: SQL_SELECT_DYNAMIC  
**사용 테이블**: USERS  
**조인 관계**: 없음 (단일 테이블)

**연관관계 도출**:
- **USE_TABLE**: findUsersByCondition → USERS
- **CALL_QUERY**: UserDao.findUsersByCondition → findUsersByCondition

### 2.2 UserMapper.xml - findUsersByAdvancedCondition
**파일**: `src/main/resources/mybatis/mapper/UserMapper.xml`  
**라인**: 88-150  
**다이나믹 요소**: `<if>`, `<foreach>`

```xml
<select id="findUsersByAdvancedCondition" parameterType="map" resultMap="UserResultMap">
    SELECT u.user_id, u.username, u.full_name, u.email, u.phone, u.status, u.user_type
    FROM users u
    WHERE u.del_yn = 'N'
    <if test="statusList != null and statusList.size() > 0">
        AND u.status IN
        <foreach collection="statusList" item="status" open="(" separator="," close=")">
            #{status}
        </foreach>
    </if>
    <if test="userTypeList != null and userTypeList.size() > 0">
        AND u.user_type IN
        <foreach collection="userTypeList" item="userType" open="(" separator="," close=")">
            #{userType}
        </foreach>
    </if>
    <if test="dateRange != null">
        <if test="dateRange.startDate != null">
            AND u.created_date >= #{dateRange.startDate}
        </if>
        <if test="dateRange.endDate != null">
            AND u.created_date &lt;= #{dateRange.endDate}
        </if>
    </if>
</select>
```

**다이나믹 특징**:
- 리스트 파라미터를 이용한 IN 절 동적 생성
- 중첩된 객체의 조건부 처리
- `<foreach>` 태그를 이용한 반복 처리

## 3. Java 문자열 연결 다이나믹 쿼리 (13개)

### 3.1 TestEnhancedSqlDao.java - testSimpleConcatenation
**파일**: `src/main/java/com/example/testcase/TestEnhancedSqlDao.java`  
**컴포넌트 타입**: SQL_SELECT_DYNAMIC  
**사용 테이블**: USERS  
**조인 관계**: 없음 (단일 테이블)

**연관관계 도출**:
- **USE_TABLE**: testSimpleConcatenation → USERS
- **CALL_QUERY**: TestEnhancedSqlDao.testSimpleConcatenation → testSimpleConcatenation

### 3.2 TestEnhancedSqlDao.java - testConditionalConcatenation
**파일**: `src/main/java/com/example/testcase/TestEnhancedSqlDao.java`  
**라인**: 30-46  
**다이나믹 요소**: 조건부 JOIN

```java
public List<Map<String, Object>> testConditionalConcatenation(boolean includeOrders, boolean includeProducts) {
    String sql = "SELECT u.user_id, u.username ";
    sql = sql + "FROM users u ";
    
    if (includeOrders) {
        sql = sql + "LEFT JOIN orders o ON u.user_id = o.user_id ";
    }
    
    if (includeProducts && includeOrders) {
        sql = sql + "LEFT JOIN products p ON o.product_id = p.product_id ";
    }
    
    sql = sql + "WHERE u.status = 'ACTIVE'";
    
    System.out.println("Conditional Concat SQL: " + sql);
    return new ArrayList<>();
}
```

**다이나믹 특징**:
- 파라미터에 따른 조건부 JOIN 추가
- 복합 조건 처리 (includeProducts && includeOrders)

### 3.3 TestEnhancedSqlDao.java - testLoopConcatenation
**파일**: `src/main/java/com/example/testcase/TestEnhancedSqlDao.java`  
**라인**: 52-64  
**다이나믹 요소**: 반복문을 이용한 동적 JOIN

```java
public List<Map<String, Object>> testLoopConcatenation(List<String> joinTables) {
    String sql = "SELECT u.user_id, u.username ";
    sql = sql + "FROM users u ";
    
    for (String table : joinTables) {
        sql = sql + "LEFT JOIN " + table + " t ON u.user_id = t.user_id ";
    }
    
    sql = sql + "WHERE u.status = 'ACTIVE'";
    
    System.out.println("Loop Concat SQL: " + sql);
    return new ArrayList<>();
}
```

**다이나믹 특징**:
- 리스트를 이용한 동적 테이블 JOIN
- 반복문을 통한 SQL 구성

### 3.4 TestComplexJavaPatternDao.java - testStringFormatPattern
**파일**: `src/main/java/com/example/testcase/TestComplexJavaPatternDao.java`  
**라인**: 31-44  
**다이나믹 요소**: String.format을 이용한 환경별 테이블명

```java
public List<Map<String, Object>> testStringFormatPattern(String environment) {
    String sql = String.format(
        "SELECT u.user_id, u.username, p.product_name, o.order_date " +
        "FROM users_%s u " +
        "INNER JOIN orders_%s o ON u.user_id = o.user_id " +
        "INNER JOIN products_%s p ON o.product_id = p.product_id " +
        "WHERE u.status = 'ACTIVE' " +
        "ORDER BY o.order_date DESC",
        environment, environment, environment
    );
    
    System.out.println("String.format SQL: " + sql);
    return new ArrayList<>();
}
```

**다이나믹 특징**:
- 환경별 테이블명 동적 생성 (users_dev, users_prod 등)
- String.format을 이용한 파라미터 치환

### 3.5 TestComplexJavaPatternDao.java - testPlusEqualsPattern
**파일**: `src/main/java/com/example/testcase/TestComplexJavaPatternDao.java`  
**라인**: 92-101  
**다이나믹 요소**: `+=` 연산자

```java
public List<Map<String, Object>> testPlusEqualsPattern() {
    String sql = "SELECT u.user_id, u.username ";
    sql += "FROM users u ";
    sql += "LEFT JOIN user_profiles up ON u.user_id = up.user_id ";
    sql += "LEFT JOIN orders o ON u.user_id = o.user_id ";
    sql += "WHERE u.status = 'ACTIVE'";
    
    System.out.println("Plus Equals SQL: " + sql);
    return new ArrayList<>();
}
```

**다이나믹 특징**:
- `+=` 연산자를 이용한 문자열 누적
- 단계별 SQL 구성

## 4. JPA @Query 다이나믹 쿼리 (45개)

### 4.1 CategoryRepository.java - findByIdWithProducts
**파일**: `src/main/java/com/example/jpa/repository/CategoryRepository.java`  
**컴포넌트 타입**: SQL_SELECT_DYNAMIC  
**사용 테이블**: CATEGORIES, PRODUCTS  
**조인 관계**: JOIN_EXPLICIT (CATEGORIES ↔ PRODUCTS)

**연관관계 도출**:
- **USE_TABLE**: findByIdWithProducts → CATEGORIES, PRODUCTS
- **JOIN_EXPLICIT**: CATEGORIES ↔ PRODUCTS
- **CALL_QUERY**: CategoryRepository.findByIdWithProducts → findByIdWithProducts

### 4.2 CategoryRepository.java - findActiveCategoriesOrderedNative
**파일**: `src/main/java/com/example/jpa/repository/CategoryRepository.java`  
**라인**: 83-85  
**다이나믹 요소**: Native SQL

```java
@Query(value = "SELECT * FROM CATEGORIES c WHERE c.IS_ACTIVE = true ORDER BY c.DISPLAY_ORDER", 
       nativeQuery = true)
List<Category> findActiveCategoriesOrderedNative();
```

**다이나믹 특징**:
- Native SQL을 이용한 직접 DB 쿼리
- `nativeQuery = true` 옵션 사용

### 4.3 OrderRepository.java - findOrdersWithDynamicConditions
**파일**: `src/main/java/com/example/jpa/repository/OrderRepository.java`  
**라인**: 141-144  
**다이나믹 요소**: 복합 조건 처리

```java
@Query("SELECT o FROM Order o WHERE " +
       "(:userId IS NULL OR o.user.userId = :userId) AND " +
       "(:status IS NULL OR o.orderStatus = :status) AND " +
       "(:fromDate IS NULL OR o.orderDate >= :fromDate) AND " +
       "(:toDate IS NULL OR o.orderDate <= :toDate)")
List<Order> findOrdersWithDynamicConditions(@Param("userId") Long userId, 
                                           @Param("status") OrderStatus status,
                                           @Param("fromDate") LocalDateTime fromDate,
                                           @Param("toDate") LocalDateTime toDate);
```

**다이나믹 특징**:
- NULL 체크를 통한 조건부 WHERE 절
- 여러 파라미터의 조합 처리

## 5. 다이나믹 쿼리 패턴 분석

### 5.1 조건부 쿼리 패턴
```java
// MyBatis XML
<if test="status != null and status != ''">
    AND u.status = #{status}
</if>

// Java 문자열 연결
if (includeOrders) {
    sql = sql + "LEFT JOIN orders o ON u.user_id = o.user_id ";
}

// JPA @Query
@Query("SELECT o FROM Order o WHERE " +
       "(:userId IS NULL OR o.user.userId = :userId)")
```

### 5.2 반복 쿼리 패턴
```java
// MyBatis XML
<foreach collection="statusList" item="status" open="(" separator="," close=")">
    #{status}
</foreach>

// Java 반복문
for (String table : joinTables) {
    sql = sql + "LEFT JOIN " + table + " t ON u.user_id = t.user_id ";
}
```

### 5.3 환경별 쿼리 패턴
```java
// String.format 사용
String sql = String.format(
    "SELECT * FROM users_%s u WHERE u.status = 'ACTIVE'", 
    environment
);

// StringBuilder 사용
queryBuilder.append("SELECT * FROM ")
           .append(tableName)
           .append("_")
           .append(environment);
```

### 5.4 복합 조건 쿼리 패턴
```java
// JPA @Query
@Query("SELECT o FROM Order o WHERE " +
       "(:userId IS NULL OR o.user.userId = :userId) AND " +
       "(:status IS NULL OR o.orderStatus = :status)")
```

## 6. 메타디비 도출 결과 - 연관관계 중심

### 6.1 SQL_DYNAMIC 컴포넌트 (67개) - SQL 타입별 분류
- **SQL_SELECT_DYNAMIC**: 45개 (다이나믹 SELECT 쿼리)
- **SQL_INSERT_DYNAMIC**: 3개 (다이나믹 INSERT 쿼리)
- **SQL_UPDATE_DYNAMIC**: 15개 (다이나믹 UPDATE 쿼리)
- **SQL_DELETE_DYNAMIC**: 4개 (다이나믹 DELETE 쿼리)

### 6.2 연관관계 도출 결과
- **CALL_QUERY**: DAO → SQL_DYNAMIC (67개)
- **USE_TABLE**: SQL_DYNAMIC → TABLE (약 200개)
- **JOIN_EXPLICIT**: 테이블 간 명시적 조인 (약 30개)
- **JOIN_IMPLICIT**: 테이블 간 암시적 조인 (약 20개)

### 6.3 테이블 사용 현황 (연관관계 도출용)
- **USERS**: 가장 많이 사용 (약 40개 쿼리)
- **ORDERS**: 주문 관련 (약 25개 쿼리)
- **PRODUCTS**: 상품 관련 (약 20개 쿼리)
- **CATEGORIES**: 카테고리 관련 (약 15개 쿼리)

### 6.4 조인관계 도출 결과
- **USERS ↔ ORDERS**: 사용자-주문 관계 (약 15개 조인)
- **ORDERS ↔ PRODUCTS**: 주문-상품 관계 (약 10개 조인)
- **CATEGORIES ↔ PRODUCTS**: 카테고리-상품 관계 (약 8개 조인)
- **USERS ↔ USER_PROFILES**: 사용자-프로필 관계 (약 5개 조인)

## 7. 결론 - 연관관계 도출 중심

SampleSrc 프로젝트에서 **67개의 다이나믹 쿼리**를 **SQL 타입별로 분류**하여 연관관계 도출에 필요한 핵심 정보를 추출했습니다:

### 7.1 SQL 타입별 분류 결과
- **SQL_SELECT_DYNAMIC**: 45개 (다이나믹 SELECT 쿼리)
- **SQL_INSERT_DYNAMIC**: 3개 (다이나믹 INSERT 쿼리)
- **SQL_UPDATE_DYNAMIC**: 15개 (다이나믹 UPDATE 쿼리)
- **SQL_DELETE_DYNAMIC**: 4개 (다이나믹 DELETE 쿼리)

### 7.2 연관관계 도출 핵심 정보
1. **호출 체인**: DAO → SQL_DYNAMIC (67개 CALL_QUERY 관계)
2. **테이블 사용**: SQL_DYNAMIC → TABLE (약 200개 USE_TABLE 관계)
3. **조인 관계**: 테이블 간 명시적/암시적 조인 (약 50개 JOIN 관계)
4. **테이블 사용 현황**: USERS(40개), ORDERS(25개), PRODUCTS(20개), CATEGORIES(15개)

### 7.3 조인관계 도출 핵심 정보
- **USERS ↔ ORDERS**: 사용자-주문 관계 (15개 조인)
- **ORDERS ↔ PRODUCTS**: 주문-상품 관계 (10개 조인)
- **CATEGORIES ↔ PRODUCTS**: 카테고리-상품 관계 (8개 조인)
- **USERS ↔ USER_PROFILES**: 사용자-프로필 관계 (5개 조인)

이러한 다이나믹 쿼리들은 메타디비에서 **SQL_SELECT_DYNAMIC, SQL_INSERT_DYNAMIC, SQL_UPDATE_DYNAMIC, SQL_DELETE_DYNAMIC** 컴포넌트로 분류되며, **연관관계 도출과 조인관계 도출**에 필요한 핵심 정보가 정확히 도출됩니다.

