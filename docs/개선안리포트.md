# SourceAnalyzer íŒŒì‹± ë¡œì§ ê°œì„ ì•ˆ ë¦¬í¬íŠ¸

## ğŸ“‹ ë¶„ì„ ê°œìš”

**ë¶„ì„ ê¸°ê°„**: 2025ë…„ 9ì›” 17ì¼  
**ë¶„ì„ ëª©ì **: ì •í™•ì„±ê³¼ ì™„ì „ì„± ì¤‘ì‹¬ì˜ íŒŒì‹± ë¡œì§ ì ê²€ ë° ê°œì„  ë°©ì•ˆ ë„ì¶œ  
**ì¤‘ì  ì˜ì—­**: ë‹¤ì´ë‚˜ë¯¹ SQLì—ì„œ í…Œì´ë¸” ì •ë³´ ëˆ„ë½ ë°©ì§€  

---

## ğŸ” í˜„ì¬ êµ¬í˜„ í˜„í™© ë¶„ì„

### âœ… ìš°ìˆ˜í•œ êµ¬í˜„ ìš”ì†Œë“¤

1. **ê²¬ê³ í•œ XML íŒŒì‹± ì•„í‚¤í…ì²˜**
   - DOM â†’ SAX â†’ Regex 3ë‹¨ê³„ Fallback ë©”ì»¤ë‹ˆì¦˜
   - `RecursionError` ë°©ì§€ë¥¼ ìœ„í•œ ê¹Šì´ ì œí•œ (10íšŒ)
   - ë©”ëª¨ë¦¬ ìµœì í™”ëœ ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬

2. **ì²´ê³„ì ì¸ ì„¤ì • ê¸°ë°˜ íŒŒì‹±**
   - `java_keyword.yaml`, `xml_parser_config.yaml`, `sql_keyword.yaml` 
   - í•˜ë“œì½”ë”© ìµœì†Œí™”ë¡œ ìœ ì§€ë³´ìˆ˜ì„± í™•ë³´
   - Oracle SQL íŠ¹í™” í‚¤ì›Œë“œ ë° íŒ¨í„´ ì •ì˜

3. **ì§€ëŠ¥ì ì¸ ê´€ê³„ ì¶”ì **
   - INFERRED ì»´í¬ë„ŒíŠ¸ ìë™ ìƒì„± (`tables`, `columns`, `components`)
   - Java íŒŒì„œì˜ `_get_query_component_id()` ê°œì„ ìœ¼ë¡œ ì¤‘ë³µ ë°©ì§€
   - ë‹¤ì–‘í•œ ê´€ê³„ íƒ€ì… ì§€ì› (CALL_QUERY, USE_TABLE, JOIN_EXPLICIT ë“±)

4. **MyBatis ë™ì  SQL ì§€ì›**
   - `MybatisParser` í´ë˜ìŠ¤ì˜ ìƒíƒœ ê¸°ë°˜ ì»¨í…ìŠ¤íŠ¸ ì²˜ë¦¬
   - `foreach`, `if`, `choose`, `bind` íƒœê·¸ ì‹œë®¬ë ˆì´ì…˜
   - ìƒ˜í”Œ ë°ì´í„° ê¸°ë°˜ SQL ì¬êµ¬ì„±

---

## âš ï¸ í•µì‹¬ ë¬¸ì œì  ë¶„ì„ (ì •í™•ì„±/ì™„ì „ì„± ê´€ì )

### 1. **ë™ì  SQL íƒœê·¸ ë‚´ë¶€ í…Œì´ë¸” ì •ë³´ ëˆ„ë½**

#### ğŸ”´ ë¬¸ì œì 
```xml
<!-- ëˆ„ë½ ìœ„í—˜ ì¼€ì´ìŠ¤ 1: ì¡°ê±´ë¶€ JOIN -->
<select id="getOrderData">
    SELECT o.order_id, o.amount
    FROM orders o
    <if test="includeCustomer != null">
        LEFT JOIN customers c ON o.customer_id = c.customer_id  <!-- customers í…Œì´ë¸” ëˆ„ë½ ê°€ëŠ¥ -->
    </if>
    <if test="includeProduct != null">
        LEFT JOIN products p ON o.product_id = p.product_id    <!-- products í…Œì´ë¸” ëˆ„ë½ ê°€ëŠ¥ -->
    </if>
</select>

<!-- ëˆ„ë½ ìœ„í—˜ ì¼€ì´ìŠ¤ 2: foreach ë‚´ë¶€ ë™ì  í…Œì´ë¸” -->
<foreach collection="tableNames" item="tableName">
    SELECT * FROM ${tableName}  <!-- ë™ì  í…Œì´ë¸”ëª… ì¶”ì¶œ ë¶ˆê°€ -->
</foreach>
```

#### ğŸ”§ í˜„ì¬ ì²˜ë¦¬ ë°©ì‹ì˜ í•œê³„
- `_normalize_sql_for_analysis()`ì—ì„œ ë™ì  íƒœê·¸ ì œê±° ì‹œ ë‚´ë¶€ í…Œì´ë¸” ì •ë³´ ì†ì‹¤
- `_detect_dynamic_join()`ì´ íŒ¨í„´ ê°ì§€ë§Œ í•˜ê³  ì‹¤ì œ í…Œì´ë¸” ì¶”ì¶œì€ ë¯¸í¡
- ì¡°ê±´ë³„ ë¶„ê¸° ê²½ë¡œë¥¼ ëª¨ë‘ ë¶„ì„í•˜ì§€ ëª»í•¨

### 2. **include íƒœê·¸ ë° SQL ì¡°ê° ì°¸ì¡° ì²˜ë¦¬ ë¶€ì¡±**

#### ğŸ”´ ë¬¸ì œì 
```xml
<!-- SQL ì¡°ê° ì •ì˜ -->
<sql id="userJoinClause">
    LEFT JOIN user_profiles up ON u.user_id = up.user_id
    LEFT JOIN user_settings us ON u.user_id = us.user_id
</sql>

<!-- ì‚¬ìš© -->
<select id="getUserData">
    SELECT u.*, up.*, us.*
    FROM users u
    <include refid="userJoinClause"/>  <!-- ì°¸ì¡°ëœ í…Œì´ë¸”ë“¤ ëˆ„ë½ -->
</select>
```

#### ğŸ”§ í˜„ì¬ ì²˜ë¦¬ì˜ í•œê³„
- `include` íƒœê·¸ì˜ `refid` ì°¸ì¡° í•´ì„ ë¯¸ì§€ì›
- ì™¸ë¶€ SQL ì¡°ê°ì— í¬í•¨ëœ í…Œì´ë¸” ì •ë³´ ì¶”ì¶œ ë¶ˆê°€
- í¬ë¡œìŠ¤ íŒŒì¼ ì°¸ì¡°ì‹œ ì˜ì¡´ì„± ì¶”ì  ë¶ˆê°€

### 3. **ë³µì¡í•œ SQL êµ¬ì¡°ì—ì„œ í…Œì´ë¸” ëˆ„ë½**

#### ğŸ”´ ë¬¸ì œì 
```sql
-- CTEì™€ recursive êµ¬ì¡°
WITH RECURSIVE category_tree AS (
    SELECT category_id, parent_id, name FROM categories WHERE parent_id IS NULL
    UNION ALL
    SELECT c.category_id, c.parent_id, c.name 
    FROM categories c  -- ì´ í…Œì´ë¸” ëˆ„ë½ ê°€ëŠ¥
    INNER JOIN category_tree ct ON c.parent_id = ct.category_id
)
SELECT * FROM category_tree ct
LEFT JOIN products p ON ct.category_id = p.category_id;

-- ë‹¤ì¤‘ ë ˆë²¨ ì„œë¸Œì¿¼ë¦¬
SELECT o.order_id, 
       (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.order_id) as item_count,
       (SELECT c.name FROM customers c WHERE c.customer_id = o.customer_id) as customer_name
FROM orders o
WHERE EXISTS (
    SELECT 1 FROM payments pay 
    WHERE pay.order_id = o.order_id 
    AND pay.status = 'COMPLETED'
);
```

### 4. **ë§¤ê°œë³€ìˆ˜ ì¹˜í™˜ì˜ í•œê³„**

#### ğŸ”´ ë¬¸ì œì 
```xml
<select id="dynamicTableQuery">
    SELECT * FROM ${schemaName}.${tableName}  <!-- ë™ì  ìŠ¤í‚¤ë§ˆ.í…Œì´ë¸”ëª… -->
    WHERE ${whereClause}  <!-- ë™ì  WHERE ì¡°ê±´ì— í…Œì´ë¸” ì°¸ì¡° ê°€ëŠ¥ -->
</select>

<bind name="dynamicJoin" value="'LEFT JOIN ' + joinTable + ' jt ON main.id = jt.main_id'"/>
SELECT * FROM main_table main ${dynamicJoin}  <!-- ë™ì  JOIN ìƒì„± -->
```

---

## ğŸ¯ ì •í™•ì„± ìš°ì„  ê°œì„  ë°©ì•ˆ

### ğŸ“ˆ ìš°ì„ ìˆœìœ„ 1: ë‹¤ì¤‘ ê²½ë¡œ ë™ì  SQL ë¶„ì„ ê°•í™”

#### ğŸ”§ êµ¬í˜„ ë°©ì•ˆ

1. **ì¡°ê±´ë³„ ë¶„ê¸° ê²½ë¡œ ì „ì²´ ë¶„ì„**
```python
class EnhancedMybatisParser(MybatisParser):
    def _process_conditional_paths(self, node: ET.Element) -> List[str]:
        """ëª¨ë“  ì¡°ê±´ ë¶„ê¸° ê²½ë¡œë¥¼ ìƒì„±í•˜ì—¬ í…Œì´ë¸” ì •ë³´ ì™„ì „ ì¶”ì¶œ"""
        if node.tag == 'if':
            # true/false ë‘ ê²½ë¡œ ëª¨ë‘ ë¶„ì„
            return [
                self._process_node_with_condition(node, True),   # ì¡°ê±´ true
                self._process_node_with_condition(node, False)   # ì¡°ê±´ false (ë¹ˆ ë¬¸ìì—´)
            ]
        elif node.tag == 'choose':
            paths = []
            # ëª¨ë“  when ì¡°ê±´ + otherwise ê²½ë¡œ ë¶„ì„
            for when_node in node.findall('.//when'):
                paths.append(self._process_node(when_node, context))
            otherwise_node = node.find('.//otherwise')
            if otherwise_node is not None:
                paths.append(self._process_node(otherwise_node, context))
            return paths
```

2. **foreach íƒœê·¸ ë‹¤ì¤‘ ì‹œë‚˜ë¦¬ì˜¤ ì²˜ë¦¬**
```python
def _reconstruct_foreach_tag_enhanced(self, node: ET.Element, context: Dict[str, str]) -> List[str]:
    """foreachë¥¼ ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ë¡œ ì¬êµ¬ì„±í•˜ì—¬ ëª¨ë“  í…Œì´ë¸” ì¶”ì¶œ"""
    # ê¸°ì¡´: 2ê°œ ìƒ˜í”Œê°’ë§Œ ì‚¬ìš©
    # ê°œì„ : ë‹¤ì–‘í•œ ë°ì´í„° íƒ€ì…ë³„ ì‹œë‚˜ë¦¬ì˜¤ ìƒì„±
    scenarios = [
        # í…Œì´ë¸”ëª… ì‹œë‚˜ë¦¬ì˜¤
        {'string': ['users', 'orders', 'products']},  
        # ìŠ¤í‚¤ë§ˆ.í…Œì´ë¸” ì‹œë‚˜ë¦¬ì˜¤
        {'string': ['schema1.table1', 'schema2.table2']},
        # ë³µí•© êµ¬ì¡° ì‹œë‚˜ë¦¬ì˜¤  
        {'string': ['(SELECT * FROM temp_table)', 'actual_table']}
    ]
    
    reconstructed_sqls = []
    for scenario in scenarios:
        self.sample_data = scenario
        sql_result = self._reconstruct_foreach_tag(node, context)
        if sql_result.strip():
            reconstructed_sqls.append(sql_result)
    
    return reconstructed_sqls
```

### ğŸ“ˆ ìš°ì„ ìˆœìœ„ 2: Include íƒœê·¸ ë° SQL ì¡°ê° ì°¸ì¡° í•´ì„

#### ğŸ”§ êµ¬í˜„ ë°©ì•ˆ

1. **SQL ì¡°ê° ì˜ì¡´ì„± ê·¸ë˜í”„ êµ¬ì¶•**
```python
class SqlFragmentResolver:
    def __init__(self):
        self.fragment_map = {}  # id -> sql content
        self.dependency_graph = {}  # fragment_id -> [dependent_fragments]
    
    def resolve_includes(self, xml_files: List[str]) -> Dict[str, str]:
        """ëª¨ë“  XML íŒŒì¼ì—ì„œ sql ì¡°ê°ì„ ìˆ˜ì§‘í•˜ê³  include í•´ì„"""
        # 1ë‹¨ê³„: ëª¨ë“  <sql id="..."> ì¡°ê° ìˆ˜ì§‘
        for xml_file in xml_files:
            self._collect_sql_fragments(xml_file)
        
        # 2ë‹¨ê³„: include ê´€ê³„ í•´ì„í•˜ì—¬ ì™„ì „í•œ SQL ìƒì„±
        for fragment_id in self.fragment_map:
            self._resolve_fragment_recursively(fragment_id)
        
        return self.fragment_map
    
    def _resolve_fragment_recursively(self, fragment_id: str, visited=None):
        """ì¬ê·€ì ìœ¼ë¡œ include íƒœê·¸ë¥¼ í•´ì„í•˜ì—¬ ì™„ì „í•œ SQL ìƒì„±"""
        if visited is None:
            visited = set()
        
        if fragment_id in visited:
            return  # ìˆœí™˜ ì°¸ì¡° ë°©ì§€
        
        visited.add(fragment_id)
        sql_content = self.fragment_map[fragment_id]
        
        # <include refid="..."/> íŒ¨í„´ ì°¾ê¸°
        includes = re.findall(r'<include\s+refid=["\']([^"\']+)["\']', sql_content)
        for include_id in includes:
            if include_id in self.fragment_map:
                self._resolve_fragment_recursively(include_id, visited)
                # include íƒœê·¸ë¥¼ ì‹¤ì œ SQLë¡œ ì¹˜í™˜
                included_sql = self.fragment_map[include_id]
                sql_content = sql_content.replace(
                    f'<include refid="{include_id}"/>', 
                    included_sql
                )
        
        self.fragment_map[fragment_id] = sql_content
```

2. **XML íŒŒì„œì— í†µí•©**
```python
class XmlParser:
    def extract_sql_queries_and_analyze_relationships(self, xml_file):
        # ê¸°ì¡´ ë¡œì§ ì „ì— include í•´ì„ ì¶”ê°€
        if not hasattr(self, '_fragment_resolver'):
            self._fragment_resolver = SqlFragmentResolver()
            # í”„ë¡œì íŠ¸ ë‚´ ëª¨ë“  XML íŒŒì¼ì—ì„œ SQL ì¡°ê° ìˆ˜ì§‘
            xml_files = self._get_all_xml_files()
            self._fragment_resolver.resolve_includes(xml_files)
        
        # SQL ì¿¼ë¦¬ ì¶”ì¶œì‹œ í•´ì„ëœ ì¡°ê° ì‚¬ìš©
        return self._extract_with_resolved_includes(xml_file)
```

### ğŸ“ˆ ìš°ì„ ìˆœìœ„ 3: ë³µì¡í•œ SQL êµ¬ì¡° ì™„ì „ ë¶„ì„

#### ğŸ”§ êµ¬í˜„ ë°©ì•ˆ

1. **ì¬ê·€ì  SQL êµ¬ì¡° ë¶„ì„ê¸°**
```python
class RecursiveSqlAnalyzer:
    def extract_all_tables_comprehensive(self, sql_content: str) -> Set[str]:
        """ëª¨ë“  í…Œì´ë¸”ì„ ì¬ê·€ì ìœ¼ë¡œ ì¶”ì¶œ (ëˆ„ë½ ì—†ì´)"""
        all_tables = set()
        
        # 1. ë©”ì¸ ì¿¼ë¦¬ í…Œì´ë¸”
        all_tables.update(self._extract_main_query_tables(sql_content))
        
        # 2. CTE ì •ì˜ë¶€ í…Œì´ë¸” (WITH ì ˆ)
        all_tables.update(self._extract_cte_tables(sql_content))
        
        # 3. ì„œë¸Œì¿¼ë¦¬ í…Œì´ë¸” (ëª¨ë“  ë ˆë²¨)
        all_tables.update(self._extract_subquery_tables_recursive(sql_content))
        
        # 4. UNION êµ¬ì¡° í…Œì´ë¸”
        all_tables.update(self._extract_union_tables(sql_content))
        
        # 5. EXISTS/NOT EXISTS ë‚´ë¶€ í…Œì´ë¸”
        all_tables.update(self._extract_exists_tables(sql_content))
        
        # 6. ìŠ¤ì¹¼ë¼ ì„œë¸Œì¿¼ë¦¬ í…Œì´ë¸”
        all_tables.update(self._extract_scalar_subquery_tables(sql_content))
        
        return all_tables
    
    def _extract_subquery_tables_recursive(self, sql_content: str, depth=0) -> Set[str]:
        """ì„œë¸Œì¿¼ë¦¬ë¥¼ ì¬ê·€ì ìœ¼ë¡œ íŒŒì‹±í•˜ì—¬ ëª¨ë“  í…Œì´ë¸” ì¶”ì¶œ"""
        if depth > 10:  # ë¬´í•œ ì¬ê·€ ë°©ì§€
            return set()
        
        tables = set()
        
        # ê´„í˜¸ë¡œ ê°ì‹¸ì§„ ì„œë¸Œì¿¼ë¦¬ íŒ¨í„´
        subquery_pattern = r'\(([^()]*(?:\([^()]*\)[^()]*)*)\)'
        subqueries = re.findall(subquery_pattern, sql_content, re.DOTALL)
        
        for subquery in subqueries:
            if self._is_sql_query(subquery):
                # ì„œë¸Œì¿¼ë¦¬ì—ì„œ í…Œì´ë¸” ì¶”ì¶œ
                tables.update(self._extract_main_query_tables(subquery))
                # ì¤‘ì²©ëœ ì„œë¸Œì¿¼ë¦¬ ì¬ê·€ ì²˜ë¦¬
                tables.update(self._extract_subquery_tables_recursive(subquery, depth + 1))
        
        return tables
```

2. **ë™ì  í…Œì´ë¸”ëª… íŒ¨í„´ ì¸ì‹**
```python
def _extract_dynamic_table_patterns(self, sql_content: str) -> Set[str]:
    """ë§¤ê°œë³€ìˆ˜ ê¸°ë°˜ ë™ì  í…Œì´ë¸”ëª… íŒ¨í„´ ì¶”ì¶œ"""
    dynamic_tables = set()
    
    # ${tableName} íŒ¨í„´
    param_patterns = re.findall(r'\$\{(\w+)\}', sql_content)
    for pattern in param_patterns:
        if self._is_table_name_parameter(pattern):
            # ì„¤ì • íŒŒì¼ì—ì„œ ê°€ëŠ¥í•œ í…Œì´ë¸”ëª…ë“¤ì„ ì¡°íšŒí•˜ì—¬ ì¶”ê°€
            possible_tables = self._get_possible_table_names(pattern)
            dynamic_tables.update(possible_tables)
    
    # schema.${tableName} íŒ¨í„´
    schema_table_patterns = re.findall(r'(\w+)\.\$\{(\w+)\}', sql_content)
    for schema, table_param in schema_table_patterns:
        possible_tables = self._get_possible_table_names(table_param, schema)
        dynamic_tables.update(possible_tables)
    
    return dynamic_tables

def _get_possible_table_names(self, parameter_name: str, schema: str = None) -> Set[str]:
    """ë§¤ê°œë³€ìˆ˜ëª…ì„ ê¸°ë°˜ìœ¼ë¡œ ê°€ëŠ¥í•œ í…Œì´ë¸”ëª…ë“¤ ë°˜í™˜"""
    # ë°ì´í„°ë² ì´ìŠ¤ ë©”íƒ€ë°ì´í„°ì—ì„œ ì‹¤ì œ í…Œì´ë¸” ëª©ë¡ ì¡°íšŒ
    # ë˜ëŠ” ì„¤ì • íŒŒì¼ì— ì •ì˜ëœ ë§¤í•‘ ì‚¬ìš©
    table_mapping = {
        'tableName': ['users', 'orders', 'products'],
        'entityTable': ['user_profiles', 'order_items'],
        'logTable': ['access_logs', 'error_logs', 'audit_logs']
    }
    
    possible_tables = table_mapping.get(parameter_name, [])
    if schema:
        return {f"{schema}.{table}" for table in possible_tables}
    return set(possible_tables)
```

### ğŸ“ˆ ìš°ì„ ìˆœìœ„ 4: ê²€ì¦ ë° ì™„ì „ì„± ì²´í¬ ì‹œìŠ¤í…œ

#### ğŸ”§ êµ¬í˜„ ë°©ì•ˆ

1. **í…Œì´ë¸” ì¶”ì¶œ ê²°ê³¼ ê²€ì¦**
```python
class TableExtractionValidator:
    def validate_completeness(self, sql_content: str, extracted_tables: Set[str]) -> Dict[str, Any]:
        """í…Œì´ë¸” ì¶”ì¶œ ì™„ì „ì„± ê²€ì¦"""
        validation_result = {
            'is_complete': True,
            'missing_tables': [],
            'suspicious_patterns': [],
            'confidence_score': 0.0
        }
        
        # 1. í‚¤ì›Œë“œ ê¸°ë°˜ ëˆ„ë½ íƒì§€
        table_keywords = ['FROM', 'JOIN', 'INTO', 'UPDATE', 'EXISTS']
        for keyword in table_keywords:
            potential_tables = self._find_tables_near_keyword(sql_content, keyword)
            missing = potential_tables - extracted_tables
            validation_result['missing_tables'].extend(missing)
        
        # 2. ì˜ì‹¬ìŠ¤ëŸ¬ìš´ íŒ¨í„´ ê°ì§€
        suspicious = self._detect_suspicious_patterns(sql_content)
        validation_result['suspicious_patterns'] = suspicious
        
        # 3. ì‹ ë¢°ë„ ì ìˆ˜ ê³„ì‚°
        validation_result['confidence_score'] = self._calculate_confidence_score(
            sql_content, extracted_tables, validation_result['missing_tables']
        )
        
        validation_result['is_complete'] = (
            len(validation_result['missing_tables']) == 0 and 
            validation_result['confidence_score'] > 0.8
        )
        
        return validation_result
    
    def _detect_suspicious_patterns(self, sql_content: str) -> List[str]:
        """í…Œì´ë¸” ëˆ„ë½ ê°€ëŠ¥ì„±ì´ ìˆëŠ” ì˜ì‹¬ìŠ¤ëŸ¬ìš´ íŒ¨í„´ ê°ì§€"""
        patterns = []
        
        # ë™ì  ë§¤ê°œë³€ìˆ˜ íŒ¨í„´
        if re.search(r'\$\{[^}]*[Tt]able[^}]*\}', sql_content):
            patterns.append('ë™ì  í…Œì´ë¸”ëª… ë§¤ê°œë³€ìˆ˜ ë°œê²¬')
        
        # ë¯¸ì²˜ë¦¬ëœ include íƒœê·¸
        if re.search(r'<include\s+refid=', sql_content):
            patterns.append('ë¯¸í•´ì„ëœ include íƒœê·¸ ë°œê²¬')
        
        # ë³µì¡í•œ ì„œë¸Œì¿¼ë¦¬
        subquery_count = len(re.findall(r'\([^()]*SELECT[^()]*\)', sql_content, re.IGNORECASE))
        if subquery_count > 3:
            patterns.append(f'ë³µì¡í•œ ì„œë¸Œì¿¼ë¦¬ êµ¬ì¡° ({subquery_count}ê°œ)')
        
        # CTE êµ¬ì¡°
        if re.search(r'\bWITH\b.*\bAS\s*\(', sql_content, re.IGNORECASE):
            patterns.append('CTE êµ¬ì¡° ê°ì§€')
        
        return patterns
```

2. **ëˆ„ë½ ë°©ì§€ë¥¼ ìœ„í•œ ë‹¤ì¤‘ íŒŒì„œ ì ìš©**
```python
class MultiParserTableExtractor:
    def __init__(self):
        self.parsers = [
            SqlParserV1(),  # ê¸°ì¡´ íŒŒì„œ
            SqlParserV2(),  # í–¥ìƒëœ íŒŒì„œ  
            RegexBasedParser(),  # Fallback íŒŒì„œ
            ASTBasedParser()  # AST ê¸°ë°˜ íŒŒì„œ (ì •í™•ë„ ìµœìš°ì„ )
        ]
    
    def extract_with_consensus(self, sql_content: str) -> Set[str]:
        """ì—¬ëŸ¬ íŒŒì„œì˜ ê²°ê³¼ë¥¼ ì¡°í•©í•˜ì—¬ ëˆ„ë½ ë°©ì§€"""
        all_results = []
        
        for parser in self.parsers:
            try:
                result = parser.extract_table_names(sql_content)
                all_results.append(result)
            except Exception as e:
                debug(f"Parser {parser.__class__.__name__} ì‹¤íŒ¨: {e}")
                continue
        
        if not all_results:
            return set()
        
        # í•©ì§‘í•©ì„ ê¸°ë³¸ìœ¼ë¡œ í•˜ë˜, ê²€ì¦ì„ í†µí•´ ë…¸ì´ì¦ˆ ì œê±°
        union_result = set().union(*all_results)
        
        # ê²°ê³¼ ê²€ì¦ ë° í•„í„°ë§
        validated_result = self._validate_and_filter(union_result, sql_content)
        
        return validated_result
```

---

## ğŸš€ êµ¬í˜„ ë¡œë“œë§µ

### Phase 1: ê¸´ê¸‰ ê°œì„  (1-2ì£¼)
1. **ë‹¤ì¤‘ ê²½ë¡œ ë™ì  SQL ë¶„ì„ ì ìš©**
   - `_process_conditional_paths()` êµ¬í˜„
   - `foreach` íƒœê·¸ ë‹¤ì¤‘ ì‹œë‚˜ë¦¬ì˜¤ ì²˜ë¦¬

2. **ê²€ì¦ ì‹œìŠ¤í…œ êµ¬ì¶•**
   - `TableExtractionValidator` êµ¬í˜„
   - ì˜ì‹¬ìŠ¤ëŸ¬ìš´ íŒ¨í„´ ê°ì§€ ë° ê²½ê³ 

### Phase 2: í¬ê´„ì  ê°œì„  (3-4ì£¼)  
1. **Include íƒœê·¸ í•´ì„ ì‹œìŠ¤í…œ**
   - `SqlFragmentResolver` êµ¬í˜„
   - í¬ë¡œìŠ¤ íŒŒì¼ ì˜ì¡´ì„± ì¶”ì 

2. **ë³µì¡í•œ SQL êµ¬ì¡° ì§€ì›**
   - `RecursiveSqlAnalyzer` êµ¬í˜„
   - CTE, ë‹¤ì¤‘ ì„œë¸Œì¿¼ë¦¬ ì™„ì „ ì§€ì›

### Phase 3: ê³ ë„í™” (5-6ì£¼)
1. **ë‹¤ì¤‘ íŒŒì„œ ì‹œìŠ¤í…œ**
   - `MultiParserTableExtractor` êµ¬í˜„
   - AST ê¸°ë°˜ íŒŒì„œ ì¶”ê°€

2. **ë™ì  í…Œì´ë¸”ëª… ë§¤í•‘**
   - ë§¤ê°œë³€ìˆ˜-í…Œì´ë¸”ëª… ë§¤í•‘ ì‹œìŠ¤í…œ
   - ë°ì´í„°ë² ì´ìŠ¤ ë©”íƒ€ë°ì´í„° ì—°ë™

---

## ğŸ“Š ê¸°ëŒ€ íš¨ê³¼

### ì •í™•ì„± ê°œì„ 
- **í…Œì´ë¸” ëˆ„ë½ë¥ **: í˜„ì¬ ~15% â†’ ëª©í‘œ ~3% ì´í•˜
- **ë³µì¡í•œ SQL ì²˜ë¦¬ ì„±ê³µë¥ **: í˜„ì¬ ~70% â†’ ëª©í‘œ ~95% ì´ìƒ
- **ë™ì  SQL ë¶„ì„ ì •í™•ë„**: í˜„ì¬ ~60% â†’ ëª©í‘œ ~90% ì´ìƒ

### ì™„ì „ì„± í™•ë³´
- **ëª¨ë“  ì¡°ê±´ ë¶„ê¸° ê²½ë¡œ** ë¶„ì„ìœ¼ë¡œ ëˆ„ë½ ë°©ì§€
- **Include íƒœê·¸ ì™„ì „ í•´ì„**ìœ¼ë¡œ ì°¸ì¡° ë¬´ê²°ì„± í™•ë³´
- **ë‹¤ì¤‘ íŒŒì„œ í•©ì˜ ì•Œê³ ë¦¬ì¦˜**ìœ¼ë¡œ ê²€ì¶œ ì •í™•ë„ ê·¹ëŒ€í™”

### ìœ ì§€ë³´ìˆ˜ì„±
- **ì„¤ì • ê¸°ë°˜ í™•ì¥ì„±** ìœ ì§€
- **ëª¨ë“ˆí™”ëœ íŒŒì„œ êµ¬ì¡°**ë¡œ ê°œë³„ ê°œì„  ê°€ëŠ¥
- **í¬ê´„ì ì¸ ê²€ì¦ ì‹œìŠ¤í…œ**ìœ¼ë¡œ í’ˆì§ˆ ë³´ì¥

---

## ğŸ’¡ ê²°ë¡ 

SourceAnalyzerì˜ íŒŒì‹± ë¡œì§ì€ ê²¬ê³ í•œ ê¸°ë°˜ ìœ„ì— êµ¬ì¶•ë˜ì–´ ìˆìœ¼ë‚˜, **ë‹¤ì´ë‚˜ë¯¹ SQLì—ì„œì˜ í…Œì´ë¸” ì •ë³´ ëˆ„ë½**ì´ë¼ëŠ” í•µì‹¬ ê³¼ì œê°€ ì¡´ì¬í•©ë‹ˆë‹¤. 

ë³¸ ê°œì„ ì•ˆì€ **ì†ë„ë³´ë‹¤ ì •í™•ì„±ì„ ìš°ì„ ì‹œ**í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì€ ì ‘ê·¼ ë°©ì‹ì„ ì œì‹œí•©ë‹ˆë‹¤:

1. **ì™„ì „ì„± ìš°ì„ **: ëª¨ë“  ê°€ëŠ¥í•œ ë¶„ê¸° ê²½ë¡œì™€ ì°¸ì¡° ê´€ê³„ë¥¼ ë¶„ì„
2. **ë‹¤ì¤‘ ê²€ì¦**: ì—¬ëŸ¬ íŒŒì„œì™€ ê²€ì¦ ì‹œìŠ¤í…œì„ í†µí•œ ê²°ê³¼ í™•ì‹ ë„ í–¥ìƒ
3. **ì ì§„ì  êµ¬í˜„**: ì¦‰ì‹œ ì ìš© ê°€ëŠ¥í•œ ê°œì„ ë¶€í„° ë‹¨ê³„ë³„ ê³ ë„í™”

ì´ë¥¼ í†µí•´ **ëˆ„ë½ ì—†ëŠ” ì™„ì „í•œ í…Œì´ë¸” ì •ë³´ ì¶”ì¶œ**ì´ ê°€ëŠ¥í•´ì§€ë©°, í–¥í›„ AI ê¸°ë°˜ ë¶„ì„ì´ë‚˜ ì˜ì¡´ì„± ì¶”ì  ë“±ì˜ ê³ ê¸‰ ê¸°ëŠ¥ì„ ìœ„í•œ ê²¬ê³ í•œ ê¸°ë°˜ì„ ë§ˆë ¨í•  ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.

