# 비교보고서 차이점 원인분석 보고서

**생성일시**: 2025-09-24 22:45:00
**분석대상**: 메소드→쿼리→테이블→컬럼, 조인조건 도출 차이점 원인
**분석방법**: 개발자 대화내용 vs 실제구현 검토

## 1. 개발 목표 vs 실제 구현 차이 분석

### 1.1 **개발자가 설계한 3단계 파이프라인**

```
1단계: 쿼리 추출 및 저장(SqlContent.db)
├─ JAVA: 문자열변수 concatenation 추출 → 쿼리변수 딕셔너리
├─ XML: Mybatis 태그 제거 → 쿼리만 추출 → 딕셔너리
└─ JPA: @Query(...) 괄호 안 문자열만 추출 → 딕셔너리

2단계: 테이블 추출 (공통화)
└─ FROM절, INSERT INTO, UPDATE-SET, JOIN-ON에서 테이블명 추출

3단계: 조인관계 추출 (공통화)
├─ WHERE ... 조인조건 → JOIN_IMPLICIT
├─ JOIN ... ON 조인조건 → JOIN_EXPLICIT
└─ MERGE ... ON 조인조건 → JOIN_MERGEON
```

### 1.2 **실제 구현 상태 검증**

| 구분 | 개발 목표 | 실제 구현 상태 | 원인 |
|------|----------|---------------|------|
| **1단계 JAVA** | 문자열변수 딕셔너리 생성 | ✅ 구현됨 | 정상 |
| **1단계 XML** | 태그제거→쿼리딕셔너리 | ⚠️ 복잡한 DOM파서 사용 | **목표와 다름** |
| **1단계 JPA** | @Query 괄호 안 문자열만 | ⚠️ 복잡한 정규식 파싱 | **목표와 다름** |
| **2단계 공통** | 테이블 추출 공통화 | ✅ 구현됨 | 정상 |
| **3단계 공통** | 조인관계 분석 공통화 | ❌ 미구현 | **핵심 누락** |
| **CALL_QUERY** | 메소드→쿼리 관계 생성 | ❌ 로직 오류 | **핵심 누락** |

## 2. **핵심 문제점 상세 분석**

### 2.1 **CALL_QUERY 관계 생성 실패 (7개 vs 66개)**

#### **문제 1: 메소드-쿼리 연결 로직 오류**
```python
# 현재 java_parser.py:647-648 코드
if 'method_name' in query:
    method_name = query['method_name']
```

**문제점**: 쿼리에 `method_name` 필드가 제대로 설정되지 않음

#### **문제 2: 개발목표와 실제구현 괴리**
- **개발목표**: 1단계에서 변수명:쿼리 딕셔너리 생성 → 메소드명과 쿼리 자동 매핑
- **실제구현**: 쿼리 추출 시 메소드명 매핑이 누락되어 관계 생성 불가

### 2.2 **XML Mybatis 파서 복잡화 문제**

#### **개발목표**: 심플한 태그 제거 방식
```python
# 목표: 태그만 제거하는 심플 파서
{"updateProductStock": '''UPDATE products
        SET stock_quantity = stock_quantity + #{quantity}
        WHERE product_id = #{productId}'''}
```

#### **실제구현**: 복잡한 DOM 파서 사용
- ET.parse, DOM파서 등 복잡한 XML 파싱
- 개발자가 원한 "태그만 제거" 방식과 완전히 다름
- **결과**: 파싱 오류 증가, 성능 저하, 유지보수성 악화

### 2.3 **JPA 쿼리 추출 복잡화 문제**

#### **개발목표**: @Query 괄호 안 문자열만 추출
```python
# 목표: 단순 괄호 안 문자열 추출
@Query("SELECT u FROM User u WHERE ...")
→ {'methodName': "SELECT u FROM User u WHERE ..."}
```

#### **실제구현**: 복잡한 정규식 파싱
- 문법적 정확성 검증하는 복잡한 파서
- 개발자가 원한 "괄호 안 문자열만" 방식과 다름
- **결과**: 일부 패턴 누락, 성능 저하

### 2.4 **3단계 조인관계 분석 미구현**

#### **개발목표**: 공통화된 조인관계 분석
```python
# 목표: 3가지 패턴 처리
WHERE ... <조인조건> → JOIN_IMPLICIT  (8개 예상 → 0개 실제)
JOIN ... ON <조인조건> → JOIN_EXPLICIT  (12개 예상 → 1개 실제)
MERGE ... ON <조인조건> → JOIN_MERGEON  (0개)
```

#### **실제구현**: 조인분석 로직 부재
- `sql_join_analyzer.py` 모듈은 있지만 제대로 호출되지 않음
- JOIN 패턴 인식 로직이 누락되어 관계 생성 실패

## 3. **성능 차이 원인 분석**

### 3.1 **왜 SQL_SELECT가 104개나 나왔는가? (35개 → 104개)**

#### **원인**: 복잡한 파서의 부작용
- DOM 파서가 예상보다 많은 SQL 패턴을 추출
- 동적 쿼리, 인라인 쿼리까지 과도하게 추출
- **부작용**: 정밀도는 높아졌지만 개발 목표와 괴리

### 3.2 **왜 CALL_METHOD가 3,087개나 나왔는가? (45개 → 3,087개)**

#### **원인**: 임시 METHOD 컴포넌트 전략의 성공
- 개발목표에는 없었지만 관계분석을 위한 우회방법
- SQL 관련 메소드들을 임시로 METHOD 컴포넌트 생성
- **결과**: CALL_METHOD는 폭증했지만 정작 CALL_QUERY는 실패

### 3.3 **왜 API_URL이 282개나 나왔는가? (14개 → 282개)**

#### **원인**: JSP/JS 파싱 강화
- 개발목표 범위를 벗어난 프론트엔드 분석 강화
- 모든 AJAX, form action, 링크까지 API_URL로 추출
- **부작용**: 범위 확장으로 노이즈 증가

## 4. **개발목표 대비 달성도 평가**

### 4.1 **목표 달성도**

| 핵심 목표 | 달성도 | 평가 |
|----------|-------|------|
| **메소드→쿼리 관계** | 10% (7/66) | **심각한 실패** |
| **쿼리→테이블 관계** | 196% (139/71) | **과달성** |
| **조인조건 도출** | 5% (1/20) | **심각한 실패** |
| **3단계 공통화** | 30% | **부분 실패** |

### 4.2 **핵심 문제 요약**

1. **심플파서 목표 실패**: DOM파서, 복잡 정규식 등 복잡한 방식 사용
2. **CALL_QUERY 핵심 실패**: 메소드-쿼리 연결이 개발의 핵심이었으나 실패
3. **3단계 공통화 미완성**: 조인관계 분석이 제대로 호출되지 않음
4. **목표 범위 초과**: SQL_SELECT, API_URL 등 불필요한 과추출

## 5. **문제 해결 방안**

### 5.1 **즉시 수정 필요사항**

#### **5.1.1 XML Mybatis 파서 심플화**
```python
# 현재: 복잡한 DOM 파서
# 수정: 정규식으로 태그만 제거
def extract_mybatis_queries_simple(xml_content):
    # <select id="queryId">...</select> → {"queryId": "..."}
    pattern = r'<(select|insert|update|delete|merge)\s+id="([^"]+)"[^>]*>(.*?)</\1>'
    # 태그 제거 후 쿼리만 추출
```

#### **5.1.2 JPA 쿼리 추출 심플화**
```python
# 현재: 복잡한 정규식 파싱
# 수정: 괄호 안 문자열만 추출
def extract_jpa_queries_simple(java_content):
    # @Query("...") → 괄호 안 문자열만 추출
    # 메소드명과 함께 딕셔너리 생성
```

#### **5.1.3 CALL_QUERY 관계 생성 수정**
```python
# 1단계에서 메소드명과 쿼리를 함께 추출하도록 수정
# 메소드 내 쿼리 추출 시 메소드명을 query['method_name']에 저장
```

### 5.2 **장기 개선사항**

#### **5.2.1 3단계 조인분석 로직 완성**
- sql_join_analyzer 제대로 호출
- WHERE, JOIN, MERGE 패턴별 조인관계 생성

#### **5.2.2 목표 달성 중심 리팩토링**
- 불필요한 과추출 제거
- 핵심 목표(메소드→쿼리→테이블→조인)에 집중

## 6. **결론**

### 6.1 **근본 원인**
1. **개발목표 이탈**: 심플파서 대신 복잡한 파서 구현
2. **핵심기능 누락**: 메소드-쿼리 연결이라는 핵심 기능 실패
3. **3단계 공통화 미완성**: 조인관계 분석 로직이 제대로 연결되지 않음

### 6.2 **우선순위**
1. **최우선**: CALL_QUERY 관계 생성 로직 수정
2. **2순위**: XML/JPA 파서 심플화
3. **3순위**: 3단계 조인분석 완성

### 6.3 **기대효과**
- CALL_QUERY: 7개 → 66개 (약 900% 개선)
- JOIN 관계: 1개 → 20개 (약 2000% 개선)
- 전체 성능: 73점 → 90점 이상 달성 가능

**핵심**: 개발자의 원래 의도대로 "심플하고 목표 중심적인" 파서로 재구현이 필요합니다.